#!/bin/zsh

#  semantic-history
#  Terminal
#
#  Created by Maxim Puchkov on 2020-04-17.
#  Copyright Â© 2020 Maxim Puchkov. All rights reserved.


# Text clicked in iTerm2
typeset clicked_path="$1"
notify $clicked_path '' ''
# If selected filepath contains extra
# characters, then truncate them
typeset filepath="$clicked_path"
while [[ ! -r "$filepath" ]]; do
  if [[ -z "$filepath" ]]; then
    return 1
  fi
  filepath="${filepath:0:-1}"
done




# Open flags
typeset -a FLAGS=()
# Flags for readable files
if [[ -r "$filepath" ]] &&
   [[ ! -d "$filepath" ]]; then
  FLAGS+=(-a Xcode)
fi



# Open file
typeset -i exit_code=0
open $FLAGS -- "$filepath"
let exit_code=$?

if [[ $exit_code -ne 0 ]]; then
  notify "Cannot open file: ${clicked_path}" "Error $exit_code" "$0"
fi

return 0



() {
  # Path to the file
  typeset filepath=$1
  # If filepath contains extra characters
  # try to delete last character until path
  # refers to a readable file
  while [[ ! -r $filepath ]]; do
    if [[ -z $filepath ]]; then
      return 1
    fi
    filepath=${filepath:0:-1}
  done
  
  if [[ -r $filepath ]] && [[ ! -d $filepath ]]; then
    flags+=(-a "$OPEN_APPLICATION")
  fi
  
  open $flags $filepath
  return $?
} $1




# Check exit code
typeset -i exit_code=$?
if [[ $exit_code -ne 0 ]]; then
  typeset title="Error (${exit_code})"
  typeset subtitle="${0:t}"
  typeset message="Cannot open '${1}'"
  
  
  # Display UI notification if `notify' is intalled
  # or print the message to console
  typeset notification_cmd='notify'
  if ! hash $notification_cmd; then
    $notification_cmd "$message" "$title" "$subtitle"
  else
    printf '%s\n%s\n%s\n\n' "$message" "$title" "$subtitle" >&2
  fi
fi

return 0
