#!/bin/zsh

#  get
#  zsh
#
#  Created by Maxim Puchkov on 2020-08-02.
#  Copyright Â© 2020 Maxim Puchkov. All rights reserved.


# Name:   get
# Usage:  get [-A array] [-f flag [...]]
#             [-o option[:default] [...]] -- argv
emulate -L zsh


# Load 'zformat' and 'zparseopts' zsh builtin commands
if ! zmodload -F zsh/zutil -b:zformat b:zparseopts &>/dev/null; then
    error -1 'Unable to load zsh module'
    return 1
fi


# Split array in two arrays 'left_split' and 'right_split' at
# next occurrence of str:
#   array(1..n)  ~>  left_split(1..i), right_split(i+1,n)
function get_split_arrays() {
    if [[ $# -eq 0 ]]; then
        usage 'No input.' "$0 str [values,]" "$0 -- a1 a2 -- b1 b2"
        pcre_compile -L
        return 2
    fi
    typeset str="$1"
    shift
    typeset -i index=${argv[(i)${~str}]}
    typeset -ag left_split right_split
    left_split=(${argv[1,$index]})
    right_split=(${argv[$index+1,#]})
    return 0
}


#MARK: - get
# Options of 'get' (all arguments up to '--')
function get_names() {
    # Find arguments with prefix '-' ('-f', '-o', etc.)
    typeset -a matches=(${(M)argv:#-*})
    if [[ -z $matches ]]; then
        error -1 'Unknown option descriptions.'
    fi
    
    # For each option, determine indices of its
    # first and last arguments
    typeset -aU opt_args
    typeset -i i max_index
    let max_index=$#matches-1
    for i in {1..$max_index}; do
        # Current and next options of 'get'
        current=$matches[$i]
        next=$matches[$i+1]
        # Select all arguments in-between current
        # and next option in 'argv'
        let begin=$argv[(wi)$current]
        let end=${argv[(wi)$next]}
        opt_args=($argv[$begin+1,$end-1])
        # Pass arguments to current option
        case $current in
            -f) flag_names+=($opt_args) ;;
            -o) opt_names+=($opt_args)  ;;
            -A) reply=$opt_args[1]      ;;
        esac
        shift $#opt_args
    done
    return 0
}


#MARK: - zparseopts
# Options of 'zparseopts' (all arguments after '--')
function get_values() {
  # Recognized flags/options
  typeset -a flags
  typeset -A opts
  flags=()
  opts=()
  # Set 'specs' for the 'zparseopts' builtin
  typeset -a specs
  specs=(${^flag_names}'=flags' ${^option_names}':=opts')
  # Parse parameters
  if ! builtin zparseopts -D -E -- $specs &>/dev/null; then
    error -$? -c +A 'zparseopts failed to parse option specs.'
  fi
  return $?
}


# Split positional arguments at '--'
typeset delim='--'
if [[ $argv[(wi)$delim] -gt $# ]]; then
    error -1 'Delimiter ${delim} was not found.'
fi
get_split_arrays $delim $argv
options_desc=($left_split)
options_spec=($right_split)


# Declare output array
typeset reply
if [[ -z $reply ]]; then
    reply='reply'
fi
typeset -Ag $reply


# Get names of flags and options
typeset -aU flag_names opt_names
flag_names=()
opt_names=()
get_names $options_desc

# Exit if no flag or option names were recognized
if [[ -z $flag_names ]] &&
   [[ -z $opt_names ]]; then
    error -1 'Missing descriptions of flags and/or options.'
fi


# Parse and store recognized option values in an array
get_values $options_names



echo;echo;echo
print-var argv


(red "'get' args: $options_desc")>&2
(blue "'zparseopts' args: $options_spec")>&2
print -- "  >>> $flag_names ++ $opt_names" >&2

return 0




#
#
#    #MARK: - Parameters for 'get-arguments'
#    # Names of flags and options
#    typeset -aU flag_names option_names
#    flag_names=()
#    option_names=()
#    # Default values
#    typeset -A defaults
#    defaults=( [opt-unset]="''"
#               [flag-set]=1
#               [flag-unset]=0 )
#    # Result array name and type
#    typeset array_{id,type}
#    array_id='optlist'
#    array_type='-A'
#
#
#    typeset -a cmds
#    cmds=()
#    while [[ $1 =~ '^-' ]] && [[ $1 != '--' ]]; do
#        typeset -a option_args=(${argv:2:${${argv:2}[(i)-*]}})
#        print-var last_arg args
#        case $1 in
#            (-o|--order) cmds+=(cutline_ordered) ;;
#            (-u|--unordered) cmds+=(cutline_unordered) ;;
#        esac
#        shift $#args
#    done
#
#
#
#    #MARK: - Set 'get-arguments' Options
#    # Parse arguments which begin with '-'
#    # or '+' (command options)
#    while [[ $1 =~ '^[-+]' ]] &&
#          [[ $1 != '--' ]]; do
#        # Arguments until the next command option
#        # are parameters for the current option
#        local -a list=()
#        let last_index=${${argv:2}[(i)[-+]*]}
#        set -A list ${argv[2,$last_index]}
#
#        case $1 in
#            # Flags
#            -f|--flags)
#                shift
#                flag_names+=($list)
#                shift ${#list}
#            ;;
#
#            # Options
#            -o|--opts|--options)
#                shift
#                local opt_spec=''
#                for opt_spec in $list; do
#                    case $opt_spec in
#                        *:*)
#                            name=${opt_spec%:*}
#                            value=${opt_spec#*:}
#                            defaults+=( [-$name]=$value )
#                        ;;
#                        *)  name=$opt_spec
#                        ;;
#                    esac
#                    option_names+=($name)
#                done
#                shift ${#list}
#            ;;
#
#            # Specify output array name and type
#            -A|-a)
#                array_type=$1
#                array_id=$2
#                shift 2
#            ;;
#
#            # Stop parsing parameters
#            *)  break ;;
#        esac
#    done
#    [[ $1 == '--' ]] && shift
#
#
#    # Exit if no flag or option names were recognized
#    if [[ -z $flag_names ]] &&
#       [[ -z $option_names ]]; then
#        error -1 'Missing descriptions of flags and/or options.'
#    fi
#
#
#
#
#
#    #MARK: - Parse Arguments
#    # Recognized flags/options
#    typeset -a flags
#    typeset -A opts
#    flags=()
#    opts=()
#    # Set 'specs' for the 'zparseopts' builtin
#    typeset -a specs
#    specs=( ${^flag_names}'=flags' ${^option_names}':=opts' )
#
#    # Parse parameters
#    builtin zparseopts -D -E -- $specs &>/dev/null
#    local -i parse_status=$?
#    if [[ $parse_status -ne 0 ]] then
#        ( name='zparseopts' \
#            error -$parse_status -c "Invalid '%U\${name}%u' specs: {\${specs}}." )
#    fi
#
#    # Recognized options and options with default values
#    typeset -a {opts,def}_keys
#    opts_keys=(${(k)opts})
#    def_keys=(${(Mk)defaults:#-*})
#    # Non-recognized flags/options
#    typeset -a unset_{flags,opts}
#    unset_opts=(${${:-'-'${^option_names}}:|opts_keys})
#    unset_flags=(${${:-'-'${^flag_names}}:|flags})
#
#    # Set remaining arguments of the caller
#    trap '{ set -- '"$argv"'; [[ $1 == "--" ]] && shift; }' EXIT
#
#
#
#
#    #MARK: - Result Array
#    # Initialize the result array
#    typeset -A result
#    result=()
#    # Append recognized 'flags' to 'result'
#    # as (flag_name, 1) pairs
#    for name in $flags; do
#        result+=( [$name]=$defaults[flag-set] )
#    done
#    # Append recognized 'opts' to 'result' as
#    # (option_name, option_value) pairs
#    for name value in ${(kv)opts}; do
#        result+=( [$name]=$value )
#    done
#
#
#    # If an option is not set but has a default value,
#    # set option to its default value
#    local {default,given}_value
#    for name in $def_keys; do
#        default_value=${defaults[(k)$name]}
#        given_value=${result[(k)$name]}
#        if [[ -n $default_value ]] &&
#           [[ -z $given_value ]]; then
#            result+=( [$name]=$default_value )
#        fi
#    done
#
#
#    # Set the output [associative] array to the
#    # (name, value) pairs of result array
#    unset $array_id
#    typeset $array_type -g $array_id
#    set -A $array_id ${(kv)result}
#    return 0
#}
