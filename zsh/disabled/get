#!/bin/zsh

#  get
#  zsh
#
#  Created by Maxim Puchkov on 2020-08-02.
#  Copyright Â© 2020 Maxim Puchkov. All rights reserved.


# Name:   get
# Usage:  get [-A array] [-f flag [...]]
#             [-o option[:default_value] [...]] -- argv
emulate -L zsh
# Print usage
if [[ $# -eq 0 ]]; then
  usage 'No input' \
    "${0} -f flag -o opt -- -flag -opt optval"
  return 2
fi
# Load required zsh builtin commands
if ! zmodload -F zsh/zutil b:zparseopts &>/dev/null; then
  error -1 'Unable to load zsh module'
  return 1
fi



#MARK: - Functions
typeset -x CALLER=$(caller)
if [[ $CALLER == $SHELL ]] &&
   [[ $WLOG -eq 1 ]]; then
  # Log recognized option names and values
  function get_wlog() {
    if [[ $1 == '-T' ]]; then
      builtin print -Pn -- '$$ [%D %*]\t'
      shift
    fi
    /usr/bin/sed -E \
      -e 's/<([^>]+)>/<'$(esc 33 -t '\1' -r 0)'>/g' \
      < <(print -- $argv) \
      >&2
    return 0
  }
else
  typeset -f get_wlog() return 0
fi


# Split array in two arrays 'left_split' and 'right_split' at
# next occurrence of 'str':
#   array(1..n)  ~>  left_split(1..i), right_split(i+1,n)
function get_split_arrays() {
  [[ $# -eq 0 ]] && error -1 'No input.'
  local str="$1"
  shift
  # Get position of the string in 'argv'
  local -i index=${argv[(i)${~str}]}
  typeset -ag left_split right_split
  left_split=(${argv[1,$index]})
  right_split=(${argv[$index+1,#]})
  return 0
}

# Split positional arguments at '--'
typeset -a options_desc options_spec
typeset delim='--'
if [[ $argv[(wi)$delim] -gt $# ]]; then
  error -1 'Delimiter ${delim} was not found.'
fi
split-array -s "$delim" \
  -l options_desc -r options_spec $argv

get_wlog "Splitting argv=<$argv> at delim=<$delim>"
get_wlog "Desc=<$options_desc>; Spec=<$options_spec>"




#MARK: - get
# Options of 'get' (all arguments up to '--')
function get_names() {
  if [[ $1 == '-A' ]]; then
    reply_array_id=$2
    shift 2
  fi
  # Find arguments with prefix '-' ('-f', '-o', etc.)
  typeset -a matches=(${(M)argv:#--*})
  if [[ $#matches -le 1 ]]; then
    return 1
  fi
  
  typeset -aU opt_args
  local arg default_value
  # Find names in 'argv' starting with a '-'
  # and select all arguments between them
  local -i max_index i
  let max_index=${#matches}-1
  for i in {1..$max_index}; do
    # Current and next options of 'get'
    current=${matches[$i]}
    next=${matches[$(( $i + 1 ))]}
    # Select arguments from 'argv' for current option
    #   --flags [begin..end] --opts [begin..end]
    let begin=${argv[(wi)$current]}+1
    let end=${argv[(wi)$next]}-1
    opt_args=(${argv[$begin,$end]})
    #
    for arg in $opt_args; do
      name="${arg%%,*}"
      # Default value
      if [[ $arg =~ ':=' ]]; then
        value=${arg##*:=}
        opt_args[(i)$arg]=${arg%:=*}
        arg=${arg%:=*}
        default_values+=([$name]="$value")
      fi
      # Alias names
      if [[ $arg =~ ',' ]]; then
        other_names="${arg#*,}"
        opt_args[(i)$arg]="${name}"
        alias_names+=([$name]="${other_names}")
      fi
    done
    
    # Pass arguments to current option
    setopt extendedglob
    case $current in
      (--f|--flags#)
        flag_names+=($opt_args)
      ;;
      (--o|--options#)
        opt_names+=($opt_args)
      ;;
      (*)
        warning 'Bad option ${current}.'
      ;;
    esac
  done
  
  if [[ -z $flag_names ]] &&
     [[ -z $opt_names ]]; then
    return 1
  fi
  
  get_wlog "Output array identifier is <${reply_array_id}>."
  get_wlog "Flag names are <${flag_names}>."
  get_wlog "Option names are <${opt_names}>."
  get_wlog "Option default values are <${(kv)default_values}>."
  get_wlog "Alias names are <${(kv)alias_names}>."
  return $?
}


# Parse names, default values, aliases of
# flags and options; and identifier of the
# output array.
typeset -aU flag_names;     flag_names=()
typeset -aU opt_names;      opt_names=()
typeset -A alias_names;     alias_names=()
typeset -A default_values;  default_values=()
typeset reply_array_id='reply'
# Exit if no flag or option names were recognized
get_names $options_desc
if [[ $? -ne 0 ]]; then
  error -1 'Cannot parse option names.'
fi





#MARK: - zparseopts
# Options of 'zparseopts' (all arguments after '--')
function get_values() {
  # Set 'specs' for the 'zparseopts' builtin
  local -a specs
  specs=(${^flag_names}'=flags' ${^opt_names}':=opts')
  # Parse parameters
  if ! builtin zparseopts -D -E -K -M -- $specs &>/dev/null; then
    return 1
  fi
  if [[ ${argv[-1]} == '--' ]]; then
    shift -p
  fi
  set -A rest $argv
  return 0
}


# Parse and store recognized option values in an array
# Recognized flags/options
typeset -ag flags;          flags=()
typeset -Ag opts;           opts=()
typeset -a rest;            rest=()
get_values $options_spec
if [[ $? -ne 0 ]]; then
  error -1 +A 'zparseopts failed to parse option specs.'
fi

# Initialize output array
# Recognized options and options with default values
typeset -a {opts,def}_keys
opts_keys=(${(k)opts})
def_keys=(${(Mk)defaults:#--*})
# Non-recognized flags/options
typeset -a unset_{flags,opts}
unset_opts=(${${:-'-'${^opt_names}}:|opts_keys})
unset_flags=(${${:-'-'${^flag_names}}:|flags})
# Set remaining arguments of the caller
trap '{set -- '${(j: :)${(q)rest}}';}' EXIT





#MARK: - Result Array
# Initialize the result array
typeset -A result
result=()
# Append recognized flags as (name, 1) pairs
for name in $flags; do
  result+=( [$name]=1 )
done
# Append recognized options as (name, value) pairs
for name value in ${(kv)opts}; do
  result+=( [$name]=$value )
done


# If an option is not set but has a default value,
# set option to its default value
#local {default,given}_value
#for name in $def_keys; do
#  default_value=${defaults[(k)$name]}
#  given_value=${result[(k)$name]}
#  if [[ -n $default_value ]] &&
#     [[ -z $given_value ]]; then
#      result+=( [$name]=$default_value )
#  fi
#done

# Set the output associative array to the
# (name, value) pairs of result array
typeset -Ag $reply_array_id
set -A ${reply_array_id} ${(kv)result}

return 0




#
#
#    #MARK: - Parameters for 'get-arguments'
#    # Names of flags and options
#    typeset -aU flag_names option_names
#    flag_names=()
#    option_names=()
#    # Default values
#    typeset -A defaults
#    defaults=( [opt-unset]="''"
#               [flag-set]=1
#               [flag-unset]=0 )
#    # Result array name and type
#    typeset array_{id,type}
#    array_id='optlist'
#    array_type='-A'
#
#
#    typeset -a cmds
#    cmds=()
#    while [[ $1 =~ '^-' ]] && [[ $1 != '--' ]]; do
#        typeset -a option_args=(${argv:2:${${argv:2}[(i)-*]}})
#        print-var last_arg args
#        case $1 in
#            (-o|--order) cmds+=(cutline_ordered) ;;
#            (-u|--unordered) cmds+=(cutline_unordered) ;;
#        esac
#        shift $#args
#    done
#
#
#
#    #MARK: - Set 'get-arguments' Options
#    # Parse arguments which begin with '-'
#    # or '+' (command options)
#    while [[ $1 =~ '^[-+]' ]] &&
#          [[ $1 != '--' ]]; do
#        # Arguments until the next command option
#        # are parameters for the current option
#        local -a list=()
#        let last_index=${${argv:2}[(i)[-+]*]}
#        set -A list ${argv[2,$last_index]}
#
#        case $1 in
#            # Flags
#            -f|--flags)
#                shift
#                flag_names+=($list)
#                shift ${#list}
#            ;;
#
#            # Options
#            -o|--opts|--options)
#                shift
#                local opt_spec=''
#                for opt_spec in $list; do
#                    case $opt_spec in
#                        *:*)
#                            name=${opt_spec%:*}
#                            value=${opt_spec#*:}
#                            defaults+=( [-$name]=$value )
#                        ;;
#                        *)  name=$opt_spec
#                        ;;
#                    esac
#                    option_names+=($name)
#                done
#                shift ${#list}
#            ;;
#
#            # Specify output array name and type
#            -A|-a)
#                array_type=$1
#                array_id=$2
#                shift 2
#            ;;
#
#            # Stop parsing parameters
#            *)  break ;;
#        esac
#    done
#    [[ $1 == '--' ]] && shift
#
#
#    # Exit if no flag or option names were recognized
#    if [[ -z $flag_names ]] &&
#       [[ -z $option_names ]]; then
#        error -1 'Missing descriptions of flags and/or options.'
#    fi
#
#
#
#
#
#    #MARK: - Parse Arguments
#    # Recognized flags/options
#    typeset -a flags
#    typeset -A opts
#    flags=()
#    opts=()
#    # Set 'specs' for the 'zparseopts' builtin
#    typeset -a specs
#    specs=( ${^flag_names}'=flags' ${^option_names}':=opts' )
#
#    # Parse parameters
#    builtin zparseopts -D -E -- $specs &>/dev/null
#    local -i parse_status=$?
#    if [[ $parse_status -ne 0 ]] then
#        ( name='zparseopts' \
#            error -$parse_status -c "Invalid '%U\${name}%u' specs: {\${specs}}." )
#    fi

#    # Recognized options and options with default values
#    typeset -a {opts,def}_keys
#    opts_keys=(${(k)opts})
#    def_keys=(${(Mk)defaults:#-*})
#    # Non-recognized flags/options
#    typeset -a unset_{flags,opts}
#    unset_opts=(${${:-'-'${^option_names}}:|opts_keys})
#    unset_flags=(${${:-'-'${^flag_names}}:|flags})
#
#    # Set remaining arguments of the caller
#    trap '{ set -- '"$argv"'; [[ $1 == "--" ]] && shift; }' EXIT
#
#
#
#
#    #MARK: - Result Array
#    # Initialize the result array
#    typeset -A result
#    result=()
#    # Append recognized 'flags' to 'result'
#    # as (flag_name, 1) pairs
#    for name in $flags; do
#        result+=( [$name]=$defaults[flag-set] )
#    done
#    # Append recognized 'opts' to 'result' as
#    # (option_name, option_value) pairs
#    for name value in ${(kv)opts}; do
#        result+=( [$name]=$value )
#    done
#
#
#    # If an option is not set but has a default value,
#    # set option to its default value
#    local {default,given}_value
#    for name in $def_keys; do
#        default_value=${defaults[(k)$name]}
#        given_value=${result[(k)$name]}
#        if [[ -n $default_value ]] &&
#           [[ -z $given_value ]]; then
#            result+=( [$name]=$default_value )
#        fi
#    done
#
#
#    # Set the output [associative] array to the
#    # (name, value) pairs of result array
#    unset $array_id
#    typeset $array_type -g $array_id
#    set -A $array_id ${(kv)result}
#    return 0
#}
