# User-specific functions for interactive zsh(1) shells.


# Open default macOS Terminal.
function term1() {
    open -g '/System/Applications/Utilities/Terminal.app'
}
# Open iTerm2.
function term2() {
    open -g '/Applications/iTerm.app'
}

# Open in editor.
function edit() {
    $EDITOR "$@"
}
# Calculate
function calc() {
    noglob expr "$@"
}






#MARK: - Oh-my-zsh Plugins
# Open oh-my-zsh root directory.
function myzsh() {
    open "$ZSH"
}
# Open oh-my-zsh/plugins.
function myplugins() {
    open "$ZSH/plugins"
}
# List plugins.
function list-plugins() {
    ls "$ZSH/plugins"
}
# Display information about an oh-my-zsh plugin.
function info-plugin() {
    local plugin_name="$1"
    open -a Xcode -g "$ZSH/plugins/$plugin_name/README"*
}
# Print plugin's README to stdout.
function cat-plugin() {
    local plugin_name="$1"
    cat "$ZSH/plugins/$plugin_name/README"*
}
# View next plugin's.
function next-plugin() {
    # Array of all plugin
    local all_plugins=($( command ls -1 "$ZSH/plugins" ))
    read_array arr
    # Seen/unseen plugins
    local seen=( $arr )
    local notseen=( ${all_plugins:|seen} )
    # Exit if seen all
    if [[ ${#notseen} -eq 0 ]]; then
        echo "<<< $(b_greenbg 'ALL PLUGINS SEEN') >>>"
        return 1
    fi
    # Next plugin is the first unseen
    local next=${notseen[1]}
    arr+=( $next )
    save_array arr
    # Sizes
    local N=${#all_plugins}
    local n=$(( ${#seen} + 1 ))
    echo "Opening plugin $( b_magenta "#${n} - $next"  ) out of ${N} total."
    info-plugin $next
}


#MARK: - Oh-my-zsh Themes
# List themes.
function list-themes() {
    local themes=(${$( command ls "$ZSH/themes" )%.zsh-theme})
    echo $themes
}
# View next theme.
function next-theme() {
    # All themes
    local themes=($( list-themes ))
    # Tried themes
    touch "$DEV/Library/Data/tried_themes.array"
    typeset -a tried_themes
    read_array tried_themes
    # Not tried themes
    local not_tried_themes=( ${themes:|tried_themes} )
    if [[ ${#not_tried_themes} -eq 0 ]]; then
        echo "<<< $(b_greenbg 'ALL THEMES TRIED') >>>"
        return 1
    fi
    # Pick first theme which has not been tried yet
    local next=${not_tried_themes[1]}
    tried_themes+=( $next )
    save_array tried_themes
    export ZSH_THEME=$next
    re "Current theme: $next"
}




function pygments-styles() {
    local list=($( pygmentize -L 'styles' ))
    printf '%s' "$list" | grep -E '\* [[:alnum:]-]*' -o | sed -E 's/\* //g'
}


# Pass/Fail symbols.
function pass() {
    printf '%s\n' "$(b_green '✔︎')"
    return 0
}
function fail() {
    printf '%s\n' "$(b_bred '✘')"
    return 1
}


# Hex print.
function hexpr() {
    printf '%s' $(xxd -p "${@:?}")
}
function hexprl() {
    echo ${#$(hexpr "$@")}
}
function hexprline() {
    echo $(hexpr "$@")
}


# Uppercase.
function uc() {
    printf '%s' "${(U)@}"
}
# Remove whitespaces.
function nosp() {
    printf '%s' "${@// /}"
}

# function
# date
function date_list_formats() {
    typeset -ag formats
    formats=()
    man strftime |
        colcrt - |
        fgrep -- '%' |
        awk '{ print $1 }' |
        while read fmt; do
            if [[ $fmt[1] == '%' ]]; then
                formats+=($fmt);
            fi
        done
    print -a -C 8 ${formats}
}
function date_formats_preview() {
    for format in $( date_list_formats ); do
        local full_command="\$( $(green "date -j +\'$format\'") )"
        local preview="$(b_byellow \'$( date -j +$format )\')"
        print -a -C2 "${format}\t ${full_command}\t" "${(Q)preview}"
    done
}


function magnetize() {
    open /Applications/Magnet.app -g
    local positions=('← Left ◧' '→ Right ◨' '↑ Up ⬒ ' '↓ Down ⬓')
    local group1=("⇧⌘"${^positions})
    printf "$(underline %s):\n" 'Magnet Commands'
    for cmd in $group1; do
        printf '%-*s' 35 "$(bold $cmd)"
    done
    echo
    
    #'Top Left ◰' 'Top Right ◳'
    #'Bottom Left ◱' 'Bottom Right ◲'
#    for cmd in $group2; do
#        printf '%-*s' 35 "$(bold $cmd)"
#    done
}

function letters() {
    
    if [[ $# -gt 2 ]]; then
        local ordered=( ${(o)@} )
        printf "Ordered: $(bgreen '%s').\n" "$ordered"
        printf "First:   $(bold '%s');   last: $(bold '%s').\n" "${ordered[1]}" "${ordered[-1]}"
        return 0
    fi
    
    typeset -ag A
    typeset -ag N
    
    A=({A..Z})
    N=({1..26})
    local letter=${1[1]:-L}
    local compareTo=${2[1]}
    
    
    local index=${A[(wi)$letter]}
    if [[ $index -gt ${#A} ]]; then
        return 1
    fi
    A[$index]=$(b_bred $A[$index])
    N[$index]=$(b_bred $N[$index])
    
    
    local index2=${A[(wi)$compareTo]}
    A[$index2]=$(blue $A[$index2])
    N[$index2]=$(blue $N[$index2])
    
    { printf '  %s' $A; echo; printf '%s ' $N; echo } |
        column -t
}


# Lists every executable in PATH.
function show-executables() {
    print -l ${^path}/*(-*N)
}



function new-file() {
    #if
    local dir
    for dir in "$@"; do
        if [[ ! -d $d ]]; then continue; fi
        echo "$dir" > $dir/new-file
    done
}


function printf_formats() {
    open 'https://www.linuxjournal.com/content/bashs-built-printf-function'
}
function zshrc_template() {
    open 'https://dev.to/manan30/what-is-the-best-zshrc-config-you-have-seen-14id'
}

# 
function lorem() {
    printf "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse nec convallis neque, eget interdum diam. Donec sit amet arcu faucibus, lobortis lacus sed, molestie massa. Vestibulum eget cursus ligula. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Integer sit amet diam rutrum, dictum eros at, dignissim orci. Nullam pulvinar pellentesque mollis. Etiam ultrices fermentum augue, vitae imperdiet mi. Nullam nec lectus nec sem eleifend pharetra. Cras congue orci vel aliquam fermentum. Ut quis metus quis mauris dapibus cursus ac vitae leo.\n"
}

# ls format
function datels() {
    date -j +'%d %b %R'
}
function statls() {
    local cmd=(stat -t '%d %b %R' -f '%-Sp %+2l %-Su %+Sg %-4z %.12Sm %-SN %n' "$@")
    if [[ $# -eq 0 ]]; then
        cmd=( echo $cmd )
    fi
    $cmd
}


# Dash
function docsets() {
    local dsets
    dsets=(${(@f)"$(find "$HOME/Library/ApplicationSupport/Dash" \
                         -name '*.docset')"})
    printf 'Found %d docsets:\n' ${#dsets}
    printf "  $(yellow '%s')\n" ${(o)dsets:t}
}

function h() {
    local n=100; n=${@:+$HISTCMD}
    history -${n} | fgrep "${@:-''}"
}


function irand() {
    integer max=$1
    integer rand=$(( $RANDOM % $max ))
    printf '%d' $rand
    red $rand >&2
}
function airand() {
    integer max=$1
    integer count=$2
    typeset -ag rand=()
    integer i=1
    for i in {1..$count}; do
        blue $RANDOM
        rand+=$(irand $max)
    done
}

#function i2() {
#    name=$1
#    info=(${(@f)"$(whence -av $name)"})
#    for desc in $info; do
#        case $desc in
#            *'alias'*)
#                print -P "%F{14}${desc#*alias for }%f" ;;
#            *'autoload'*'function')
#                fn def $name ;; # print -P "Function %F{6}${name}%f"
#            *'function'*)
#                fn def $name ;; # print -P "Function %F{4}${name}%f"
#            *'not found'*)
#                print -P "%F{9}${name} not found%f" ;;
#            *'builtin'*)
#                print -P "%F{4}shell builtin%f" ;;
#            *'/'$name)
#                print -P "%F{2}${desc#*$name is }%f" ;;
#        esac
#    done
##    print -l $info
#}

function write-lines() {
    local line_count bytes_per_line
    line_count=${1:-1}
    text_length=${2}
    local line pad length
    for line in {1..$line_count}; do
        pad=$(( ${#line_count} + 1 ))
        length=${text_length:-$line}
        text=$(printf '%s' $(dd if=/dev/random bs=1 count=$length 2>/dev/null | xxd -p))
        print ":${(r:$pad:)line}   ${text:0:$length}   ${(l:$pad:)line}:"
    done
}
