# User-specific functions for interactive zsh(1) shells.


# Open default macOS Terminal
function term1() {
    open -a '/System/Applications/Utilities/Terminal.app' -g -n
}
# Open iTerm2
function term2() {
    open -a '/Applications/iTerm.app' -g -n
}

# Open in editor
function edit() {
    ${=EDITOR} "$@"
}
# Calculate
function calc() {
    noglob expr "$@"
}
alias calc='noglob calc'

#
function themes() {
    ${=EDITOR} $zterm/etc/themes.oh-my-zsh
}
#
function plugins() {
    ${=EDITOR} $zterm/etc/plugins.oh-my-zsh
}

# Highlight grep matches with backgroud color
function hgrep hegrep hfgrep() {
    (GREP_COLOR='01;30;42' ${0:1} --color='always' $argv)
}





#MARK: - File Directories
# Go to Z-Terminal directory.
function zterm()    { cd "$ZTERM/$@"; }
# Go to ZDOTDIR.
function zdot()     { cd "$ZDOTDIR/$@"; }
# Go to SFU directory.
function sfu()      { cd "$SFU/$@"; }
# Go to Desktop.
function desk()     { cd "$HOME/Desktop/$@"; }
# Go to Library.
function lib()      { cd "$HOME/Library/$@"; }
# Go to Development root.
function dev()      { cd "$DEV/$@"; }
# Go to Projects directory.
function proj()     { cd "$DEV/Projects/$@"; }
# Go to Developer Library.
function devlib()   { cd "$devlib/$@"; }
# Go to Temporary Files.
function tmp()      { cd "/tmp/$@"; }
#function temp()     { cd "$tempdir/$@"; }
# Go to my var directory.
function var()      { cd "$HOME/var/$@"; }
# Go to launchd services.
function services() { cd "$HOME/Library/LaunchAgents/$@"; }
# Go to logs.
function logs()     { cd "$ZTERM/var/log/$@"; }
# Go to Test Files.
#function testdir()  { cd "$testdir/$@"; }




#MARK: - Oh-my-zsh Plugins
# Open oh-my-zsh root directory.
function myzsh() {
    open "$ZSH"
}
# Open oh-my-zsh/plugins.
function myplugins() {
    open "$ZSH/plugins"
}
# List plugins.
function list-plugins() {
    ls "$ZSH/plugins"
}
# Display information about an oh-my-zsh plugin.
function info-plugin() {
    local plugin_name="$1"
    open -a Xcode -g "$ZSH/plugins/$plugin_name/README"*
}
# Print plugin's README to stdout.
function cat-plugin() {
    local plugin_name="$1"
    cat "$ZSH/plugins/$plugin_name/README"*
}
# View next plugin's.
function next-plugin() {
    # Array of all plugin
    local all_plugins=($( command ls -1 "$ZSH/plugins" ))
    read_array arr
    # Seen/unseen plugins
    local seen=( $arr )
    local notseen=( ${all_plugins:|seen} )
    # Exit if seen all
    if [[ ${#notseen} -eq 0 ]]; then
        echo "<<< $(b_greenbg 'ALL PLUGINS SEEN') >>>"
        return 1
    fi
    # Next plugin is the first unseen
    local next=${notseen[1]}
    arr+=( $next )
    save_array arr
    # Sizes
    local N=${#all_plugins}
    local n=$(( ${#seen} + 1 ))
    echo "Opening plugin $( b_magenta "#${n} - $next"  ) out of ${N} total."
    info-plugin $next
}


#MARK: - Oh-my-zsh Themes
# List themes.
function list-themes() {
    local themes=(${$( command ls "$ZSH/themes" )%.zsh-theme})
    echo $themes
}
# View next theme.
function next-theme() {
    # All themes
    local themes=($( list-themes ))
    # Tried themes
    touch "$DEV/Library/Data/tried_themes.array"
    typeset -a tried_themes
    read_array tried_themes
    # Not tried themes
    local not_tried_themes=( ${themes:|tried_themes} )
    if [[ ${#not_tried_themes} -eq 0 ]]; then
        echo "<<< $(b_greenbg 'ALL THEMES TRIED') >>>"
        return 1
    fi
    # Pick first theme which has not been tried yet
    local next=${not_tried_themes[1]}
    tried_themes+=( $next )
    save_array tried_themes
    export ZSH_THEME=$next
    re "Current theme: $next"
}




# function
# date
function date_list_formats() {
    typeset -ag formats
    formats=()
    man strftime |
        colcrt - |
        fgrep -- '%' |
        awk '{ print $1; }' |
        while read fmt; do
            if [[ $fmt[1] == '%' ]]; then
                formats+=($fmt);
            fi
        done
    builtin print -a -C8 -- ${formats}
}
function date_formats_preview() {
    for format in $( date_list_formats ); do
        local full_command="\$( $(green "date -j +\'$format\'") )"
        local preview="$(b_byellow \'$( date -j +$format )\')"
        builtin print -a -C2 -- "${format}\t ${full_command}\t" "${(Q)preview}"
    done
}


function magnetize() {
    open /Applications/Magnet.app -g
    local positions=('← Left ◧' '→ Right ◨' '↑ Up ⬒ ' '↓ Down ⬓')
    local group1=("⇧⌘"${^positions})
    printf "$(underline %s):\n" 'Magnet Commands'
    for cmd in $group1; do
        printf '%-*s' 35 "$(bold $cmd)"
    done
    echo
    
    #'Top Left ◰' 'Top Right ◳'
    #'Bottom Left ◱' 'Bottom Right ◲'
#    for cmd in $group2; do
#        printf '%-*s' 35 "$(bold $cmd)"
#    done
}


# Lists every executable in PATH.
function show-executables() {
    print -l ${^path}/*(-*N)
}






function printf_formats() {
    open 'https://www.linuxjournal.com/content/bashs-built-printf-function'
}
function zshrc_template() {
    open 'https://dev.to/manan30/what-is-the-best-zshrc-config-you-have-seen-14id'
}


function print-q() {
    builtin print -- "${(qqqq)argv}"
}


#
function lorem() {
    typeset -a lines=(
        'Lorem ipsum dolor sit amet, consectetur adipiscing elit.'
        'Suspendisse nec convallis neque, eget interdum diam.'
        'Donec sit amet arcu faucibus, lobortis lacus sed, molestie massa.'
        'Vestibulum eget cursus ligula.'
        'Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos.'
        'Integer sit amet diam rutrum, dictum eros at, dignissim orci.'
        'Nullam pulvinar pellentesque mollis.'
        'Etiam ultrices fermentum augue, vitae imperdiet mi.'
        'Nullam nec lectus nec sem eleifend pharetra.'
        'Cras congue orci vel aliquam fermentum.'
        'Ut quis metus quis mauris dapibus cursus ac vitae leo.'
    )
    set -A fmt ${fmt} ${argv}
    builtin print ${fmt} -- "${(@)lines}" >&1
}

# ls format
function datels() {
    date -j +'%d %b %R'
}
function statls() {
    local cmd=(stat -t '%d %b %R' -f '%-Sp %+2l %-Su %+Sg %-4z %.12Sm %-SN %n' "$@")
    if [[ $# -eq 0 ]]; then
        cmd=( echo $cmd )
    fi
    $cmd
}


# Dash
function docsets() {
    local dsets
    dsets=(${(@f)"$(find "$HOME/Library/ApplicationSupport/Dash" \
                         -name '*.docset')"})
    printf 'Found %d docsets:\n' ${#dsets}
    printf "  $(yellow '%s')\n" ${(o)dsets:t}
}










function test-cdp() {
    dir=$PWD
    cmd=$1
    
    ${=cmd} ~/Developer/Projects
    ${=cmd} ~/Documents
    ${=cmd} ~/var
    ${=cmd} ~/Public/Drop\ Box
    ${=cmd} ~/Library/DES
    
    print-line
    for i in {1..15}; do
        ${=cmd} +3
    done
    print-line
    
    cd $dir
}



function env0() {
    /usr/bin/env -i "${(@f)$(< $zterm/etc/zsh/env0)}" \
    /usr/local/bin/zsh -f "$@"
}
function env1() {
    /usr/bin/env -i "${(@f)$(< $zterm/etc/zsh/env1)}" \
    /usr/local/bin/zsh -f "$@"
}







function list-services() {
    /bin/launchctl list |
        /usr/bin/fgrep -e 'com.maximpuchkov'
}

function print-quotes() {
    typeset arg="$argv"
    printf "%-4s: ${lb}%s${rb}\n"  "q"    "${(q)arg}"
    printf "%-4s: ${lb}%s${rb}\n"  "qq"   "${(qq)arg}"
    printf "%-4s: ${lb}%s${rb}\n"  "qqq"  "${(qqq)arg}"
    printf "%-4s: ${lb}%s${rb}\n"  "qqqq" "${(qqqq)arg}"
}

function print-debug() {
    local c='%F{4}'
    local args="$argv"
    local value="${c}${args}%f"
    local length="${c}${#args}%f"
    local label='%B%UValue%u%b'
    builtin printf "%s(length: %s) = <%s>\n" \
                    "${(%)label}" "${(%)length}" "${(%)value}"
}


# Print
function print-br() {(
    # Number of line breaks to print
    typeset n=${1:-0}
    if [[ ! $n =~ '^[1-9][0-9]*$' ]]; then
        error -1 'invalid number of line breaks: $n.'
    fi
    # Default line break is '\n'
    typeset linebr="${2:-\n}"
    repeat $n { printf '%b' "$linebr" }
    return 0
)}

function print-ln() {(
    typeset -i width=${1:-$COLUMNS}
    typeset char=${2:-'*'}
    print -- ${(pr:$width::$char:)}
)}



#function untab() {
#    typeset find replace out
#    find='^[[:space:]]+'
#    replace=''
#    out=$(sed -n -E "s/${find}/${replace}/p" <<< "$argv")
#    print -- ${out:-$argv}
#}







#MARK: - TEMP
#export TEMP_THEME_N=${$(< ~/var/TEMP_THEME_N):-1}
#
#function theme_dislike() {
#    local f=$HOME/var/Themes/disliked.txt
#    echo $ZSH_THEME >> $f
#    logf "Disliked oh-my-zsh theme '\$ZSH_THEME'."
#    logf "Theme name is written to \$f."
#    theme_n; sleep 3; re;
#}
#function theme_like() {
#    local f=$HOME/var/Themes/liked.txt
#    local i=$(( ${=$(wc -l < $f)} + 1 ))
#    echo $ZSH_THEME >> $f
#
#    local outf=$HOME/var/Themes/"Like ${i} - $ZSH_THEME"
#    theme_example > $outf
#    logf "Liked oh-my-zsh theme '\$ZSH_THEME'."
#    logf "Theme name is written to '\$f'."
#    logf "Theme example is written to '\$outf'."
#    theme_n; sleep 3; re;
#}
##
#function theme_n() {
#    local -i next=$1
#    if [[ $next -eq 0 ]]; then
#        next=$(( $TEMP_THEME_N + 1 ))
#    fi
#    echo $next > ~/var/TEMP_THEME_N
#}
#function theme_example() (
#    cd $zterm
#    for p in PS{1..4}; do
#        print -P -x4 -- "\tPrompt '$p' = <${(P)p}>"
#    done
#    echo;echo;
#    ls -lFGHah
#)
#
#alias dislike='theme_dislike'
#alias like='theme_like'
#alias example='theme_example'
#alias next='theme_n'
#MARK:   TEMP -

function unwrap() {
    tput rmam
    print -P -- "%F{4}%S${(@)argv[1]}%s ${(@)argv:2}%f"
    ${=argv}
    tput smam
}


#function tap() {
#    pv@
#    while [[ $1 =~ '^[-+]' ]]; do
#        D "Shifting 1=$1"
#        shift
#    done
#    pv@
#    builtin set -- "${(@)argv}"
#    pv@
#}











#function cleanf() {
#    local bytes=256
#    local file=$1
#    local size=$(stat -f '%z' < $file)
#    print -a -C2 -Pl -- "%UFile:%u:" "$file" "%USize%u:" "$size bytes"
#
#    hexyl -n $bytes < $file
#
#    # ...
#}
#
#
#function f () {
#    integer a b c
#     #{1,2}
#    #=${1:3}
#    exec {a}>&0 {b}>&1 {c}>&2
##    exec
##    exec {
#    print 'This is a log message.' >&$a >&1
#    S a: $a,   b: $b,   c: $c
#    exec {a}>&- {b}>&- {c}>&-
#}



function dgst() {
    tput rmam
    local file d
    for file in $argv; do
        builtin print -P -- "%F{4}${(l:$COLUMNS::*:)}%f"
        local -a list=(md4 md5 md5-sha1 sha1 sha256 sha512 rmd160 blake2b512)
        for d in $list; do
            openssl dgst -$d $file
        done
    done
    builtin print -P -- "%F{4}${(l:$COLUMNS::*:)}%f"
    tput smam
    return 0
}

function randbytes() {
    local n_bytes=${1:-1}
    local output_file=${2:-/dev/stdout}
    builtin print "Writing ${n_bytes} random bytes to ${output_file}." >&2
    /bin/dd if=/dev/random of=$output_file bs=8 count=$n_bytes 2>/dev/null
}


function ow() {
    stat -f "%Sp -> owner=%SHp group=%SMp other=%SLp"
}
function recent_files() {
    stat -f "%m%t%Sm %N" ${argv:-$PWD}/* | sort -rn | head -3 | cut -f2-
}


function tprof() {
    local name=${1:-'Light'}
    printf '%b\n' "\e]1337;SetProfile=Term 3: $name\a"
}
function SetProfile() {
    local name=${1:-'Light'}
    printf '%b\n' "\e]1337;$0=Term 3: $name\a"
}
function GetProfile() {
    printf '%b\n' "\e]1337;$0\a"
}




function testpyg() {
    for style in xcode{dark,light}; do
        pygmentize -O style=$style $argv
        print-line
    done
}
function pyg-rtf() {
    local file=$1
    shift
    pygmentize -f 'rtf' ${=argv}
}








function le() {
    unfunction _$0
cat >"$zdot/completions/_$0" <<EOF
#compdef $0

# _$0
#
#
# zsh function completion
#

typeset -a args=()

args=(
    "-n[create an empty filename (the disk blocks aren't allocated until data is written to them)]"
    "-v[report the names and sizes of created files]"
    $(print -Pl -- ${(qq)argv};)
)

#_arguments -s -S \$args
_arguments -s \$args \
    '-E[specify EOF marker]:end-of-file marker' \
    '(-x -i)-I[specify replacement string for command line]:replacement string' \
    '(-n -l)-L[call program for every number of lines]:number of input lines' \
    '(-)1: :(b k m g)' \
    '*::args: _normal'


return 0
EOF
    OK ; pass
    
    compdef _$0 $0
    autoload -Uz _$0
    return 0
}


#MARK: - Manual Pages
function manp() {(
    local name="$argv"
    local dir="${zterm}/share/man"
    if [[ ! -d $dir ]]; then
        /bin/mkdir -p -- $dir
    fi
    local file="${dir}/${name}"
    /usr/bin/man  -t -- $name > $file
    /usr/bin/open -a Preview -- $file
)}
function xman() {(
    open -a Terminal -g x-man-page://"$argv"
)}




function test_print-var() {
    # Test 0
    (
        print-var
        Standout "Exit code: $?"
    )
    print-line
    
    # Test 0
    (
        print-var myVar
        Standout "Exit code: $?"
    )
    print-line
    
    # Test 1
    (
        typeset myVar
        myVar='One variable'
        
        print-var myVar
        Standout "Exit code: $?"
    )
    print-line
    
    # Test *
    (
        typeset myStr
        typeset -i10 myInt
        typeset -a myArr
        typeset -A myAssoc
        myStr='my string'
        myInt=1234567890
        myArr=('my' 'array' 'elements')
        myAssoc=( [name]='John' [surname]='Doe' [age]=50 )
        
        print-var my{Str,Int,Arr,Assoc}
        Standout "Exit code: $?"
    )
    print-line
    
    # Test * (null values)
    (
        typeset myStr
        typeset -i10 myInt
        typeset -a myEmptyArr
        typeset -a myArr
        typeset -A myAssoc
        myStr=""
        myInt=0
        myEmptyArr=()
        myArr=(1 '' 3 '' 5 "" 7 "" 9 "\"\"" "''" )
        myAssoc=( [key]='' ['']='value' )
        
        print-var my{Str,Int,EmptyArr,Arr,Assoc}
        Standout "Exit code: $?"
    )
    print-line
    
    # Test * (undefined variables)
    (
        typeset myVar
        myVar='my defined variable'
        
        print-var my{Str,Int,Arr,Var,Assoc}
        Standout "Exit code: $?"
    )
    print-line
}






#MARK: - Keep 
# Misc Functions
# Move a file to iCloud.
function icmv() {
    # Create 'MovedFiles' directory
    local directory=$iCloud/MovedFiles
    if [[ ! -e $directory ]]; then
        /usr/bin/mkdir -p -- $directory
    fi
    # Move files
    local filepath
    for filepath in $argv; do
        /bin/mv -- $filepath $directory
        local message="Moved %B%U${filepath:t}%u%b to %F{10}${directory}%f."
        builtin print -P -- "$message"
    done
    return 0
}

# Show synonyms and antonyms for a given word (online).
function thesaurus() {
    local base='https://www.thesaurus.com/browse'
    local word=${argv// /+}
    local url="${base}/${word}"
    /usr/bin/open -a 'Safari' -- $url
}





function word() {
    function word_thesaurus() {
        base='https://www.thesaurus.com/browse'
    }
    
    function word_sentences() {
        base='https://www.wordhippo.com/what-is/sentences-with-the-word/'
    }
    
    if [[ $# -eq 0 ]]; then
        fn print-commands $0
        return 2
    fi
    
    typeset cmd=$1
    shift
    if [[ ${+functions[${0}_${cmd}]} -eq 0 ]]; then
        error -127 'Command not found: $cmd.'
    fi
    
    typeset base url
    typeset word
    word=${argv// /+}
    if [[ -z $word ]]; then
        error -1 'Word not set.'
    fi
    ${0}_${cmd} $word
    
}


function rand() {
    function rand_str() {
        local n_bytes=${1:-1}
        local output_file=${2:-/dev/stdout}
        {
            builtin print -- \
                    "Writing ${n_bytes} random bytes" \
                    "to ${output_file}." \
                    >&2
            /bin/dd  if=/dev/random  \
                     of=$output_file \
                     bs=8            \
                     count=$n_bytes  \
                     2>/dev/null
        }
    }
    
    case $# in
        0)  fn print-commands $0
            return 22
        ;;
        1)  error -1 ' is not specified.'
            
        ;;
    esac
    
    if [[ $# -lt 2 ]]; then
        error -1 'Bad input.'
    fi
    typeset cmd=$1
    shift
    
    
    typeset value
    if [[ ${+functions[${0}_${cmd}]} -eq 0 ]]; then
        error -127 'Command not found: $cmd.'
    fi
    ${0}_${cmd} "$@"
    return $?
}


# Create a .webloc shortcut file
function webloc() {
    if [[ -z $1 ]]; then
        error -1 'URL is not set.'
    fi
    local url=${${1#*://}//\//:}
    local filename=${2:-$url}
    if [[ -d $filename ]]; then
        filename="${filename%/}/${url}"
    fi
    
#    filename="${filename//\//:}"
    
    # ${2:-$url}
    pv url filename
#    https://coursys.sfu.ca/history
}



# Initialize an array of letters A-Z and a-z.
#
#   1) ABC
#       echo $ABC[A]    # Letter 'A' is 'Alpha'
#       echo $ABC[a]    # alpha
#       echo $#ABC      # 52
#   2) assign='X y z' ABC
#       echo $X         # Letter 'X' is 'X-ray'
#       echo $y         # yankee
#       echo $z         # zulu
function ABC() {
    # Read phonetic spellings (words) from file
    typeset alphabet=${1:-"$zterm/share/misc/phonetic-alphabet.txt"}
    typeset abc_file=~/var/commands/abc.spellings
    # Set result to associative array (default name: ABC)
    typeset id=${2:-$0}
    typeset -Ag $id
    set -A $id
    # Set short and long
    local word
    local -l lowercase
    local -u uppercase
    # Set variables
    () {
        while read -t word; do
            lowercase="${word[1]}"
            uppercase="${word[1]}"
            ABC[$lowercase]="${(L)word}"
            ABC[$uppercase]="Letter '${uppercase}' is '${word}'"
        done <&0
    } <$alphabet
    # Save ABC to a file
    () {
        print -l -- ${(kv)ABC} >&1
    } >$abc_file
    # Quickly assign variables. E.g., if assign is 'a b',
    # then a is set to ABC[a] and b is set to ABC[b]
    export assign
    () {
        for var in $argv; do
            typeset -ag $var
            set -A $var ${(kv)ABC[$var]}
        done
        print -P -- "Assigned %F{2}${#argv}%f variables"
    } $=assign
    return 0
}



function setget() {
    unset optlist
    typeset -A optlist
    
    typeset -ag opt_strings val_strings
    opt_strings=(
        '-f a -o x'
        '-f a b'
        '-o x y'
        '-f a b c -o x y z'
        '-f a'
        '-o x'
        '-o z:12345'
    )
    val_strings=(
        '-a -x 100'
        '-a -b'
        '-x valX -y valY'
        '-a -b -c -x x1 -y y2 -z z3'
        '-a'
        '-x valX'
        '-notz abcde'
    )
    
    
    
    local set_array_opt='-A optlist'
    opt_flags=(${set_array_opt:^opt_strings})
    
    local rest='and1 other2 args3'
    set +A val_strings ${^val_strings}' REST '${rest}
    
    for str val in ${opt_strings:^val_strings}; do
        print -- "get-arguments "$(red $str)" -- "$(green $val)"\n\n"
        typeset -A optlist
        optlist=()
        set -- ${=val}
        get-arguments -A optlist ${=str} -- $argv
        
        printf "<<-$(magenta '%s')-  |  -$(blue '%s')->>\n" "$val" "get-arguments -A optlist ${str} -- $argv"
        print-var optlist @
        tput setab 2; print-line tput sgr0;
    done
}



function get-arguments-t() {
    # Names of set flags/options
    local -a set_{flags,opts}
    set_flags=(${(s: :)1})
    set_opts=(${(s: :)2})
    # Names of wanted flags/options
    local -a get_{flags,opts}
    get_flags=(${(s: :)3})
    get_opts=(${(s: :)4})
    # Non-flag/option arguments
    local -a other_args
    set -A other_args 'Hello World'{1..5}
    
    
    # Output option list
    typeset -Ag optlist
    optlist=()
    
    # Set positional arguments
    set -- '-'${^set_flags} \
           '-'${^set_opts}{,' opt-value'} \
              ${^other_args}
    
    # Set and parse arguments
    print -P -- "%F{1}BEFORE:\t{$argv} [$#]%f"
    
    get-arguments -A optlist    \
                  -f $get_flags \
                  -o $get_opts  \
                  -- $argv
    print -Pl -- "%Uget-arguments%u" \
                 "-A optlist" \
                 "-f $get_flags" \
                 "-o $get_opts" \
                 "-- $argv"
    
    print -P  -- "%F{2}AFTER:\t{$argv} [$#]%f"
    echo; echo;
    
    
    # Print results
    print-line
    print -P -- "Test: $0."
    print -P -- "Set flags: {%F{2}${set_flags}%f}, options: {%F{2}${set_opts}%f}."
    print -P -- "Get flags: {%F{4}${get_flags}%f}, options: {%F{4}${get_opts}%f}."
    print -P -- "Optlist[${#optlist}]: {%F{3}${optlist}%f}."
    print-var optlist defaults @
    print-line
    echo
}




function cat() {(
    if [[ -v cc ]]; then
        print -P -- "%S%K{${cc}}${0}%f%s"
        esc $cc
    fi
    $(which -p $0) $argv
    typeset -i code=$?
    esc 0
    return $code
)}



#
#
#    typeset input=${argv:-/dev/stdin}
#    if [[ -n $c ]]; then
#        (
#            local program="%B${0}%b"
#            print -P -- "%B>  Setting %F{${c}}color%f of %U${0}%u%b"
#
##            printf '>  ' &&
##            /usr/bin/tput smul &&
##            printf '%s color is set to %d\n' "${(%)program}" $c &&
##            /usr/bin/tput rmul
#        )
#        /usr/bin/tput setaf $c
#    fi
#    cat <<EOF
#
#EOF
#    /bin/cat <$input
#    /usr/bin/tput sgr0
#)}




#
#
#function iff() {
#    function iff_result() {
#        eval "[[ $argv ]]"
#        print $?
#    }
#    
#    local cond res
#    for cond in $argv; do
#        let res=$(iff_result $cond)
#        printf 'if [[ %s ]]:  %s\n' "${cond}" "${res}"
#    done
#    return 0
#    
#    
#    typeset condition
#    for condition in $argv; do
#        eval "[[ ${condition} ]]; result=\$?"
#        
##        let bool=$(iff_result $1)
#        print $bool
#        printf 'if [[ %s ]]:  %s' "${condition}" $bool
#        shift
#    done
##    [[ $argv ]]
#}


    # Format files
#    typeset -A iofmt_files
#    iofmt_files=( [labels]="$zterm/etc/iofmt/labels" )
#    /usr/bin/touch -- ${(k)iofmt_files}
    
    #

#typeset -A arrxyz
#arrxyz=( [x1]=100 [y1]=500 )



# All 'print -P' prompts
function all-prompts() {
    typeset -A result
    result=()
    typeset -a list
    list=($(< $zterm/etc/prompt-sequences.txt))
    typeset file="$zterm/etc/prompt-sequences.txt"
    typeset reset='\e[0m'
    () {
        while [[ -n $1 ]]; do
            cmd=(print -P "'%${1}' ")
            value=$($cmd)
            result+=("$cmd" "${(Q)value}${reset}")
            shift
        done
    } $(<$file)
    print -aC2 -- ${(kv)result}
    return 0
}





function findf() {
    typeset name=$1
    typeset -a dirs=($PWD)
    () (
        for d in $dirs; do
            ( /usr/bin/cd -- $d &&
              /usr/bin/find . -name $name )
        done
    ) 2>/dev/null
}
function mapf() {
    zmodload zsh/mapfile
    typeset -ag map
    typeset file=$1
    map=(${(@f)${mapfile[$file]%$'\n'}})
    pv map file @
    
    m1=(${(@f)${mapfile[$file]%\n}})
    m2=(${${mapfile[$file]%$'\n'}})
    m3=(${(@f)"${mapfile[$file]%$'\n'}"})
    pv m1 m2 m3
}


function dir() {
    typeset dirpath=${1:-$PWD}
    find $dirpath/* -prune
    
}

# Initialize an array or associative Array
function Array array() {
    # Get array name
    typeset reply=$1
    [[ -z $reply ]] && usage 'Bad input' '$0 name [value, ...]'
    shift
    #
    [[ -v $reply ]] && unset $reply
    typeset type="-${0[1]}g"
    
    # Set array values
    typeset $type -g $reply
    case $1 in
        ## [Aa]rray -c: set array elements to output of command ##
        -c) shift
            set -A $reply ${(@f)"$(${=argv})"}
        ;;
        ## [Aa]rray: set array elements to arguments ##
        *)  set -A $reply $argv
        ;;
    esac
        
    # Print array
    [[ -t 1 ]] && print-var $reply
}


function print-input() {
    print -P -- "%F{5}>%f %BInput of %F{5}%U${0}%u%f:%b"
    print-var -1 argv
}





function jb() {
    typeset -i ifd
    exec {ifd}
    while read arg; do
        notify -- $arg
    done
}

#function print-input() {
#    typeset name=$1
#    shift
#    typeset count=${#}
#    typeset values=${(j:, :)argv}
#
#    if [[ -t 1 ]]; then
#        name="%F{4}%U${name}%u%f"
#        count="%F{4}${count}%f"
#        values=
#    fi
#
#    print -P -- "${name}: argv[${count}] = {${values}}"
#
##    print -P -- "${0}: argv[${#}]="
##    trap 'print -P -- "${0}: in (%x %N)"' EXIT
#}

function inp() {
    print-input $0 $argv
}


function funcstat() {
    bred 'Function Trace'
    print -l -x2 -- '\t'${^functrace}
    echo
    
    bred 'Function Stack'
    print -l -x2 -- '\t'${^funcstack}
}



        # sed -E -e 's/'$1'/'$2'/g'

function find_replace() {
    file=$1
    shift
    () (
        file=$1
        shift
        while [[ -n $2 ]]; do
            perl -pe "s/${(q)1}/'${(q)2}/g" -i $file
            shift 2
        done
        cat <$file
    ) =(<&0) $argv
    return 0
}

function hsym() {
    typeset -A map
    map=( ['{']=$(red '{')     ['}']=$(red '}')
          ['[']=$(blue '[')   [']']=$(blue ']')
          ['(']=$(green '(')  [')']=$(green ')') )
    find_replace ${(kv)map} <$1
}

function notify() {
    typeset program=${${functrace[1]%:*}:-$0}
    if [[ -t 1 ]]; then
        program="%F{4}${program}%f"
    fi
    
    # Print
    builtin print -Pn -X2 -- "${program}:\t"
    builtin print ${argv}
    return 0
}




typeset -a iff_exprs=(
    '-n A'
    '[ -n B ]'
    '[[ -n C ]]'
    '[[ -n D1 ]] && [[ -n D2 ]]'
    '-n E1 && -n E2 || -n E3'
    "$texpr"
    "$fexpr"
)



