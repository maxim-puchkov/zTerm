# User-specific functions for interactive zsh(1) shells.


# Open default macOS Terminal.
function term1() {
    open -g '/System/Applications/Utilities/Terminal.app'
}
# Open iTerm2.
function term2() {
    open -g '/Applications/iTerm.app'
}

# Open in editor.
function edit() {
    ${=EDITOR} "$@"
}
# Calculate
function calc() {
    noglob expr "$@"
}

#
function themes() {
    ${=EDITOR} $ZSH_THEMES
}
#
function plugins() {
    ${=EDITOR} $ZSH_PLUGINS
}




#MARK: - Oh-my-zsh Plugins
# Open oh-my-zsh root directory.
function myzsh() {
    open "$ZSH"
}
# Open oh-my-zsh/plugins.
function myplugins() {
    open "$ZSH/plugins"
}
# List plugins.
function list-plugins() {
    ls "$ZSH/plugins"
}
# Display information about an oh-my-zsh plugin.
function info-plugin() {
    local plugin_name="$1"
    open -a Xcode -g "$ZSH/plugins/$plugin_name/README"*
}
# Print plugin's README to stdout.
function cat-plugin() {
    local plugin_name="$1"
    cat "$ZSH/plugins/$plugin_name/README"*
}
# View next plugin's.
function next-plugin() {
    # Array of all plugin
    local all_plugins=($( command ls -1 "$ZSH/plugins" ))
    read_array arr
    # Seen/unseen plugins
    local seen=( $arr )
    local notseen=( ${all_plugins:|seen} )
    # Exit if seen all
    if [[ ${#notseen} -eq 0 ]]; then
        echo "<<< $(b_greenbg 'ALL PLUGINS SEEN') >>>"
        return 1
    fi
    # Next plugin is the first unseen
    local next=${notseen[1]}
    arr+=( $next )
    save_array arr
    # Sizes
    local N=${#all_plugins}
    local n=$(( ${#seen} + 1 ))
    echo "Opening plugin $( b_magenta "#${n} - $next"  ) out of ${N} total."
    info-plugin $next
}


#MARK: - Oh-my-zsh Themes
# List themes.
function list-themes() {
    local themes=(${$( command ls "$ZSH/themes" )%.zsh-theme})
    echo $themes
}
# View next theme.
function next-theme() {
    # All themes
    local themes=($( list-themes ))
    # Tried themes
    touch "$DEV/Library/Data/tried_themes.array"
    typeset -a tried_themes
    read_array tried_themes
    # Not tried themes
    local not_tried_themes=( ${themes:|tried_themes} )
    if [[ ${#not_tried_themes} -eq 0 ]]; then
        echo "<<< $(b_greenbg 'ALL THEMES TRIED') >>>"
        return 1
    fi
    # Pick first theme which has not been tried yet
    local next=${not_tried_themes[1]}
    tried_themes+=( $next )
    save_array tried_themes
    export ZSH_THEME=$next
    re "Current theme: $next"
}




function pygments-styles() {
    local list=($( pygmentize -L 'styles' ))
    printf '%s' "$list" | grep -E '\* [[:alnum:]-]*' -o | sed -E 's/\* //g'
}


# Pass/Fail symbols.
function pass() {
    printf '%s\n' "$(b_green '✔︎')"
    return 0
}
function fail() {
    printf '%s\n' "$(b_bred '✘')"
    return 1
}


# Hex print.
function hexpr() {
    printf '%s' $(xxd -p "${@:?}")
}
function hexprl() {
    echo ${#$(hexpr "$@")}
}
function hexprline() {
    echo $(hexpr "$@")
}


# Uppercase.
function uc() {
    printf '%s' "${(U)@}"
}
# Remove whitespaces.
function nosp() {
    printf '%s' "${@// /}"
}

# function
# date
function date_list_formats() {
    typeset -ag formats
    formats=()
    man strftime |
        colcrt - |
        fgrep -- '%' |
        awk '{ print $1 }' |
        while read fmt; do
            if [[ $fmt[1] == '%' ]]; then
                formats+=($fmt);
            fi
        done
    print -a -C 8 ${formats}
}
function date_formats_preview() {
    for format in $( date_list_formats ); do
        local full_command="\$( $(green "date -j +\'$format\'") )"
        local preview="$(b_byellow \'$( date -j +$format )\')"
        print -a -C2 "${format}\t ${full_command}\t" "${(Q)preview}"
    done
}


function magnetize() {
    open /Applications/Magnet.app -g
    local positions=('← Left ◧' '→ Right ◨' '↑ Up ⬒ ' '↓ Down ⬓')
    local group1=("⇧⌘"${^positions})
    printf "$(underline %s):\n" 'Magnet Commands'
    for cmd in $group1; do
        printf '%-*s' 35 "$(bold $cmd)"
    done
    echo
    
    #'Top Left ◰' 'Top Right ◳'
    #'Bottom Left ◱' 'Bottom Right ◲'
#    for cmd in $group2; do
#        printf '%-*s' 35 "$(bold $cmd)"
#    done
}


function letters~old() {
    
    if [[ $# -gt 2 ]]; then
        local ordered=( ${(o)@} )
        printf "Ordered: $(bgreen '%s').\n" "$ordered"
        printf "First:   $(bold '%s');   last: $(bold '%s').\n" "${ordered[1]}" "${ordered[-1]}"
        return 0
    fi
    
    typeset -ag A
    typeset -ag N
    
    A=({A..Z})
    N=({1..26})
    local letter=${1[1]:-L}
    local compareTo=${2[1]}
    
    
    local index=${A[(wi)$letter]}
    if [[ $index -gt ${#A} ]]; then
        return 1
    fi
    A[$index]=$(b_bred $A[$index])
    N[$index]=$(b_bred $N[$index])
    
    
    local index2=${A[(wi)$compareTo]}
    A[$index2]=$(blue $A[$index2])
    N[$index2]=$(blue $N[$index2])
    
    { printf '  %s' $A; echo; printf '%s ' $N; echo } |
        column -t
}


# Lists every executable in PATH.
function show-executables() {
    print -l ${^path}/*(-*N)
}



function new-file() {
    #if
    local dir
    for dir in "$@"; do
        if [[ ! -d $d ]]; then continue; fi
        echo "$dir" > $dir/new-file
    done
}


function printf_formats() {
    open 'https://www.linuxjournal.com/content/bashs-built-printf-function'
}
function zshrc_template() {
    open 'https://dev.to/manan30/what-is-the-best-zshrc-config-you-have-seen-14id'
}

# 
function lorem() {
    printf "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse nec convallis neque, eget interdum diam. Donec sit amet arcu faucibus, lobortis lacus sed, molestie massa. Vestibulum eget cursus ligula. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Integer sit amet diam rutrum, dictum eros at, dignissim orci. Nullam pulvinar pellentesque mollis. Etiam ultrices fermentum augue, vitae imperdiet mi. Nullam nec lectus nec sem eleifend pharetra. Cras congue orci vel aliquam fermentum. Ut quis metus quis mauris dapibus cursus ac vitae leo.\n"
}

# ls format
function datels() {
    date -j +'%d %b %R'
}
function statls() {
    local cmd=(stat -t '%d %b %R' -f '%-Sp %+2l %-Su %+Sg %-4z %.12Sm %-SN %n' "$@")
    if [[ $# -eq 0 ]]; then
        cmd=( echo $cmd )
    fi
    $cmd
}


# Dash
function docsets() {
    local dsets
    dsets=(${(@f)"$(find "$HOME/Library/ApplicationSupport/Dash" \
                         -name '*.docset')"})
    printf 'Found %d docsets:\n' ${#dsets}
    printf "  $(yellow '%s')\n" ${(o)dsets:t}
}

function h~old() {
    local n=100; n=${@:+$HISTCMD}
    history -${n} | fgrep "${@:-''}"
}




function write-lines() {
    local line_count text_length
    line_count=${1:-1}
    text_length=${2}
    local line pad length
    for line in {1..$line_count}; do
        pad=$(( ${#line_count} + 1 ))
        length=${text_length:-$line}
        text=$( printf '%s' $(dd if=/dev/random bs=1 count=$length 2>/dev/null |
            xxd -p) )
        print ":${(r:$pad:)line}   ${text:0:$length}   ${(l:$pad:)line}:"
    done
}

function ndo() {
    local n cmd i
    n=${1:-1}
    shift
    cmd=$@
    for i in {1..$n}; do
        ${=cmd}
    done
}

function icmv() {
    local filepath=$1
    local directory=$ICLOUD/MovedFiles
    mkdir -p $directory
#    mvp $filepath $directory
    mv $filepath $directory
    print -P "Moved %B%U${filepath:t}%u%b to %F{10}${directory}%f."
}


function compress3 {
    local file=$1
    local filename=${file:r}
    local fileext=${file:e}
    
    if [[ -z $file ]]; then
        error 'No file to compress'
        return 2
    fi
    if [[ $file != $filename ]]; then
        mv -- $file $filename
    fi
    
    local tools=(
        "zip -1 ${filename:r}.zip1 $filename"
        "zip -9 ${filename:r}.zip9 $filename"
        "gzip -1 -k ${filename:t}"
        
    )
    for t in $tools; do
        echo $t
    done
    
    if [[ $file != $filename ]]; then
        mv -- $filename $file
    fi
}

function filename() {
    name="${1:-New File}"
#    files
}

function txt() {
    name=${1:t}
    files list .
    if [[ -n ${(M)files:#*/$name.*} ]]; then
        echo "there are ${(M)#files:#*/$name-?*.*} files named '$name'"
    fi
}


function debug() {
    # Check argument count
    if [[ $# -eq 0 ]]; then
        error 'Function name not specified.'
        return 2
    fi
    
    # Function name and arguments
    typeset fname=$1
    shift
    typeset -a fargs
    fargs=($@)
    
    # Function source file
    typeset fsrc=$(fn src $fname)
    if [[ -z $fsrc ]]; then
        error "Function not found: %F{1}$fname%f."
        return 1
    fi
    $fname $fargs
}

function envt_test() {
    typeset -a envt_arr
    envt_arr=(arr1 arr2 arr3)
    
    typeset -i10 envt_int
    envt_int=12345
}
function envt() {
    envt_test
}

function env-change() {
    typeset cmd
    cmd=($@)
    
    vars_begin
    fns_begin=$(typeset -f)
    
    
    typeset env_begin env_end
    env_begin=$(env)
    empty-env
    $cmd
    
}
