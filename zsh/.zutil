# User-specific functions for interactive zsh(1) shells.


# stat -f 'Permissions for %N: %SMp%SLp' 

# Open default macOS Terminal
function term1() {
    open -a '/System/Applications/Utilities/Terminal.app' -g -n
}
# Open iTerm2
function term2() {
    open -a '/Applications/iTerm.app' -g -n
}

# Open in editor
function edit() {
    ${=EDITOR} "$@"
}
# Calculate
function calc() {
    noglob expr "$@"
}

#
function themes() {
    ${=EDITOR} $zdot/etc/themes.oh-my-zsh
}
#
function plugins() {
    ${=EDITOR} $zdot/etc/plugins.oh-my-zsh
}




#MARK: - Oh-my-zsh Plugins
# Open oh-my-zsh root directory.
function myzsh() {
    open "$ZSH"
}
# Open oh-my-zsh/plugins.
function myplugins() {
    open "$ZSH/plugins"
}
# List plugins.
function list-plugins() {
    ls "$ZSH/plugins"
}
# Display information about an oh-my-zsh plugin.
function info-plugin() {
    local plugin_name="$1"
    open -a Xcode -g "$ZSH/plugins/$plugin_name/README"*
}
# Print plugin's README to stdout.
function cat-plugin() {
    local plugin_name="$1"
    cat "$ZSH/plugins/$plugin_name/README"*
}
# View next plugin's.
function next-plugin() {
    # Array of all plugin
    local all_plugins=($( command ls -1 "$ZSH/plugins" ))
    read_array arr
    # Seen/unseen plugins
    local seen=( $arr )
    local notseen=( ${all_plugins:|seen} )
    # Exit if seen all
    if [[ ${#notseen} -eq 0 ]]; then
        echo "<<< $(b_greenbg 'ALL PLUGINS SEEN') >>>"
        return 1
    fi
    # Next plugin is the first unseen
    local next=${notseen[1]}
    arr+=( $next )
    save_array arr
    # Sizes
    local N=${#all_plugins}
    local n=$(( ${#seen} + 1 ))
    echo "Opening plugin $( b_magenta "#${n} - $next"  ) out of ${N} total."
    info-plugin $next
}


#MARK: - Oh-my-zsh Themes
# List themes.
function list-themes() {
    local themes=(${$( command ls "$ZSH/themes" )%.zsh-theme})
    echo $themes
}
# View next theme.
function next-theme() {
    # All themes
    local themes=($( list-themes ))
    # Tried themes
    touch "$DEV/Library/Data/tried_themes.array"
    typeset -a tried_themes
    read_array tried_themes
    # Not tried themes
    local not_tried_themes=( ${themes:|tried_themes} )
    if [[ ${#not_tried_themes} -eq 0 ]]; then
        echo "<<< $(b_greenbg 'ALL THEMES TRIED') >>>"
        return 1
    fi
    # Pick first theme which has not been tried yet
    local next=${not_tried_themes[1]}
    tried_themes+=( $next )
    save_array tried_themes
    export ZSH_THEME=$next
    re "Current theme: $next"
}




function pygments-styles() {
    local list=($( pygmentize -L 'styles' ))
    printf '%s' "$list" | grep -E '\* [[:alnum:]-]*' -o | sed -E 's/\* //g'
}


# Pass/Fail symbols.
function pass() {
    printf '%s\n' "$(b_green '✔︎')"
    return 0
}
function fail() {
    printf '%s\n' "$(b_bred '✘')"
    return 1
}


# Hex print.
function hexpr() {
    printf '%s' $(xxd -p "${@:?}")
}
function hexprl() {
    echo ${#$(hexpr "$@")}
}
function hexprline() {
    echo $(hexpr "$@")
}


# Uppercase.
function uc() {
    printf '%s' "${(U)@}"
}
# Remove whitespaces.
function nosp() {
    printf '%s' "${@// /}"
}

# function
# date
function date_list_formats() {
    typeset -ag formats
    formats=()
    man strftime |
        colcrt - |
        fgrep -- '%' |
        awk '{ print $1; }' |
        while read fmt; do
            if [[ $fmt[1] == '%' ]]; then
                formats+=($fmt);
            fi
        done
    builtin print -a -C8 -- ${formats}
}
function date_formats_preview() {
    for format in $( date_list_formats ); do
        local full_command="\$( $(green "date -j +\'$format\'") )"
        local preview="$(b_byellow \'$( date -j +$format )\')"
        builtin print -a -C2 -- "${format}\t ${full_command}\t" "${(Q)preview}"
    done
}


function magnetize() {
    open /Applications/Magnet.app -g
    local positions=('← Left ◧' '→ Right ◨' '↑ Up ⬒ ' '↓ Down ⬓')
    local group1=("⇧⌘"${^positions})
    printf "$(underline %s):\n" 'Magnet Commands'
    for cmd in $group1; do
        printf '%-*s' 35 "$(bold $cmd)"
    done
    echo
    
    #'Top Left ◰' 'Top Right ◳'
    #'Bottom Left ◱' 'Bottom Right ◲'
#    for cmd in $group2; do
#        printf '%-*s' 35 "$(bold $cmd)"
#    done
}


function letters~old() {
    
    if [[ $# -gt 2 ]]; then
        local ordered=( ${(o)@} )
        printf "Ordered: $(bgreen '%s').\n" "$ordered"
        printf "First:   $(bold '%s');   last: $(bold '%s').\n" "${ordered[1]}" "${ordered[-1]}"
        return 0
    fi
    
    typeset -ag A
    typeset -ag N
    
    A=({A..Z})
    N=({1..26})
    local letter=${1[1]:-L}
    local compareTo=${2[1]}
    
    
    local index=${A[(wi)$letter]}
    if [[ $index -gt ${#A} ]]; then
        return 1
    fi
    A[$index]=$(b_bred $A[$index])
    N[$index]=$(b_bred $N[$index])
    
    
    local index2=${A[(wi)$compareTo]}
    A[$index2]=$(blue $A[$index2])
    N[$index2]=$(blue $N[$index2])
    
    { printf '  %s' $A; echo; printf '%s ' $N; echo } |
        column -t
}


# Lists every executable in PATH.
function show-executables() {
    print -l ${^path}/*(-*N)
}



function new-file() {
    #if
    local dir
    for dir in "$@"; do
        if [[ ! -d $d ]]; then continue; fi
        echo "$dir" > $dir/new-file
    done
}


function printf_formats() {
    open 'https://www.linuxjournal.com/content/bashs-built-printf-function'
}
function zshrc_template() {
    open 'https://dev.to/manan30/what-is-the-best-zshrc-config-you-have-seen-14id'
}

# 
function lorem() {
    printf "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse nec convallis neque, eget interdum diam. Donec sit amet arcu faucibus, lobortis lacus sed, molestie massa. Vestibulum eget cursus ligula. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Integer sit amet diam rutrum, dictum eros at, dignissim orci. Nullam pulvinar pellentesque mollis. Etiam ultrices fermentum augue, vitae imperdiet mi. Nullam nec lectus nec sem eleifend pharetra. Cras congue orci vel aliquam fermentum. Ut quis metus quis mauris dapibus cursus ac vitae leo.\n"
}

# ls format
function datels() {
    date -j +'%d %b %R'
}
function statls() {
    local cmd=(stat -t '%d %b %R' -f '%-Sp %+2l %-Su %+Sg %-4z %.12Sm %-SN %n' "$@")
    if [[ $# -eq 0 ]]; then
        cmd=( echo $cmd )
    fi
    $cmd
}


# Dash
function docsets() {
    local dsets
    dsets=(${(@f)"$(find "$HOME/Library/ApplicationSupport/Dash" \
                         -name '*.docset')"})
    printf 'Found %d docsets:\n' ${#dsets}
    printf "  $(yellow '%s')\n" ${(o)dsets:t}
}

function h~old() {
    local n=100; n=${@:+$HISTCMD}
    history -${n} | fgrep "${@:-''}"
}




function write-lines() {
    local line_count text_length
    line_count=${1:-1}
    text_length=${2}
    local line pad length
    for line in {1..$line_count}; do
        pad=$(( ${#line_count} + 1 ))
        length=${text_length:-$line}
        text=$( printf '%s' $(dd if=/dev/random bs=1 count=$length 2>/dev/null |
            xxd -p) )
        print ":${(r:$pad:)line}   ${text:0:$length}   ${(l:$pad:)line}:"
    done
}

function ndo() {
    local n cmd i
    n=${1:-1}
    shift
    cmd=$@
    for i in {1..$n}; do
        ${=cmd}
    done
}

function icmv() {
    local filepath=$1
    local directory=$ICLOUD/MovedFiles
    mkdir -p $directory
#    mvp $filepath $directory
    mv $filepath $directory
    print -P "Moved %B%U${filepath:t}%u%b to %F{10}${directory}%f."
}


function compress3 {
    local file=$1
    local filename=${file:r}
    local fileext=${file:e}
    
    if [[ -z $file ]]; then
        error 'No file to compress'
        return 2
    fi
    if [[ $file != $filename ]]; then
        mv -- $file $filename
    fi
    
    local tools=(
        "zip -1 ${filename:r}.zip1 $filename"
        "zip -9 ${filename:r}.zip9 $filename"
        "gzip -1 -k ${filename:t}"
        
    )
    for t in $tools; do
        echo $t
    done
    
    if [[ $file != $filename ]]; then
        mv -- $filename $file
    fi
}

function filename() {
    name="${1:-New File}"
#    files
}

function txt() {
    name=${1:t}
    files list .
    if [[ -n ${(M)files:#*/$name.*} ]]; then
        echo "there are ${(M)#files:#*/$name-?*.*} files named '$name'"
    fi
}











function te() {
    a='11 22'
    b=(a b)
    c='z z z'
    echo $a $b "$c" | highlight
    highlight $a $b "$c" 
}

function test-cdp() {
    dir=$PWD
    cmd=$1
    
    ${=cmd} ~/Developer/Projects
    ${=cmd} ~/Documents
    ${=cmd} ~/var
    ${=cmd} ~/Public/Drop\ Box
    ${=cmd} ~/Library/DES
    
    print-line
    for i in {1..15}; do
        ${=cmd} +3
    done
    print-line
    
    \cd $dir
}


# Associative arrays
function k() {
    print -P -- "%U$argv keys%u:   %B%F{4}${(Pkj:%f%b, %B%F\{4\}:)argv}%f%b"
}
function v() {
    print -P -- "%U$argv values%u: %B%F{6}${(Pvj:%f%b, %B%F\{6\}:)argv}%f%b";
}
function kv() {
    print -C2 -P -- "${(Pkv)argv}"
}

function env0() {
    /usr/bin/env -i "${(@f)$(< ~/etc/env0)}" \
    /usr/local/bin/zsh -f "$@"
}
function env1() {
    /usr/bin/env -i "${(@f)$(< ~/etc/env1)}" \
    /usr/local/bin/zsh -f "$@"
}




function fdw() {
#    typeset filepath=/tmp/$0.txt
    typeset file="$0_$$_$(date -j +'%H:%M').txt"
    exec 3<>/tmp/$file
    
    print -- "$0" >&3
    print -P -- "Arguments[$#]: {$argv}" >&3
    print -P -- "fds 0..10:" >&3
    fds {0..10} >&3
    
    exec 3>&-
    return $?
}


fdc_foo() {
    count=$1
    repeat $count; do
        local delay=$(( $RANDOM % 10 ))
        if [[ $delay -gt 2 ]]; then
            print -P "Error: sleep delay is too long: i=%F{3}${delay}%f" >&2
        else
            print -P "OK: sleeping for i=%F{3}${delay}%f seconds..." >&1
            sleep ${delay:-0}
        fi
    done
}

function fdc() {
    exec 3<&0
    exec 4>&1
    exec 5>&2
    count=${1:-1}
    result=$( { time (fdc_foo $count 1>&4 2>&5); } 2>&1 )
    
    read -t -u0 args0;
    red "FD0: $args0"
    echo
    read -t -u3 args3;
    blue "FD3: $args3"
    echo
    
#    cat <&3
#    cat <&4
#    cat <&5
    
    exec 3>&- 4>&- 5>&-
    redbg "Result = $result"
}



function list-services() {
    /bin/launchctl list |
        /usr/bin/fgrep -e 'com.maximpuchkov'
}

function print-quotes() {
    typeset arg="$argv"
    printf "%-4s: ${lb}%s${rb}\n"  "q"    "${(q)arg}"
    printf "%-4s: ${lb}%s${rb}\n"  "qq"   "${(qq)arg}"
    printf "%-4s: ${lb}%s${rb}\n"  "qqq"  "${(qqq)arg}"
    printf "%-4s: ${lb}%s${rb}\n"  "qqqq" "${(qqqq)arg}"
}

function print-debug() {
    local c='%F{4}'
    local args="$argv"
    local value="${c}${args}%f"
    local length="${c}${#args}%f"
    local label='%B%UValue%u%b'
    builtin printf "%s(length: %s) = <%s>\n" \
                    "${(%)label}" "${(%)length}" "${(%)value}"
}




#function untab() {
#    typeset find replace out
#    find='^[[:space:]]+'
#    replace=''
#    out=$(sed -n -E "s/${find}/${replace}/p" <<< "$argv")
#    print -- ${out:-$argv}
#}







#MARK: - TEMP
export TEMP_THEME_N=${$(< ~/var/TEMP_THEME_N):-1}

function theme_dislike() {
    local f=$HOME/var/Themes/disliked.txt
    echo $ZSH_THEME >> $f
    logf "Disliked oh-my-zsh theme '\$ZSH_THEME'."
    logf "Theme name is written to \$f."
    theme_n; sleep 3; re;
}
function theme_like() {
    local f=$HOME/var/Themes/liked.txt
    local i=$(( ${=$(wc -l < $f)} + 1 ))
    echo $ZSH_THEME >> $f
    
    local outf=$HOME/var/Themes/"Like ${i} - $ZSH_THEME"
    theme_example > $outf
    logf "Liked oh-my-zsh theme '\$ZSH_THEME'."
    logf "Theme name is written to '\$f'."
    logf "Theme example is written to '\$outf'."
    theme_n; sleep 3; re;
}
#
function theme_n() {
    local -i next=$1
    if [[ $next -eq 0 ]]; then
        next=$(( $TEMP_THEME_N + 1 ))
    fi
    echo $next > ~/var/TEMP_THEME_N
}
function theme_example() (
    cd $zterm
    for p in PS{1..4}; do
        print -P -x4 -- "\tPrompt '$p' = <${(P)p}>"
    done
    echo;echo;
    ls -lFGHah
)

alias dislike='theme_dislike'
alias like='theme_like'
alias example='theme_example'
alias next='theme_n'
#MARK:   TEMP -

function unwrap() {
    tput rmam
    print -P -- "%F{4}%S${(@)argv[1]}%s ${(@)argv:2}%f"
    ${=argv}
    tput smam
}


#function tap() {
#    pv@
#    while [[ $1 =~ '^[-+]' ]]; do
#        D "Shifting 1=$1"
#        shift
#    done
#    pv@
#    builtin set -- "${(@)argv}"
#    pv@
#}







function tt() {
    local x=${1:-0}
    local y=${2:-1}
    if [[ $x -eq $y ]]; then
        
    fi
}


#function iff() {
#    eval [[ ]]
#}


function thesaurus() {
    local URL='https://www.thesaurus.com/browse'
    local word=${argv// /%20}
    open -a 'Safari' $URL/$word
}


function one-by-one() {
    typeset -a commands
    commands=($argv)
    local argc=$#
    
#    while [[ -n $1 ]] && [[ $? -eq 0 ]]; do
#        () { green $1; return $1 } $1
#        shift
#    done
#    done
#
#    for cmd in $commands; do
    while [[ -n $1 ]]; do
        $=1
#        $=cmd
        
        printf '%d/%d  -  continue? (y/n)  ' $# $argc
        read -q do_next
        shift
    done
}



function cleanf() {
    local bytes=256
    local file=$1
    local size=$(stat -f '%z' < $file)
    print -a -C2 -Pl -- "%UFile:%u:" "$file" "%USize%u:" "$size bytes"
    
    hexyl -n $bytes < $file
    
    # ...
}


function f () {
    integer a b c
     #{1,2}
    #=${1:3}
    exec {a}>&0 {b}>&1 {c}>&2
#    exec
#    exec {
    print 'This is a log message.' >&$a >&1
    S a: $a,   b: $b,   c: $c
    exec {a}>&- {b}>&- {c}>&-
}



function dgst() {
    tput rmam
    local file d
    for file in $argv; do
        print -P -- "%F{4}${(l:$COLUMNS::*:)}%f"
        local -a list=(md4 md5 md5-sha1 sha1 sha256 sha512 rmd160 blake2b512)
        for d in $list; do
            openssl dgst -$d $file
#            openssl dgst -$d -binary $file
            # | fgrep -i $d
        done
    done
    print -P -- "%F{4}${(l:$COLUMNS::*:)}%f"
    tput smam
}

function randbytes() {
    local n_bytes=${1:-1}
    local output_file=${2:-/dev/stdout}
    print "Writing $n_bytes random bytes to $output_file."
    dd if=/dev/random of=$output_file bs=8 count=$n_bytes 2>/dev/null
}
function enc() {
    local file=$1
    local n=128
    local KEY
    local IV='00000000000000000000000000000000'
    for n in {128,192,256}; do
        KEY="$(printf '%s' $(xxd -p < ~/var/$n.key))"
        openssl enc -aes-$n-cbc -p -K $KEY -iv $IV -e -in $file -out $file-enc-$n
    done
}
function dec() {
    local file=$1
    local n=128
    local KEY
    local IV='00000000000000000000000000000000'
    for n in {128,192,256}; do
        KEY="$(printf '%s' $(xxd -p < ~/var/$n.key))"
        openssl enc -aes-$n-cbc -p -K $KEY -iv $IV -d -in ${file%-enc*}-enc-$n-* -out ${file%-enc*}-dec-$n
    done
}

function ecn2() {
    local file=$1
    cp -- "$file" "plaintext-$file.txt"
    
}





function ow() {
    stat -f "%Sp -> owner=%SHp group=%SMp other=%SLp"
}
function recent_files() {
    stat -f "%m%t%Sm %N" ${argv:-$PWD}/* | sort -rn | head -3 | cut -f2-
}


function tprof() {
    local name=${1:-'Light'}
    printf '%b\n' "\e]1337;SetProfile=Term 3: $name\a"
}
