# User-specific functions for interactive zsh(1) shells.


# Open default macOS Terminal.
function term1() {
    open -g '/System/Applications/Utilities/Terminal.app'
}
# Open iTerm2.
function term2() {
    open -g '/Applications/iTerm.app'
}

# Open in editor.
function edit() {
    $EDITOR "$@"
#    if ( ! open -a $EDITOR "$@" ); then
#        $EDITOR "$@"
#    fi
}



#MARK: - Oh-my-zsh Plugins
# Open oh-my-zsh root directory.
function myzsh() {
    open "$ZSH"
}
# Open oh-my-zsh/plugins.
function myplugins() {
    open "$ZSH/plugins"
}
# List plugins.
function list-plugins() {
    ls "$ZSH/plugins"
}
# Display information about an oh-my-zsh plugin.
function info-plugin() {
    local plugin_name="$1"
    open -a Xcode -g "$ZSH/plugins/$plugin_name/README"*
}
# Print plugin's README to stdout.
function cat-plugin() {
    local plugin_name="$1"
    cat "$ZSH/plugins/$plugin_name/README"*
}
# View next plugin's.
function next-plugin() {
    # Array of all plugin
    local all_plugins=($( command ls -1 "$ZSH/plugins" ))
    read_array arr
    # Seen/unseen plugins
    local seen=( $arr )
    local notseen=( ${all_plugins:|seen} )
    # Exit if seen all
    if [[ ${#notseen} -eq 0 ]]; then
        echo "<<< $(b_greenbg 'ALL PLUGINS SEEN') >>>"
        return 1
    fi
    # Next plugin is the first unseen
    local next=${notseen[1]}
    arr+=( $next )
    save_array arr
    # Sizes
    local N=${#all_plugins}
    local n=$(( ${#seen} + 1 ))
    echo "Opening plugin $( b_magenta "#${n} - $next"  ) out of ${N} total."
    info-plugin $next
}


#MARK: - Oh-my-zsh Themes
# List themes.
function list-themes() {
    local themes=(${$( command ls "$ZSH/themes" )%.zsh-theme})
    echo $themes
}
# View next theme.
function next-theme() {
    # All themes
    local themes=($( list-themes ))
    # Tried themes
    touch "$DEV/Library/Data/tried_themes.array"
    typeset -a tried_themes
    read_array tried_themes
    # Not tried themes
    local not_tried_themes=( ${themes:|tried_themes} )
    if [[ ${#not_tried_themes} -eq 0 ]]; then
        echo "<<< $(b_greenbg 'ALL THEMES TRIED') >>>"
        return 1
    fi
    # Pick first theme which has not been tried yet
    local next=${not_tried_themes[1]}
    tried_themes+=( $next )
    save_array tried_themes
    export ZSH_THEME=$next
    re "Current theme: $next"
}




#MARK: - Z-Functions (zf)
# Find Z-Function definition file.
function zf-find() {
    local fdir="$1"
    local fname="$2"
    if [[ -z $fdir ]] || [[ -z $fname ]]; then
        echo "$(Info zf-find): Function directory or function name is not defined."
        return 1
    fi
    f=$( find "$fdir" -name "$fname" )
    if [[ -z "$f" ]]; then
        echo "$(Info zf-find): Function '$(Bad $fname)' not found."
        return 1
    fi
    echo "$f"
    return 0
}


# Enable a Z-Function.
function zf-localfunction() {
    local fname="$1"
    local target_dir="${2:-zshell}"
    local subdirs=($( ls -d $zfunc/z* ))
    local subdirs_names=(${subdirs:t})
    # Check output subdirectory in 'zsh/functions'
    if [[ $subdirs_names[(wi)$target_dir] -gt ${#subdirs_names} ]]; then
        echo "Subdirectory '$(Bad $target_dir)' is not found in:"
        print -C 4 "$subdirs"
        return 1
    fi
    # Find disabled function
    f=$( zf-find "$DEV/Terminal/zsh/site-functions/" "$fname" )
    if [[ $? -ne 0 ]]; then
        echo "Function '$(Bad $fname)' is not a site function."
        return 1
    fi
    # Move function to an autoloaded directory
    mv "$f" "$zfunc/$target_dir/"
    echo "$(OK 'OK'): '$(bold $fname)' is now a local function."
    return 0
}
# Disable a Z-Function.
function zf-sitefunction() {
    local fname="$1"
    # Find an enabled function
    f=$( zf-find "$zfunc" "$fname" )
    if [[ $? -ne 0 ]]; then
        echo "Function '$(Bad $fname)' is not a site function."
        return 1
    fi
    # Move function to 'zsh/function/disabled'
    mv "$f" "$DEV/Terminal/zsh/site-functions"
    echo "$(OK 'OK'): '$(bold $fname)' is now a site function."
    return 0
}


# Enable a Z-Function.
function zf-enable() {
    local fname="$1"
    local target_dir="${2:-zshell}"
    local subdirs=($( ls -d $zfunc/z* ))
    local subdirs_names=(${subdirs:t})
    # Check output subdirectory in 'zsh/functions'
    if [[ $subdirs_names[(wi)$target_dir] -gt ${#subdirs_names} ]]; then
        echo "Subdirectory '$(Bad $target_dir)' is not found in:"
        print -C 4 "$subdirs"
        return 1
    fi
    # Find disabled function
    f=$( zf-find "$zfunc/disabled" "$fname" )
    if [[ $? -ne 0 ]]; then
        echo "Function '$(Bad $fname)' is not disabled."
        return 1
    fi
    # Move function to an autoloaded directory
    mv "$f" "$zfunc/$target_dir/"
    echo "$(OK 'OK'): enabled '$(bold $fname)'."
    return 0
}
# Disable a Z-Function.
function zf-disable() {
    local fname="$1"
    # Find an enabled function
    f=$( zf-find "$zfunc" "$fname" )
    if [[ $? -ne 0 ]]; then
        echo "Function '$(Bad $fname)' is not enabled."
        return 1
    fi
    # Move function to 'zsh/function/disabled'
    mv "$f" "$zfunc/disabled/"
    echo "$(OK 'OK'): disabled '$(bold $fname)'."
    return 0
}

# List all enabled and disabled Z-Functions.
function zf-list() {
    # Display enabled functions
    local fdirs=($( ls -d $zfunc/z* ))
    local enabled_list=()
    for fdir in $fdirs; do
        enabled_list+=($( ls -1G "$fdir" ))
    done
    b_greenbg 'ENABLED'
    print -C 4 ${(o)enabled_list}
    echo
    # Display disabled functions.
    local disabled_fdir="$zfunc/disabled"
    local disabled_list=$( ls -1G "$disabled_fdir" )
    b_redbg 'DISABLED'
    print -C 4 ${(o)disabled_list}
    echo
}
# Display number of enabled and disabled Z-Functions.
function zf-stat() {
    local on=($( printf '%s\n' $zfunc/z*/* ))
    local off=($( printf '%s\n' $zfunc/disabled/* ))
    local n_on=${#on}
    local n_off=${#off}
    local n_total=$(( $n_on + $n_off ))
    InfoSection 'Z-Functions'
    print -C 2 "Enabled: " "$n_on"
    print -C 2 "Disabled:" "$n_off"
    print -C 2 "Total:   " "$n_total"
}




#MARK: - File Directories
# Go to Z-Terminal root directory.
function ztermdir() {
    cdp "$ztermdir"
}
# Go to Z-Functions root directory.
function zfuncdir() {
    cdp "$zfunc"
}

# Go to SFU Spring 2020 directory.
function sfudir() {
    cdp "$SFU_TERM"
}


function pygments-styles() {
    local list=($( pygmentize -L 'styles' ))
    printf '%s' "$list" | grep -E '\* [[:alnum:]-]*' -o | sed -E 's/\* //g'
}



# Go to Desktop.
function desk()     { cdp "${(q)HOME}/Desktop/${@}"; }
# Go to Development root.
function dev()      { cdp "${(q)DEV}/${@}"; }
# Go to Library.
function lib()      { cdp "${(q)lib}/${@}"; }
# Go to Temporary Files.
function temp()     { cdp "${(q)tempdir}/${@}"; }
# Go to Test Files.
function testdir()  { cdp "${(q)testdir}/${@}" }




# Pass/Fail symbols.
function pass() {
    printf '%s\n' "$(b_green '✔︎')"
    return 0
}
function fail() {
    printf '%s\n' "$(b_bred '✘')"
    return 1
}



# Z-Cmd-Function
# date
function date_list_formats() {
    typeset -ag formats
    formats=()
    man strftime |
        colcrt - |
        fgrep -- '%' |
        awk '{ print $1 }' |
        while read fmt; do
            if [[ $fmt[1] == '%' ]]; then
                formats+=($fmt);
            fi
        done
    print -a -C 8 ${formats}
}
function date_formats_preview() {
    for format in $( date_list_formats ); do
        local full_command="\$( $(green "date -j +\'$format\'") )"
        local preview="$(blue ${(qq)$( date -j +"$format" )})"
        print -a -C2 "${format}\t ${full_command}\t" "${preview}"
    done
}


function magnetize() {
    open /Applications/Magnet.app -g
    local positions=('← Left ◧' '→ Right ◨' '↑ Up ⬒ ' '↓ Down ⬓')
    local group1=("⇧⌘"${^positions})
    printf "$(underline %s):\n" 'Magnet Commands'
    for cmd in $group1; do
        printf '%-*s' 35 "$(bold $cmd)"
    done
    echo
    
    #'Top Left ◰' 'Top Right ◳'
    #'Bottom Left ◱' 'Bottom Right ◲'
#    for cmd in $group2; do
#        printf '%-*s' 35 "$(bold $cmd)"
#    done
}

function letters() {
    typeset -ag Asym
    typeset -ag Anum
    
    Asym=({A..Z})
    Anum=({1..26})
    local letter=${1[1]:-L}
#    local compareTo=${2[1]}
    
    local index=${Asym[(wi)$letter]}
    if [[ $index -gt ${#Asym} ]]; then
        return 1
    fi
    
    Asym[$index]=$(b_bred $Asym[$index])
    Anum[$index]=$(b_bred $Anum[$index])
    { printf '  %s' ${Asym}; echo
        printf '%s ' $Anum; echo } | \
        column -t
    
    echo; echo;
    printf '  %s %s\n' ${Asym} ${Anum} | column -t
}

