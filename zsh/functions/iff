#!/bin/zsh

#  iff
#  Z-Function (74)
#
#  Created by Maxim Puchkov on 2020-06-25.
#  Copyright Â© 2020 Maxim Puchkov. All rights reserved.


# vars=(X Y) X=(1 2) Y=(3 4) iff 'X -lt Y'
# 1<3, 1<4, 2<3, 2<4

# iff -v X Y Z

# Evaluate and display the result of conditional expressions.

#iff -i x=(10,20,30)
typeset -a var_specs
zparseopts -D -E -a var_specs - i+:
#print -l -- $var_specs

typeset -ag exprs

local -a expr
while [[ -n $1 ]]; do
  case $1 in
    (--)
      exprs+=("${expr}")
      expr=()
      shift
      continue
    ;;
    (*)
      expr+=($1)
      shift
    ;;
  esac
done
exprs+=("${expr}")
#print -l -- $exprs




typeset -ag var_exprs
var_exprs=()

local var_expr
for opt spec in $var_specs; do
  local var_name=${spec%%=*}
  local -a var_values=(${(s:,:)${spec#*=}})
  local -a matches=(${(M)exprs:#*'$'$var_name*})
  red $exprs
  exprs=(${exprs:|matches})
  magenta $exprs
  for var_expr in $matches; do
    for var_value in $var_values; do
      var_exprs+=(${var_expr/\$${var_name}/${var_value}})
    done
  done
done

() {
  print -C1 -- $argv
} $exprs $var_exprs




#  red $opt $spec
#  blue $name '|' $values
#  echo

#function iff() {(
#    export prog=$0
#    ## iff -i var: specify variable names ##
#    if [[ $1 == '-i' ]]; then
#        typeset -a vars=(${(s:,:)2})
#        shift 2
#    fi
#    [[ $1 == '--' ]] && shift
#
#    for v in $vars; do
#        show "Var is $v"
##        for m in ${(M)argv:#$v}; do
##            show 'Matching element: $m'
###            argv[(i)$m]=$
##        done
###        set -- ${argv//$v/$REPL}
##        for vexp in ${(M)argv:#(|* )${v}( *|)}; do
##            print $vexp
##        done
#    done
#
#    # Evaluate each argument
#    local -i result
#    local result_label
#    print-var argv
#    if [[ $# -eq 0 ]]; then
#        usage 'Bad input.' \
#            '$prog "1 -lt 2"' \
#            '$prog -v X "X -gt 0"'
#    fi
#    while [[ -n $1 ]]; do
##        if [[ $1 =~ '' ]]; then
#
##        fi
#
#        builtin eval "[[ $1 ]]" &>/dev/null
#        let result=$?
#        case $result in
#            0) result_label='%F{2}true%f'  ;;
#            1) result_label='%F{1}false%f' ;;
#            *) result_label='%F{3}invalid expression%f' ;;
#        esac
#        builtin print -P -- "[[ $1 ]]:  $result_label"
#        shift
#    done
#    return 0
#)}
