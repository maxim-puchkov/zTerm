#!/bin/zsh

#  template
#  Documents & Support
#
#  Created by admin on 2020-03-04.
#  Copyright Â© 2020 Maxim Puchkov. All rights reserved.


# Generate files from templates.
# Synopsis:
#   template [options...] kind
function template() {
    # Generate unique suffixes for files which
    # already exist in Output directory.
    #   E.g.: file, file-2, ..., file-N.
    function generate_filename() {
        # Output file.
        local name="$1"
        local base=${name:r:t}
        if [[ -z $name ]]; then
            return 1
        fi
            
        # Count all files starting with the same 'base' name.
        local count=$( files count "$target_dir" "$base" )
        
        # If there exists a file with a similar name,
        # save new file with appended file number.
        local suffix=''
        if [[ $count -ge 1 ]]; then
            local file_number=$(( $count + 1 ))
            suffix="-$file_number"
        fi
        
        # Append file extension if necessary.
        local ext=''
        if [[ -n ${name:e} ]]; then
            ext=".${name:e}"
        fi
        
        # Print generated name.
        local new_name="${base}${suffix}${ext}"
        echo $new_name
    }
    
    # Replace ___MACRO___ strings.
    function substitute_macros() {
        local file=$1
        if [[ ! -e $file ]]; then
            return 1
        fi
        shift
        for macro in "$@"; do
            local macro_id="___${(U)macro#'m_'}___"
            local macro_value=${(P)macro}
            sed -i '' "s/$macro_id/$macro_value/g" $file
        done
    }
    
    # Copy template file to the target directory and
    # replace macro strings.
    function copy_template() {
        local m_filename="$1"
        local m_package_name="$2"
        local original="$3"
        local new_template="$4"
        # Create new file from a copy of the original file.
        if ( cp -n $original $new_template ); then
            m_filename=$name
            m_package_name=$package
            # Substitute template macro strings.
            substitute_macros "$new_template" $TEMPLATE_MACROS
            echo "Generated template file: '$(OK $new_template)'."
            save_array m_template_id $savefile
            return 0
        else
            error 'Fatal error.'
            return 1
         fi
    }
    
    
    #MARK: - Z-Shell Command Template
    function template_zsh() {
        target_dir="${target_dir:-${PWD}}"
        local name="${$( generate_filename ${1:-${(U)0}} )}"
        local package="$2"
        local new_template="${target_dir}/${name}"
        local TEMPLATE_ORIG="$TEMPLATES_DIR/$0"
        
        copy_template "$name" "$package" "$TEMPLATE_ORIG" "$new_template"
    }
    
    #MARK: - Z-Shell Function
    function template_zfunction() {
        target_dir="${target_dir:-${zfunc}}"
        local name="${$( generate_filename $1 ):-${(U)0}}"
        local package='Z-Function'
        local new_template="${target_dir}/${name}"
        local TEMPLATE_ORIG="$TEMPLATES_DIR/$0"
        
        copy_template "$name" "$package" "$TEMPLATE_ORIG" "$new_template"
    }
    
    #MARK: - Z-Shell Command Function
    function template_zcmdfunction() {
        target_dir="${target_dir:-${zfunc}}"
        local name="${$( generate_filename $1 ):-${(U)0}}"
        local package='Z-Function'
        local new_template="${target_dir}/${name}"
        local TEMPLATE_ORIG="$TEMPLATES_DIR/$0"
        
        copy_template "$name" "$package" "$TEMPLATE_ORIG" "$new_template"
    }
    
    #MARK: - Python Script
    function template_python() {
        target_dir="${target_dir:-${PWD}}"
        local name="${$( generate_filename ${1:-${(U)0}} )}"
        local package="$2"
        local new_template="${target_dir}/${name}"
        local TEMPLATE_ORIG="$TEMPLATES_DIR/$0.py"
        m_shebang='\#\!\/usr\/bin\/env\ python3'
        
        if (copy_template "$name" "$package" "$TEMPLATE_ORIG" "$new_template"); then
            chmod a+x $new_template
        fi
    }
    
    #MARK: - Z-Shell Completion
    function template_zcompletion() {
        target_dir="${target_dir:-${ZDOTDIR}/completions}"
        local name="${$( generate_filename _${1:-${(U)0}} )}"
        local package='Z-Function Completion'
        local new_template="${target_dir}/${name}"
        local TEMPLATE_ORIG=$( tempfile )
        
        zfc completion "$1" > "$TEMPLATE_ORIG"
        copy_template "$name" "$package" "$TEMPLATE_ORIG" "$new_template"
        rm -f "$TEMPLATE_ORIG"
    }
    
    
    
    
    if [[ $# -eq 0 ]]; then
        fn print-commands 'template'
        return 2
    fi
    
    local savefile="$zterm/etc/template.id"
    typeset -a lastid=( 0 )
    read_array lastid $savefile &>/dev/null
    
    # Template macro strings.
    typeset -a TEMPLATE_MACROS=(
        m_shebang           m_template_ts
        m_filename          m_package_name
        m_owner             m_username
        m_date_full         m_date_year
        m_organization_id   m_template_id
    )
    m_shebang='\#\!\/bin\/zsh'
    m_template_ts='<#timestamp#>'
    m_filename="<#name#>"
    m_package_name="<#package#>"
    m_owner='Maxim Puchkov'
    m_username='Maxim Puchkov'
    m_date_full=$( date +'%Y-%m-%d' )
    m_date_year=$( date +'%Y' )
    m_organization_id='com.maximpuchkov'
    m_template_id=( $(( $lastid + 1 )) )
    
    export TEMPLATE_MACROS
    export TEMPLATES_DIR="$ZDOTDIR/templates"
    
    # Function options.
    typeset -A optlist
    get_options optlist 'd:D' "$@"
    shift $optlist[length]
    
    # Source and compound commands.
    src=$( basename $0 )
    cmd=$1
    
    # Template output directory (-d).
    target_dir=${optlist[d]:a}
    if [[ -n "$target_dir" ]] && [[ ! -d "$target_dir" ]]; then
        error "Invalid directory: '$target_dir'"
        return 2
    fi
    
    # Compound command.
    case $cmd in
        "")
            print "Usage:"
            print -x2 "\t$(b_bcyan $src) $(cyan 'command') $(cyan 'arguments')... - call command '$src command' with a list of 'arguments'."
            ;;
        *)
            shift
            ${src}_${cmd} "$@"
            local ecode=$?
            if [ $ecode = 127 ]; then
                echo "Unknown command: $(Bad $cmd) (Exit code $ecode)." >&2
            fi
            ;;
    esac
    return $ecode
}
