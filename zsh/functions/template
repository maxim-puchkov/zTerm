#!/bin/zsh

#  template
#  Documents & Support
#
#  Created by admin on 2020-03-04.
#  Copyright Â© 2020 Maxim Puchkov. All rights reserved.


# Generate files from templates.
# Synopsis:
#   template [options...] kind
function template() {
    # Generate unique suffixes for files which
    # already exist in Output directory.
    #   E.g.: file, file-2, ..., file-N.
    function generate_filename() {
        # Output file.
        name="$1"
        local base=${name:r:t}
        if [[ -z $name ]]; then
            return 1
        fi
        # Count all files starting with the same 'base' name.
        local count=$( files count "$target_dir" "$base" )
        # If there exists a file with a similar name,
        # save new file with appended file number.
        local suffix=''
        if [[ $count -ge 1 ]]; then
            local file_number=$(( $count + 1 ))
            suffix="-$file_number"
        fi
        # Append file extension if necessary.
        local ext=''
        if [[ -n ${name:e} ]]; then
            ext=".${name:e}"
        fi
        # Print generated name.
        local new_name="${base}${suffix}${ext}"
        print -- $new_name
    }
    
    # Replace ___MACRO___ strings.
    function substitute_macros() {
        local file=$1
        if [[ ! -e $file ]]; then
            return 1
        fi
        shift
        local macro macro_id macro_value
        for macro in "$@"; do
            macro_id="___${(U)macro#'m_'}___"
            macro_value=${(P)macro}
            sed -i '' "s/$macro_id/$macro_value/g" $file
        done
    }
    
    # Copy template file to the target directory and
    # replace macro strings.
    function copy_template() {
        # Test run: print the names of the files only
        if [[ -n ${optlist[t]} ]]; then
            print -P -- "TestRun $0 [$$]: "\
                        "orig[$template_orig] --> "\
                        "New[%F{2}$template_new%f]."
            return 0
        fi
        
        # Copy the original template file to new location
        if ! ( command cp -n $template_orig $template_new ); then
            error 'Fatal error.'
            return 1
        fi
        # Substitute all template macro strings in the file
        substitute_macros "$template_new" $TEMPLATE_MACROS
        print -P -- "Generated template file: %F{2}$template_new%f (ID: $m_template_id)."
        
        # Update 'template.seq' and 'template.id' files
        print -- $template_new   >> $template_seq_file
        print -- $m_template_id  > $template_id_file
        return 0
    }
    
    
    #MARK: - Z-Shell command template
    ## zsh: zsh script ##
    function template_zsh() {
        target_dir="${target_dir:-${PWD}}"
        name="${$( generate_filename ${1:-${(U)0}} )}"
        m_filename=$name
        m_package_name='zsh'
        template_new="${target_dir}/${name}"
        template_orig="$templates_dir/$0"
        
        copy_template
    }
    
    #MARK: - Z-Shell function
    ## zfunction: zsh autoload function
    function template_zfunction() {
        target_dir="${target_dir:-${zfunc}}"
        name="${$( generate_filename $1 ):-${(U)0}}"
        m_filename=$name
        m_package_name='Z-Function'
        template_new="${target_dir}/${name}"
        template_orig="$templates_dir/$0"
        
        copy_template
    }
    
#    #MARK: - Z-Shell Command Function
#    function template_zcmdfunction() {
#        target_dir="${target_dir:-${zfunc}}"
#        name="${$( generate_filename $1 ):-${(U)0}}"
#        local package='Z-Function'
#        template_new="${target_dir}/${name}"
#        template_orig="$templates_dir/$0"
#        
#        copy_template
#    }
    
    #MARK: - Python script
    ## python: python3 script ##
    function template_python() {
        target_dir="${target_dir:-${PWD}}"
        name="${$( generate_filename ${1:-${(U)0}} )}"
        m_filename=$name
        m_package_name='Python'
        template_new="${target_dir}/${name}"
        template_orig="$templates_dir/$0.py"
        m_shebang='#!\/usr\/bin\/env\ python3'
        if (copy_template); then
            chmod a+x $template_new
        fi
    }
    
    #MARK: - Z-Shell completion function
    ## zcompletion: zsh function completion ##
    function template_zcompletion() {
        target_dir="${target_dir:-${ZDOTDIR}/completions}"
        name="${$( generate_filename _${1:-${(U)0}} )}"
        m_filename=$name
        m_package_name='zsh completion'
        template_new="${target_dir}/${name}"
        template_orig=$( tempfile )
        
        zfc completion "$1" > "$template_orig"
        copy_template
        command rm -f "$template_orig"
    }
    
    #MARK: - Z-Shell tool
    ## ztool: standalone zsh script ##
    function template_ztool() {
        target_dir="${target_dir:-${ZTERM}/Tools}"
        name="${$( generate_filename ${1:-${(U)0}} )}"
        m_filename=$name
        m_package_name='Terminal'
        template_new="${target_dir}/${name}"
        template_orig="$templates_dir/$0"
        if (copy_template); then
            chmod a+x $template_new
        fi
    }
    
    #MARK: - Launchd service
    function template_launchd() {
        target_dir="${target_dir:-${ZTERM}/etc/$1}"
        command mkdir -p -- $target_dir
        name="${$( generate_filename ${m_organization_id}.services.${1:-${(U)0}} )}.plist"
        m_filename=$name
        m_package_name='Services'
        template_new="${target_dir}/${name}"
        template_orig="$templates_dir/$0"
        copy_template
        
        template -d $ZTERM/Services ztool $1
        command ln -s -- $target_dir/$name  $HOME/Library/LaunchAgents/$name
        command ln -s -- $ZTERM/Services/$1 /usr/local/bin/$1
    }
    
    #MARK: - Oh-my-zsh custom plugin
    function template_plugin() {
        target_dir="${target_dir:-${ZDOTDIR/plugins/$1}}"
        mkdir -p -- $target_dir
        name="${$( generate_filename $1 ):-${(U)0}}.plugin.zsh"
        m_filename=$name
        m_package_name='Oh-my-zsh plugin'
        template_new="${target_dir}/${name}"
        template_orig="$templates_dir/$0"
        copy_template
        
        command mkdir -p -- $target_dir
        command ln -s -- $target_dir/$name $ZDOTDIR/.oh-my-zsh/plugins/custom/$1/$name
        
    }
    
    
    function template_null() {
        print -P "Called $0"
        print-fstack
    }
    
    
    
    
    # Files
    typeset template_seq_file="$ZTERM/etc/template.seq"
    typeset template_id_file="$ZTERM/etc/template.id"
    touch $template_seq_file $template_id_file
    typeset lastid=${$(< $template_id_file):-0}
    typeset templates_dir="$ZDOTDIR/templates"
    
    # Template macro strings
    local m_shebang   m_template_ts  m_filename   m_package_name     m_owner \
          m_username  m_date_full    m_date_year  m_organization_id  m_template_id
    m_shebang='#!\/bin\/zsh'
    m_template_ts='<#timestamp#>'
    m_filename="<#name#>"
    m_package_name="<#package#>"
    m_owner='Maxim Puchkov'
    m_username='Maxim Puchkov'
    m_date_full=$( date +'%Y-%m-%d' )
    m_date_year=$( date +'%Y' )
    m_organization_id='com.maximpuchkov'
    m_template_id=( $(( $lastid + 1 )) )
    export TEMPLATE_MACROS=(
        m_shebang   m_template_ts  m_filename   m_package_name     m_owner
        m_username  m_date_full    m_date_year  m_organization_id  m_template_id
    )
    
    # Function options
    typeset -A optlist
    get_options optlist 'd:Dt' "$@"
    shift $optlist[length]
    
    if [[ $# -eq 0 ]]; then
        fn print-commands $0
        return 2
    fi
    
    typeset name target_dir template_orig template_new
    
    # Template output directory (-d)
    target_dir=${optlist[d]:a}
    if [[ -n "$target_dir" ]] && [[ ! -d "$target_dir" ]]; then
        error "Invalid directory: %F{1}$target_dir%f."
        return 2
    fi
    # Test run (-t)
    if [[ -n $optlist[t] ]]; then
        m_template_id='No identifier'
    fi
    
    # Subcommand
    typeset cmd=$1
    if ! (whence ${0}_${cmd} &>/dev/null); then
        error -127 'Function command not found: $cmd.'
    fi
    shift
    ${0}_${cmd} "$@"
    typeset -i exit_code=$?
    
#    builtin print -P -- "${0}: done."
    logm "Done"
    return $exit_code
}
