#!/bin/zsh

#  get-arguments
#  Z-Function (46)
#
#  Created by Maxim Puchkov on 2020-06-01.
#  Copyright Â© 2020 Maxim Puchkov. All rights reserved.


# Name:
#   get-arguments
#
# Usage:
#   get-arguments [-[Aa] array_id] [-[fo] name,...],... args
#
# Description:
#   Parse arguments, store recognized flags
#   and options in an array, and remove
#   them from positional arguments.
#
# Examples:
# 1. Parse options X,Y,Z and store their values in 'optlist':
#       get-arguments -o X,Y,Z -- -Z opt-Z -X opt-x -Y opt-y
# 2. Parse flags A,B, options C,D, and store result in 'myArray':
#       typeset -A myArray
#       get-arguments -A myArray -f A,B -o C,D -- -C opt-C -A -D opt-D -B
function get-arguments() {
    typeset -a name_list
    typeset -i distance
    
    
    #MARK: - Parse Argument Names
    # Parse list of argument names and calculate
    # shift distance
    function get-arguments-parse-list() {
        distance=0
        # Type (flag or option)
        typeset name_type=$1
        shift
        distance=$(( $distance + 1 ))
        if [[ -z $1 ]]; then
            error -1 'Cannot parse $name_type.'
        fi
        # List of individual names
        name_list=()
        if [[ $1 =~ '[,]' ]]; then
            # Add each comma-separated
            # argument to the list
            while [[ $1 =~ '[,]' ]]; do
                name_list+=($=1)
                distance=$(( $distance + 1 ))
                if [[   $1 =~ '[,][ ]?$' ]] &&
                   [[ ! $2 =~ '[,]' ]]; then
                    name_list+=($=2)
                    distance=$(( $distance + 1 ))
                    break
                fi
            shift
            done
        else
            # If an argument does not contain commas,
            # then it is the only argument
            name_list+=($=1)
            distance=$(( $distance + 1 ))
        fi
        return 0
    }
    
    
    #MARK: - Parameters for get-arguments
    # Names of flags and options
    typeset -aU flag_names option_names
    flag_names=()
    option_names=()
    # Result array
    typeset array_id array_type
    array_id='optlist'
    array_type='-A'
    # Parse flag and option names
    while [[ $1 =~ '^[-]' ]]; do
        case $1 in
            # Flags
            -f|--flags)
                # Parse flag names
                get-arguments-parse-list $argv
                if [[ $? -ne 0 ]]; then
                    return 1
                fi
                # Append new flag names to 'flag_names' array
                shift $distance
                flag_names+=(${=${(s:,:)name_list}})
            ;;
            # Options
            -o|--opts|--options)
                # Parse option names
                get-arguments-parse-list $argv
                if [[ $? -ne 0 ]]; then
                    return 1
                fi
                # Append new option names to 'option_names' array
                shift $distance
                option_names+=(${=${(s:,:)name_list}})
            ;;
            # Set name of the result associative array
            -A) shift
                array_id=$1
                array_type='-A'
                shift
            ;;
            # Set name of the result array
            -a) shift
                array_id=$1
                array_type='-a'
                shift
            ;;
            # Stop parsing parameters
            --) shift ;&
            *)  break ;;
        esac
    done
    # Check argument names
    if [[ -z $flag_names ]] && [[ -z $option_names ]]; then
        error -1 'Missing argument descriptions.'
    fi
    # Check that there are more arguments
    if [[ $# -eq 0 ]]; then
        #error -1 'Nothing to parse.'
        return 1
    fi
    
    
    #MARK: - Parse Arguments with zparseopts
    # Initialize 'flags' and 'opts' arrays
    typeset -a flags
    typeset -A opts
    flags=()
    opts=()
    # Set 'specs' for the zparseopts builtin
    typeset -a specs
    specs=(${^flag_names}'=flags' ${^option_names}':=opts')
    # Parse and store recognized flags and options
    builtin zparseopts -D -E -- $=specs &>/dev/null
    if [[ $? -ne 0 ]]; then
        error -1 'Failed to parse options.'
    fi
    trap 'builtin set -- "'${argv}'"' EXIT
#    trap "bluebg $argv; builtin set -- \"${argv}\";" EXIT
    # Append each flag to 'opts' as an option
    # with value 'flag is set'
    typeset flag
    for flag in $flags; do
        opts[$flag]="${flag} is set"
    done
    
    
    #MARK: - Set Result Array
    # Assign options to the result array
    unset $array_id
    typeset $=array_type -g $array_id
    set -A $array_id ${(kv)opts}
    
    
    unfunction -m "${0}-*"
    return 0
}
