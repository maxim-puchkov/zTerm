#!/bin/zsh

#  error
#  /usr/local/zterm/zsh/functions (id: 29)
#
#  Generated by 'ztemplate_apply' (zterm/zsh/sources) on 2020-10-10
#  Copyright Â© 2020 Maxim Puchkov. All rights reserved.


# error
#
# Print error message and return from calling function.
#
# Usage:
# error [-c num] [-m message] [--color color]
#       [--usage "line1[; line2[; ...]]"]
typeset -i last_code=$?
typeset PROG="${(C)0##/*}"

emulate -L zsh
setopt extended_glob
autoload -Uz syntaxf




# If 'SET_TRAP' is 1, error will cause the caller
# function to return if exit code is not 0.
typeset SET_TRAP=${SET_TRAP:=1}




#MARK: - Options
# If the first parameter is '-<digit>',
# interpret it as '--code <digit>'.
if [[ "$1" =~ ^[-][[:digit:]]+$ ]]; then
  set -- '--code' ${1#-} ${argv:2}
fi

# @define     option
# @annotation option @opt
#
# @opt -c,--code     Set error return code.
# @opt -C,--color    Set error title color.
# @opt -m,--message  Set error message.
# @opt -P,--program  Set program display name.
# @opt -S,--say      Say the error message.
# @opt -T,--trace    Print function trace.
# @opt -u,--usage    Print program usage description.
# @opt -e,--err      Print short error message only.
#
# @opt -I,--stdin    Read error message from standard input.
# @opt -d,--delim    Delimiter (use with --field).
# @opt -f,--field    Initial field in message.
local -A opts
opts=(
  [--code]="1"
  [--color]="red"
  [--delim]=":"
)
local -a specs
specs=(
  '-code:'    'c:=-code'
  '-color:'   'C:=-color'
  '-message:' 'm:=-message'
  '-program:' 'P:=-program'
  '-say'      'S=-say'
  '-trace'    'T=-trace'
  '-usage:'   'u:=-usage'
  '-err'      'e=-err'
  
  '-stdin'    's=-stdin'    'I=-stdin'
  '-delim:'   'd:=-delim'
  '-field:'   'f:=-field'
)
if [[ $# -gt 0 ]] &&
   ! zparseopts -D -K -M -A opts - ${specs[@]}; then
  return 1
fi
[[ $1 == '--' ]] && shift




# Append input after parameters.
if [[ ${+opts[--stdin]} -eq 1 ]] &&
   [[ ! -t 0 ]]; then
  set -- "$@" "${(f)$(<&0)}"
fi




# Set variables
local program_name=${opts[--program]}             # Program display name
local -i code=${opts[--code]}                     # Return code
local -i title_width=6                            # Width is length of "Usage:" (6)
local c_error=${opts[--color]} c_usage='cyan'     # Error and Usage title colors


# Error message text and usage text
local -a message usage excluded_titles
set -A excluded_titles "$ZSH_ARGZERO" '\(anon\)'  # Exclude top-level, anon
set -A message    ${opts[--message]} $argv        # Append arguments to message
set -A usage      ${opts[--usage]}                # Usage (next line: "; ")
# Format message syntax
if [[ ${+functions[syntaxf]} -eq 1 ]]; then
  message="${$(syntaxf -c -n -- $message 0</dev/null)}"
fi
# --skip: skip n delimiters
local field_num=${${opts[--field]##[[:punct:]]#}%%[[:punct:]]#}
if [[ ${+opts[--field]} -eq 1 ]] &&
   [[ $field_num -ge 1 ]]; then
  local delim=${opts[--delim]}
  local -i i
  for i in {1..$field_num}; do
    message="${message#*$delim}"
  done
  message="${message#[ ]*}"
fi

# Title labels
local usage_title="%F{$c_usage}Usage%f"           # "Usage"
local error_title="%F{$c_error}"                  # Caller or "Error"
if [[ ${+opts[--program]} -eq 1 ]]; then
  error_title+="${program_name}%f"
else
  error_title+="\${\${0#(${(j:|:)~excluded_titles})}:-$PROG}%f"
fi




# Make exit trap
local -a error_trap=()

if [[ ${+opts[--err]} -eq 1 ]]; then
  # Short error message (-e)
  if [[ $last_code -ne 0 ]] &&
     [[ $code -eq 1 ]]; then
    code=$last_code
  fi
  error_trap+="print -- \"error $code\" \$_"
elif [[ -n "$message" ]]; then
  # Default error message (-m)
  error_trap+="print -P -- \"${(%)error_title}: $message\""
fi

# --say: Say the error message with computer voice
if [[ ${+opts[--say]} -eq 1 ]]; then
  error_trap+="/usr/bin/say -- \"$message\" &!"
fi

# --trace: Print function trace in form of:
# 'function:155->TopLevel:3'
if [[ ${+opts[--trace]} -eq 1 ]]; then
  local arrow='%F{1}->%f'
  local -a trace=( ${(pj:$arrow:)functrace//$ZSH_ARGZERO/TopLevel} )
  error_trap+="print -- \"Trace: ${(%)trace}\""
fi

# Usage
if [[ -n "$usage" ]]; then
  set -A usage ${(@fs:; :)^usage}$'\n\t'
  error_trap+="print -P -x ${title_width} -- \"${usage_title}: ${usage}\""
fi


if [[ $code -ne 0 ]]; then
  error_trap+="return ${code}"
fi

# Set exit trap
if [[ $SET_TRAP -eq 1 ]]; then
  trap "{${(j:; :)error_trap}} >&2" EXIT
fi


return $code
