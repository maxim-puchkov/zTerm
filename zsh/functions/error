#!/bin/zsh

#  error
#  /usr/local/zterm/zsh/functions (id: 29)
#
#  Generated by 'ztemplate_apply' (zterm/zsh/sources) on 2020-10-10
#  Copyright Â© 2020 Maxim Puchkov. All rights reserved.


# error
#
# Print error message and return from calling function.
#
# Usage:
# error [-c num] [-m message] [--color color]
#       [--usage "line1[; line2[; ...]]"]
local -i last_code=$?

emulate -LR zsh
autoload -Uz syntaxf


typeset PROG="${(C)0##/*}"


# If 'SET_TRAP' is 1, error will cause the caller
# function to return if exit code is not 0.
typeset SET_TRAP=${SET_TRAP:=1}


# If the first parameter is '-<digit>', interpret
# it as option '--code -<digit>'.
if [[ "$1" =~ ^[-][[:digit:]]+$ ]]; then
  set -- '--code' ${1#-} ${argv:2}
fi




# Function options.
# @define     option
# @annotation option @opt
#
# @opt -c,--code     Set error return code.
# @opt -C,--color    Set error title color.
# @opt -m,--message  Set error message.
# @opt -P,--program  Set program display name.
# @opt -s,--stdin    Read error message from standard input.
# @opt -S,--say      Say error message.
# @opt -t,--trace    Print function trace.
# @opt -u,--usage    Print program usage.
# @opt -e,--err      Print short error message.
local -A opts
opts=([--code]="1" [--color]="red")
local -a specs
specs=(
  '-code:'    'c:=-code'
  '-color:'   'C:=-color'
  '-message:' 'm:=-message'
  '-program:' 'P:=-program'
  '-stdin'    's=-stdin'
  '-say'      'S=-say'
  '-trace'    'T=-trace'
  '-usage:'   'u:=-usage'
  '-err'      'e=-err'
)
if [[ $# -gt 0 ]] &&
   {! zparseopts -D -K -M -A opts - $specs}; then
  return 1
fi
[[ $1 == '--' ]] && shift




# Append piped input after parameters.
if [[ ${+opts[--stdin]} -eq 1 ]] &&
   [[ ! -t 0 ]]; then
  local -a error_input
  set   -A error_input ${(@f)"$(<&0)"}
  set -- $argv $error_input
fi




# Set variables
local program_name=${opts[--program]}             # Program display name
local -i code=${opts[--code]}                     # Return code
local -i title_width=6                            # Width is length of "Usage:" (6)
local c_error=${opts[--color]} c_usage='cyan'     # Error and Usage title colors


# Error message text and usage text
local -a message usage excluded_titles
set -A excluded_titles "$ZSH_ARGZERO" '\(anon\)'  # Exclude top-level, anon functions
set -A message    ${opts[--message]} $argv        # Append arguments to error message
set -A usage      ${opts[--usage]}                # Usage lines delimited with "; "
# Format message syntax
if [[ ${+functions[syntaxf]} -eq 1 ]]; then
  message="${$(syntaxf -cn -- $message 0</dev/null)}"
fi


# Title labels
local usage_title="%F{$c_usage}Usage%f"           # "Usage" label
local error_title="%F{$c_error}"                  # Set alternative "Error" label
if [[ ${+opts[--program]} -eq 1 ]]; then
  error_title+="${program_name}%f"
else
  error_title+="\${\${0#(${(j:|:)~excluded_titles})}:-$PROG}%f"
fi




# Make an EXIT trap 
local -a error_trap=()
if [[ ${+opts[--err]} -eq 1 ]]; then
  # Short error message
  if [[ $last_code -ne 0 ]] &&
     [[ $code -eq 1 ]]; then
    code=$last_code
  fi
  error_trap+="print -- \"error $code\" \$_"
elif [[ -n "$message" ]]; then
  # Default error message
  error_trap+="print -P -- \"$error_title: $message\""
fi
if [[ ${+opts[--say]} -eq 1 ]]; then
  error_trap+="/usr/bin/say \"$message\" &|"
fi
# Trace
if [[ ${+opts[--trace]} -eq 1 ]]; then
  local arrow='%F{1}->%f'
  local -a trace=()
  set -A trace ${(pj:$arrow:)functrace//$ZSH_ARGZERO/'Top_Level'}
  error_trap+="print -- \"Trace: ${(%)trace}\""
fi
# Usage
if [[ -n "$usage" ]]; then
  set -A usage ${(@fs:; :)^usage}$'\n\t'
  error_trap+="print -P -x ${title_width} -- \"${usage_title}: ${usage}\""
fi
if [[ $code -ne 0 ]]; then
  error_trap+="return ${code}"
fi
# Set the trap
if [[ $SET_TRAP -eq 1 ]]; then
  trap "{${(j:; :)error_trap}} >&2" EXIT
fi


return $code
