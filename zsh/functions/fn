#!/bin/zsh

#  fn
#  Generated by mkzsh at 03:13am.
#
#  Created by mpuchkov/506:20 on April 10, 2021.
#  ~/private/functions/fn


 
#@define option
#@define command   1
#@define arg       *: :( $ZDOTDIR/{functions,completions}{,/**/*}(:t) ${(k)functions} )
function fn {


emulate -L zsh
setopt extended_glob
autoload -Uz error highlight

[[ -n "${functions_source[$0]}" ]] || {
     builtin unfunction   -- "$0" \
  && builtin autoload -Uz -- "$0"
}

typeset PROG="$0"
export _ZFN_AWK_DIR="$ZDOTDIR/lib/plugins/zfn/AWK"


#@fn usage: print usage text for this function.
__fn__usage() {
  command cat <<EOF
$0
EOF
  return 1
}




#@fn commands: list function subcommands.
__fn__commands() {
  local -A opts=(
    '--field-separator'  ", "
    '--prefix'           "__${1:-PROG}__"
  )
  local -a specs=( '-field-separator:' 'F:=-field-separator' '-prefix:' 'P:=-prefix' )
  zparseopts -D -F -M -K -A opts - $specs
  local separator="${opts[--field-separator]}"
  local prefix="${opts[--prefix]}"
  local -a subcmds=( ${${functions[(I)$prefix*]}#$prefix} )
  [[ ${#subcmds} -gt 0 ]] || return 1
  print -nrC1 -- "${(pj:$separator:)subcmds}"
}


# fn open
__fn__open() {
  [[ ${+functions[$1]} -eq 1 ]] || return 1
  autoload +X "$1"
  command open -a ${CODE_EDITOR:-Xcode} -- "${functions_source[$1]}"
}

# fn show
__fn__show() {
  [[ ${+functions[$1]} -eq 1 ]] || {
    error -1 -P "$PROG" -m 'function ${1} not found'
    return 1
  }
  [[ -n "${functions_source[$1]}" ]] || autoload +X "$1"
  print -nrC1 -- "${functions[$1]}" \
  | command sed -E -e 's/^\t//' \
  | highlight

  # | command sed -E -n -e 's/^\t//p' \
}

# fn where
__fn__where() {
  [[ ${+functions[$1]} -eq 1 ]] || {
    error -1 -P "$PROG" -m 'function ${1} not found'
    return 1
  }
  [[ -n "${functions_source[$1]}" ]] || autoload +X "$1"
  print -nrC1 -- "${functions_source[$1]}"
}



## fn source
#__fn__source() {
#  if [[ -z "${functions_source[$1]}" ]]; then
#    autoload +X "$1" # &>/dev/null
#  fi
#  print -- "${functions_source[$1]}"
#}

  
  #print -nrC1 -- ${(@f)"$(builtin functions -x2 $1)"} \
  #| command sed -n -e 's/^  //p' -e '1d' -e '$d'








# 




#MARK: Completion Functions
# @command      tags
# +description  Parse function source file to generate completion tags.
__fn__tags() {
  local function_name="$1"
  autoload +X $function_name
  local function_file="${functions_source[$function_name]}"
  if [[ -z "$function_file" ]]; then
    error -1 -m 'function file for ${function_name} not found'
  fi
  # local awk_program="$_ZFN_AWK_DIR/tags.awk"
  local awk_program="$_ZFN_AWK_DIR/${0##*_}.awk"
  command awk -f $awk_program -v v_prefix="__${PROG}__" "$function_file"
  #local awk_program="$_ZFN_AWK_DIR/${0#*_}.awk"
#  /usr/bin/awk "$@"                   \
#      -f "$awk_program"               \
#      -v v_prefix="${function_name}_" \
#      "$function_file"
}


# @command      complete
# +description  Parse completion tags to generate completion function.
__fn__complete() {
  local function_name="$1"
  # local awk_program="$_ZFN_AWK_DIR/complete.awk"
  local awk_program="$_ZFN_AWK_DIR/${0##*_}.awk"
  $PROG tags "$function_name" | command awk -f "$awk_program"
}












###  Main  ###
# Without arguments, print function usage.
[[ $# -gt 0 ]] || {
  __${0}__usage
  return 1
}

# Check the specified command.
local command=$1
shift
[[ ${+functions[__${0}__${command}]} -eq 1 ]] || {
  error -1 -m '${command} is not a valid command'
  return 1
}

__${0}__${command} "$@"


















}




#print -P -- "%F{2}Args: ${(j:, :)@}%f (count = $#)"


#function omz {
#  [[ $# -gt 0 ]] || {
#    $0::help
#    return 1
#  }
#
#  local command="$1"
#  shift
#
#  # Subcommand functions start with _ so that they don't
#  # appear as completion entries when looking for `omz`
#  (( $+functions[_omz::$command] )) || {
#    $0::help
#    return 1
#  }
#
#  $0::$command "$@"
#}



#compdef _fn fn
#functions -T fn


