#!/bin/zsh

#  fn
#  Z-Function
#
#  Created by mpuchkov on 2020-03-12.
#  Copyright Â© 2020 Maxim Puchkov. All rights reserved.


# Information about shell functions.
#
# Options:
## fn -h,--help: show help ##

# Arguments:
## arg1: vars ##
## arg2: ##
function fn() {(
    autoload -Uz print-line
    
    ## def: print function source code ##
    function fn_def() {
        local label="function %U%B${fn_name}%b%u () {"
        local def="$(functions $fn_name | highlight | tail -n +2)"
        printf '%s\n%s\n' "${(%)label}" "$def"
        return $?
    }
    ## src: find function source file ##
    function fn_src() {
        local fsource=$functions_source[$fn_name]
        if [[ -z $fsource ]]; then
            error -2 'Function definition file for $fn_name was not found.'
        fi
        # Abbreviate directories
        local -a output_flags=('-P')
        if [[ -t 1 ]]; then
            output_flags+=('-D')
        fi
        builtin print $=output_flags -- "$fsource"
        return 0
    }
    ## show: display function definition and source file ##
    function fn_show() {
        local fn_code=$(fn def $fn_name)
        local fn_line=${(%):-"%F{8}${(l:$COLUMNS::-:)}%f"}
        builtin print -f '%s\n%s\n%s\n\n%s\n' \
            "$fn_line" "$fn_code" "$fn_line" "${(D)fn_file}"
        return 0
    }
    ## open: open function source file ##
    function fn_open() {
        if [[ ! -r $fn_file ]]; then
            error -1 'Cannot read source file for function $fn_name.'
        fi
        /usr/bin/open -a Xcode -- $fn_file
        return 0
    }
    ## isdef: check if a function is defined ##
    function fn_isdef() {
        if [[ ${+functions[$fn_name]} -ne 1 ]]; then
            return 1
        fi
        return 0
    }
    ## sub: list functions defined within a function ##
    function fn_sub() {
        typeset fn_syntax fn_pattern
        fn_syntax='function ('${fn_prefix}'|\$0|\$\{(\(.*\))?0\})_((?:\w|-)+)'
        fn_pattern="^[^#]*(function\s+${fn_syntax}|${fn_syntax}\s*\(\))\s*"
        
        typeset -a list
        list=($( egrep -o -i -E "${fn_pattern}" -- $fn_file ))
        list=(${${list#'function'*}%*'()'})
        
        typeset -a result
        local f
        for f in $list; do
            typeset subfn_name=${f%'('*')'}
            subfn_name=$(sed -E -e 's/\$(\{0\}|0)/'${fn_prefix}'/g' <<< $subfn_name)
            if [[ ${+functions[$subfn_name]} ]]; then
                result+=($subfn_name)
            fi
        done
        if [[ -z $result ]]; then
            error -2 'BOB'
            return 1
        fi
        print -l -- $result
        return 0
    }
    ## commands: list function commands ##
    function fn_commands() {
        typeset -a fcommands=(${$(fn_sub $fn_name)//${fn_prefix}_/})
        printf '%s\n' $fcommands
        return 0
    }
    ## print-commands: format and list function commands ##
    function fn_print-commands() {
        typeset -a commands
        commands=($(fn_commands $fn_name))
        if [[ -z $commands ]]; then
            return 1
        fi
        if [[ -t 1 ]]; then
            print -P -- "%B%U${fn_name} commands%u%b:"
            print -Pl -X2 -- '%F{4}\t'${^commands}'%f'
        else
            print -Pl -- ${commands}
        fi
        return 0
    }
    ## options: list function flags and options ##
    function fn_options() {
        typeset grep_pattern='^[ ]*##[ ]*[\-\+][^ ]+: .* ##[ ]*$'
        typeset sed_pattern='s/## ([\-\+].*): (.*) ##/\1: \2/p'
        typeset -A reply
        reply=("${(@f)$(grep -E $grep_pattern $fn_file |
            sed -n -E $sed_pattern |
            awk -F ': ' '{print $1; print $2;}' )}")
        # Print completion for arguments
        local k v
        for k v in ${(kv)reply}; do
            if [[ $k =~ '[,]' ]]; then
                k="{$k}"
            fi
            printf '\t%s"[%s]" \\\\\n' "$k" "$v"
        done
    }
    
    # Completion for flags and options
    function fn_completion-arguments() {
        typeset -A reply
        typeset grep_pattern='^[ ]*##[ ]* (.+) [-+][^ ]+[^:]*: .* ##[ ]*$'
        typeset sed_pattern='s/## (.+) ([-+][^ ]+)[^:]*: (.+) ##/\2: \3/p'
        reply=("${(@f)$(grep -E $grep_pattern $fn_file |
            sed -n -E $sed_pattern |
            awk -F ': ' '{print $1; print $2;}' )}") 2>/dev/null
        if [[ $? -ne 0 ]]; then
            error -1 'Parse error'
        fi
        # Print completion for arguments
        local k v
        for k in ${(ok)reply}; do
            v=${reply[(k)$k]}
            if [[ $k =~ '[,]' ]]; then
                k='{'${k// /}'}'
            fi
            printf '\t%s"[%s]"\n' "$k" "$v"
        done
        return 0
    }
    
    # Completion for commands
    function fn_completion-commands() {
        typeset -A reply
        typeset -a fn_commands=($(fn commands ${fn_file:t}))
        # Parse commands
        local cmd
        for cmd in ${fn_commands}; do
            local pattern="## ${cmd}: .+ ##.*function ${fn_name}[\-\_]${cmd}[\s]*\(\)"
            local description=$(
                greps '-o' "$pattern" "$fn_file" |
                    head -n 1 |
                    sed -e "s/## ${cmd}: //g" -e "s/ ##.*//g"
            )
            reply[$cmd]="${description:-''}"
        done
        
        # Print command completion
        local k v
        for k in ${(ok)reply}; do
            v=${reply[(k)$k]}
            printf '\t%s:"%s"\n' "$k" "$v" | colrm
        done
        return 0
    }
    
    #MARK: - Z-Shell Function Completion
    ## completion: generate function command completion ##
    function fn_completion() {
        # Find files starting with the specified 'fn_name'
        typeset -a cmd_completion=()
        typeset -a arg_completion=()
        # Parse each file and generate argument/command completion
        typeset fn_dir file
        fn_dir="${$(fn_src $fn_name):h}"
        for fn_file in ${fn_dir}/${fn_name}*; do
            autoload +X ${fn_file:t}
            arg_completion=(${(@f)"$(fn_completion-arguments $fn_file)"})
            cmd_completion=(${(@f)"$(fn_completion-commands $fn_file)"})
        done
        
        
cat <<EOF
#compdef ${fn_name}

# _${fn_name}
# ${(D)fn_dir}/${fn_name}
#
# zsh function completion
# $(date -j +'Updated on %F at %I:%M %p')


_arguments -C \\$(if [[ -n $arg_completion ]]; then
  builtin print -x2 -- '\n' ${^arg_completion}' \\\n'
fi)
  ":command:->command" \\
  "*::arg:->arg"

case \$state in
  (command)
    typeset -a commands
    commands=(
$(if [[ -n $cmd_completion ]]; then
  builtin print -x6 -l -- ${cmd_completion}
fi)
    )
    _describe -t commands command commands
  ;;
  (arg)
    typeset -a args
    args=(
      # Completion for commands' arguments
    )
    _describe -t args arg args
  ;;
esac

return 0
EOF
        
        
        return 0
    }
    
    
    ## compgen: generate and update function completion ##
    function fn_compgen() {
        function completion_function() {
            awk '/_arguments/,/exit;/  {print $0;}' <&0
        }
        # Set target file path
        () {
            typeset target="${zcomp}/_${fn_name}"
            if [[ -e $target ]]; then
                # Compare old and new completion functions
                diff -s -q -- =(completion_function <$target) \
                              =(completion_function <$1)      \
                              &>/dev/null
                # Stop if the files are identical
                if [[ $? -eq 0 ]]; then
                    error -2 'Function completion is already up-to-date.'
                    return 2
                fi
                # If completion function is outdated, ask to overwrite it
                typeset -i target_size new_size
                target_size=$(stat -f '%z' -- $target)
                new_size=$(stat -f '%z' -- $1)
                print -P -- "%F{1}%BWarning\!%b%f"
                print -P -- "Target file '%F{2}${target}%f' already exists."
                print -P -- "Overwrite '%F{2}${target}%f' (%F{2}${target_size}%f bytes) with updated completion file (%F{2}${new_size}%f bytes)? (yes/no)"
                
                # Read user response if overwrite is not enabled with option '-y'
                (
                    [[ -z $response ]] && read response
                    if [[ ! $response =~ "${langinfo[YESEXPR]}" ]]; then
                        error -1 "User response is 'no'." \
                            "Aborting..."
                    fi
                )
                if [[ $? -ne 0 ]]; then
                    return 1
                fi
                print -P -- "Overwriting completion function..."
            fi
            cat <$1 >$target
            print -P -- "Completion function %F{2}_${fn_name}%f updated."
        } =(fn_completion $fn_name)
        return 0
    }
    
    ## d: debug function ##
    function fn_d() {(
        typeset -fT $fn_name
        print-line
        $fn_name $argv
        print-line
    )}
    
    function fn_edit() {(
        ${=EDITOR} -- $fn_file
        return 0
    )}
    function fn_xedit() {(
        /usr/bin/open -F -a Xcode -- $fn_file
        return 0
    )}
    
    function fn_modify() {(
        cat <$fn_file
    )}
    
    
    
    #MARK: - Options
    # Parse
    typeset -A optlist
    autoload -Uz get-arguments
    get-arguments -A optlist \
                  --flags 'h' 'y' \
                  -- $argv
    # Set compgen overwrite response (-y)
    typeset response=${optlist[-y]:+'yes'}
    # Show help message (-h)
    if [[ $# -eq 0 ]] ||
       [[ $optlist[-h] -eq 1 ]]; then
        $0 print-commands $0
        return 0
    fi
    
    
    
    
    # Command name
    typeset cmd=$1
    if [[ ${+functions[${0}_${cmd}]} -ne 1 ]]; then
        error -127 'Command not found: ${cmd}.'
    fi
    shift
    
    # Command arguments
    typeset fn_name=$1
    if [[ -z $fn_name ]]; then
        error -1 'Missing function name.'
    fi
    shift
    # Return if function is not defined
    if [[ ${+functions[$fn_name]} -ne 1 ]]; then
        error -127 'Function not found: ${fn_name}.'
    fi
    
    
    # Function name prefix
    if [[ -z $fn_prefix ]]; then
        typeset fn_prefix=${fn_name%%[_-]*}
    fi
    
    # Source file
    autoload +X $fn_name
    typeset fn_file=$functions_source[$fn_name]
    if [[ -z $fn_file ]]; then
        error -1 'Cannot read source file for function ${fn_name}.'
    fi
    
    # Execute the command
    ${0}_${cmd} $fn_name $argv
    return $?
)}
