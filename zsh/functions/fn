#!/bin/zsh

#  fn
#  Z-Function
#
#  Created by mpuchkov on 2020-03-12.
#  Copyright Â© 2020 Maxim Puchkov. All rights reserved.


# Information about shell functions.
#
# Options:
## fn -h,--help: show help ##

# Arguments:
## arg1: vars ##
## arg2: ##
function fn() {
    typeset program_name=$0
    function print-error() {
        local code=-1
        if [[ $1 =~ '-[0-9]' ]]; then
            code=$1
            shift
        fi
        error $code --title $program_name ${argv}
        return $code
    }
    
    ## def: print function definition ##
    function fn_def() {
        local label="function %U%B${fn_name}%b%u () {"
        local def="$(functions $fn_name | highlight | tail -n +2 )"
        printf '%s\n%s\n' "${(%)label}" "$def"
        return $?
    }
    ## src: find function source file ##
    function fn_src() {
        local fsource=$functions_source[$fn_name]
        if [[ -z $fsource ]]; then
            print-error -2 'Function definition file for $fn_name was not found.'
        fi
        # Abbreviate directories
        local -a output_flags=('-P')
        if [[ -t 1 ]]; then
            output_flags+=('-D')
        fi
        builtin print $=output_flags -- $fsource
        return 0
    }
    ## show: display function definition and source file ##
    function fn_show() {
        local code=$(fn def $fn_name)
        local file=$(fn_src $fn_name)
        local line=${(%):-"%F{8}${(l:$COLUMNS::-:)}%f"}
        builtin print -f '%s\n%s\n%s\n\nFile: %s\n' "$line" "$code" "$line" "${(D)file}"
        return 0
    }
    ## open: open function source file ##
    function fn_open() {
        local file=$(fn_src $fn_name 2>/dev/null)
        if [[ ! -r $file ]]; then
            print-error -1 'Cannot read source file for function $fn_name.'
        fi
        /usr/bin/open -a Xcode -- $file
        return 0
    }
    ## isdef: check if a function is defined ##
    function fn_isdef() {
        if [[ ${+functions[$fn_name]} -ne 1 ]]; then
            return 1
        fi
        return 0
    }
    ## sub: list functions defined within a function ##
    function fn_sub() {
#        fn_prefix="${fn_prefix:-${fn_name%%[_-]*}}"
        typeset srcfile
        if ! srcfile=$( fn_src $fn_name ); then
            return 1
        fi
        typeset fn_syntax fn_pattern
        fn_syntax="${fn_prefix}_((?:\w|-)+)"
        fn_pattern="^[^#]*(function\s+${fn_syntax}|${fn_syntax}\s*\(\))\s*"
        typeset -a list
        list=($( egrep -o -i -E "${fn_pattern}" -- $srcfile ))
        list=(${${list#'function'*}%*'()'})
        typeset f
        for f in $list; do
            typeset subfn_name=${f%'('*')'}
            if [[ ${+functions[$subfn_name]} ]]; then
                printf '%s\n' "$subfn_name"
            fi
        done
        return 0
    }
    ## commands: list function commands ##
    function fn_commands() {
#        fn_prefix="${fn_prefix:-${fn_name%%_*}}"
        typeset -a fcommands=(${$(fn_sub $fn_name)//${fn_prefix}_/})
        printf '%s\n' $fcommands
        return 0
    }
    ## print-commands: format and list function commands ##
    function fn_print-commands() {
#        fn_prefix="${fn_prefix:-${fn_name%%_*}}"
        typeset -a commands
        commands=($(fn_commands $fn_name))
#        print -- "fn commands is: ${functions[fn_commands]}";
#        fn_commands fn >~/var/cfn
#        fn_prefix='zfc' fn_commands zfc >~/var/czfc
#        fn_prefix='error' fn_commands error >~/var/cerror
        if [[ -z $commands ]]; then
#            error -1 "Function '\$fn_name' does not have any commands."
            return 1
        fi
        if [[ -t 1 ]]; then
            print -P -- "%B%U${fn_name} commands%u%b:"
            print -Pl -X2 -- '%F{4}\t'${^commands}'%f'
        else
            print -Pl -- ${commands}
        fi
        return 0
    }
    ## options: list function flags and options ##
    function fn_options() {
        typeset srcfile
        if ! srcfile=$(fn_src $fn_name); then
            return 1
        fi
        typeset grep_pattern='^[ ]*##[ ]*[\-\+][^ ]+: .* ##[ ]*$'
        typeset sed_pattern='s/## ([\-\+].*): (.*) ##/\1: \2/p'
        typeset -A reply
        reply=("${(@f)$(grep -E $grep_pattern $srcfile |
            sed -n -E $sed_pattern |
            awk -F ': ' '{print $1; print $2;}' )}")
        # Print completion for arguments
        local k v
        for k v in ${(kv)reply}; do
            if [[ $k =~ '[,]' ]]; then
                k="{$k}"
            fi
            printf '\t%s"[%s]" \\\\\n' "$k" "$v"
        done
    }
    
    
    # Completion for flags and options
    function fn_completion-arguments() {
        typeset file
        if ! file=$(fn_src $fn_name); then
            return 1
        fi
        typeset -A reply
        typeset grep_pattern='^[ ]*##[ ]* (.+) [-+][^ ]+[^:]*: .* ##[ ]*$'
        typeset sed_pattern='s/## (.+) ([-+][^ ]+)[^:]*: (.+) ##/\2: \3/p'
        reply=("${(@f)$(grep -E $grep_pattern $file |
            sed -n -E $sed_pattern |
            awk -F ': ' '{print $1; print $2;}' )}") 2>/dev/null
        if [[ $? -ne 0 ]]; then
            print-error -1 'Parse error'
        fi
        # Print completion for arguments
        local k v
        for k in ${(ok)reply}; do
            v=${reply[(k)$k]}
            if [[ $k =~ '[,]' ]]; then
                k='{'${k// /}'}'
            fi
            printf '\t%s"[%s]"\n' "$k" "$v"
        done
        return 0
    }
    
    # Completion for commands
    function fn_completion-commands() {
        typeset file
        if ! file=$(fn_src $fn_name); then
            return 1
        fi
        typeset -A reply
        typeset -a fn_commands=($(fn commands ${file:t}))
        # Parse commands
        local cmd
        for cmd in ${fn_commands}; do
            local pattern="## ${cmd}: .+ ##.*function ${fn_name}[\-\_]${cmd}[\s]*\(\)"
            local description=$(
                greps '-o' "$pattern" "$file" |
                    head -n 1 |
                    sed -e "s/## ${cmd}: //g" -e "s/ ##.*//g"
            )
            reply[$cmd]="${description:-''}"
        done
        
        # Print command completion
        local k v
        for k in ${(ok)reply}; do
            v=${reply[(k)$k]}
            printf '\t%s:"%s"\n' "$k" "$v" | colrm
        done
        return 0
    }
    
    #MARK: - Z-Shell Function Completion
    ## completion: generate function command completion ##
    function fn_completion() {
        # Find files starting with the specified 'fn_name'
        typeset -a cmd_completion=()
        typeset -a arg_completion=()
        # Parse each file and generate argument/command completion
        typeset fn_dir file
        fn_dir="${$(fn_src $fn_name):h}"
        for file in ${fn_dir}/${fn_name}*; do
            autoload +X ${file:t}
            arg_completion=(${(@f)"$(fn_completion-arguments $file)"})
            cmd_completion=(${(@f)"$(fn_completion-commands $file)"})
        done
        
        
cat <<EOF
#compdef ${fn_name}

# _${fn_name}
# ${(D)fn_dir}/${fn_name}
#
# zsh function completion
# $(date -j +'Updated on %F at %I:%M %p')


_arguments -C \\$(if [[ -n $arg_completion ]]; then
  builtin print -x2 -- '\n' ${^arg_completion}' \\\n'
fi)
  ":command:->command" \\
  "*::arg:->arg"

case \$state in
  (command)
    typeset -a commands
    commands=(
$(if [[ -n $cmd_completion ]]; then
  builtin print -x6 -l -- ${cmd_completion}
fi)
    )
    _describe -t commands command commands
  ;;
  (arg)
    typeset -a args
    args=(
      # Completion for commands' arguments
    )
    _describe -t args arg args
  ;;
esac

return 0
EOF
        
        
        return 0
    }
    
    
    ## compgen: generate and update function completion ##
    function fn_compgen() {
        function completion_function() {
            awk '/_arguments/,/exit;/  {print $0}' <$1
        }
        () {
            # Set target file path
            typeset target=$zdot/completions/_$fn_name
            # Compare old and new completion functions
            diff -s -q -- =(completion_function $target) \
                          =(completion_function $1)      \
                          &>/dev/null
            # Stop if the files are identical
            if [[ $? -eq 0 ]]; then
                print-error -2 'Function completion is already up-to-date.'
                return 2
            fi
            
            # If completion already exists, ask to overwrite it
            if [[ -e $target ]]; then
                typeset -i target_size new_size
                target_size=$(stat -f '%z' -- $target)
                new_size=$(stat -f '%z' -- $1)
                print -P -- "%F{1}%BWarning\!%b%f"
                print -P -- "Target file '%F{2}${target}%f' already exists."
                print -P -- "Overwrite '%F{2}${target}%f' (%F{2}${target_size}%f bytes) with updated completion file (%F{2}${new_size}%f bytes)? (yes/no)"
                # Read user response if overwrite is not enabled with option '-y'
                [[ -z $response ]] && read response
                if [[ ! $response =~ "${langinfo[YESEXPR]}" ]]; then
                    print-error -1 'User response: no. Aborting...'
                    return 1
                fi
                print -P -- "Overwriting completion function..."
                unset response
            fi
            cat <$1 >$target
            print -P -- "Completion function %F{2}_${fn_name}%f updated."
        } =(fn completion $fn_name)
        return 0
    }
    
    
    
    
    
    
    #MARK: - Options
    autoload -Uz get-arguments
    typeset -A optlist
    get-arguments -A optlist \
                  --flags 'h' 'y' \
                  -- $argv
    
    typeset show_help
    show_help=${optlist[-h]}                        # -h
    typeset response
#    fn_prefix=${optlist[-p]:-${fn_name%%[_-]*}}   # -p <prefix>
#    if [[ ${optlist[-y]} -eq 1 ]]; then
#        response='yes'
#    fi
    
    # Show help message
    if [[ $show_help -eq 1 ]]; then
        ${0}_print-commands $0
        return 0
    fi
    
    # Check argument count
    case $# in
        0)  warning 'Command needs arguments.'
            ${0}_print-commands $0
            return 2 ;;
        1)  print-error -2 'Function name is not specified.'
            return 2 ;;
    esac

    
    # Command name
    typeset cmd=$1
    shift
    # Command argument
    typeset fn_name="${argv}"
    # Function name prefix
    [[ -n $fn_prefix ]] || fn_prefix=${fn_name%%[_-]*}
    export fn_prefix
    
    
    if [[ ${+functions[${0}_${cmd}]} -ne 1 ]]; then
        print-error -127 "Unknown command: '\$cmd'."
    fi
    
    
    if [[ $cmd == 'isdef' ]]; then
        ${0}_${cmd} $fn_name
        return $?
    fi

    # Return if function is not defined
    if [[ ${+functions[$fn_name]} -eq 0 ]]; then
        print-error -1 "Function '\$fn_name' is not defined."
    fi
    
    # Execute the command
    autoload +X $fn_name
    ${0}_${cmd} $fn_name
    local -i cmd_status=$?
    if [[ $cmd_status -ne 0 ]]; then
        local cmd_text="$0 $cmd $fn_name"
#        print-error -$cmd_status -c "While executing \$cmd, an error code \$cmd_status \$cmd code: \$cmd_status."
        print-error -$cmd_status -c -- \
            '\$cmd: command failed to complete (error code \$cmd_status).'
        #"\n"
        
 #       "Executed command: '\$cmd_text'."
    fi
    
    unset fn_prefix
    return 0
}
