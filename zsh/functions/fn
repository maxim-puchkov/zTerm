#!/bin/zsh

#  fn
#  Z-Function
#
#  Created by mpuchkov on 2020-03-12.
#  Copyright Â© 2020 Maxim Puchkov. All rights reserved.


# Information about shell functions.
#
# Options:
## fn -h,--help: show help ##
function fn() (
    ## def: print function definition ##
    function fn_def() {
        local label="function %U%B${fn_name}%b%u () {"
        local def="$(functions $fn_name | highlight | tail -n +2 )"
        printf '%s\n%s\n' "${(%)label}" "$def"
        return $?
    }
    ## src: find function source file ##
    function fn_src() {
        local fsource=$functions_source[$fn_name]
        if [[ -z $fsource ]]; then
            error -1 'Function definition file for $fn_name was not found.'
            return 1
        fi
        # Abbreviate directories
        local -a output_flags=('-P')
        if [[ -t 1 ]]; then
            output_flags+=('-D')
        fi
        builtin print $=output_flags -- $fsource
        return 0
    }
    ## show: display function definition and source file ##
    function fn_show() {
        local code=$(fn def $fn_name)
        local file=$(fn src $fn_name)
        local line=${(%):-"%F{8}${(l:$COLUMNS::-:)}%f"}
        print -f '%s\n%s\n%s\n\nFile: %s\n' "$line" "$code" "$line" "${(D)file}"
#        print -f '%s\n\n' "$code"
#        print -Pf 'File: %s\n' "%U${(D)file}%u"
        return 0
    }
    ## open: open function source file ##
    function fn_open() {
        local file=$(fn src $fn_name 2>/dev/null)
        if [[ ! -r $file ]]; then
            error -1 'Cannot read source file for function $fn_name.'
        fi
        open -a Xcode $file
        return 0
    }
    
    ## isdef: check if a function is defined ##
    function fn_isdef() {
        if [[ ${+functions[$fn_name]} -ne 1 ]]; then
            return 1
        fi
        return 0
    }
    ## sub: list functions defined within a function ##
    function fn_sub() {
        name_prefix="${name_prefix:-${fn_name%%[_-]*}}"
        typeset srcfile
        if ! srcfile=$( fn src $fn_name ); then
            return 1
        fi
        typeset fn_syntax fn_pattern
        fn_syntax="${name_prefix}_((?:\w|-)+)"
        fn_pattern="^[^#]*(function\s+${fn_syntax}|${fn_syntax}\s*\(\))\s*"
        typeset -a list
        list=($( egrep -o -i -E "${fn_pattern}" -- $srcfile ))
        list=(${${list#'function'*}%*'()'})
        typeset f
        for f in $list; do
            typeset subfn_name=${f%'('*')'}
            if [[ ${+functions[$subfn_name]} ]]; then
                printf '%s\n' "$subfn_name"
            fi
        done
        return 0
    }
    ## commands: list function commands ##
    function fn_commands() {
        name_prefix="${name_prefix:-${fn_name%%_*}}"
        typeset -a fcommands=(${$( fn -p $name_prefix sub $fn_name )//${name_prefix}_/})
        printf '%s\n' $fcommands
        return 0
    }
    ## print-commands: format and list function commands ## [Function]
    function fn_print-commands() {
        name_prefix="${name_prefix:-${fn_name%%_*}}"
        print_h1 "%U${fn_name}%u commands:"
        print -P -l -- "%F{14}$( fn -p $name_prefix commands $fn_name )%f"
        return 0
    }
    ## options: list function flags and options ##
    function fn_options() {
        typeset srcfile
        if ! srcfile=$( fn src $fn_name ); then
            return 1
        fi
        typeset grep_pattern='^[ ]*##[ ]*-[^ ]+: .* ##[ ]*$'
        typeset sed_pattern='s/## ([-].*): (.*) ##/\1: \2/p'
        typeset -A reply
        reply=("${(@f)$(grep -E $grep_pattern $srcfile |
            sed -n -E $sed_pattern |
            awk -F ': ' '{print $1; print $2;}' )}")
        # Print completion for arguments
        local k v
        for k v in ${(kv)reply}; do
            if [[ $k =~ '[,]' ]]; then
                k="{$k}"
            fi
            printf '\t%s"[%s]" \\\\\n' "$k" "$v"
        done
    }
#    function fn_options() {
#        name_prefix="${name_prefix:-${fn_name%%_*}}"
#        typeset srcfile
#        if ! srcfile=$( fn src $fn_name ); then
#            return 1
#        fi
##        typeset -a list
##        list=($( egrep --only-matching \
##                       --ignore-case \
##                       --regexp "^[ ]*## -[^ ,]+(,[^ ,]+)? ##" -- \
##                       $srcfile ))
##        typeset -A reply
#        typeset grep_pattern='^[ ]*##[ ]*-[^ ]+: .* ##[ ]*$'
#        typeset sed_pattern='s/## ([-].*): (.*) ##/\1 "\2"/p'
#        typeset -a reply
#        reply=("${(@f)$(grep -E $grep_pattern $srcfile |
#            sed -n -E $sed_pattern)}")
##        grep -E $grep_pattern $zfunc/fn |
##            sed -n -E $sed_pattern
#
##        print-var list
##        awk -F '## | ##|: ' '/## -.*: .* ##/ { print "2={"$2"}"; }' $srcfile
##        typeset f
##        for f in $list; do
##            typeset subfn_name=${f%'('*')'}
##            if [[ ${+functions[$subfn_name]} ]]; then
##                printf '%s\n' "$subfn_name"
##            fi
##        done
#        return 0
#    }
#
    
    
    
#    # Completion for commands
#    function fn_commands_completion() {
#        typeset -a arg
#        while read -t -E -A arg; do
#            S $arg
#
#            blue
#
#
#        done
#
#
#        typeset -A reply
#        typeset file=$1
#        typeset -a fn_commands=($(fn -p ${file:t} commands ${file:t}))
#        # Parse commands
#        for cmd in $fn_commands; do
#            local pattern="## ${cmd}: .+ ##.*function ${fn_name}[\-\_]${cmd}[\s]*\(\)"
#            local description=$(
#                greps '-o' "$pattern" "$file" |
#                    head -n 1 |
#                    sed -e "s/## ${cmd}: //g" -e "s/ ##.*//g"
#            )
#            reply[$cmd]="${description:-''}"
#        done
#        # Print command completion
#        for k v in ${(kv)reply}; do
#            printf '\t%s:"%s"\n' "$k" "$v" | colrm
#        done
#    }
    
    
    
    
    #MARK: - Z-Shell Function Completion
    ## completion: generate function command completion ##
    function fn_completion() {
        # Completion for flags and options
        function completion_arguments() {
            typeset file=$1
            typeset -A reply
            typeset grep_pattern='^[ ]*##[ ]* (.+) -[^ ]+: .* ##[ ]*$'
            typeset sed_pattern='s/## (.+) ([-].+): (.+) ##/\2: \3/p'
            reply=("${(@f)$(grep -E $grep_pattern $file |
                sed -n -E $sed_pattern |
                awk -F ': ' '{print $1; print $2;}' )}") 2>/dev/null
            if [[ $? -ne 0 ]]; then
                error -1 'Parse error'
            fi
            # Print completion for arguments
            local k v
            for k v in ${(kv)reply}; do
                if [[ $k =~ '[,]' ]]; then
                    k="{$k}"
                fi
                printf '\t%s"[%s]"\n' "$k" "$v"
            done
        }
        
        # Completion for commands
        function completion_commands() {
            typeset file=$1
            typeset -A reply
            typeset -a fn_commands=($(fn -p ${file:t} commands ${file:t}))
            # Parse commands
            local cmd
            for cmd in $fn_commands; do
                local pattern="## ${cmd}: .+ ##.*function ${fn_name}[\-\_]${cmd}[\s]*\(\)"
                local description=$(
                    greps '-o' "$pattern" "$file" |
                        head -n 1 |
                        sed -e "s/## ${cmd}: //g" -e "s/ ##.*//g"
                )
                reply[$cmd]="${description:-''}"
            done
            # Print command completion
            local k v
            for k v in ${(kv)reply}; do
                printf '\t%s:"%s"\n' "$k" "$v" | colrm
            done
            return 0
        }
        # Find files starting with the specified 'fn_name'
        typeset -a cmd_completion=()
        typeset -a arg_completion=()
        # Parse each file and generate argument/command completion
        typeset fn_dir file
        fn_dir="${$(fn src $fn_name):h}"
        for file in ${fn_dir}/${fn_name}*; do
            autoload +X ${file:t}
            arg_completion=(${(@f)"$(completion_arguments $file)"})
            cmd_completion=(${(@f)"$(completion_commands $file)"})
        done
        
cat <<EOF
#compdef ${fn_name}

# _${fn_name}
# ${(D)fn_dir}/${fn_name}
#
# zsh function completion
# $(date -j +'Updated on %F at %I:%M %p')


_arguments -C \\$( if [[ -n $arg_completion ]] print -x2 -- '\n' ${^arg_completion}' \\\n' )
  ":command:->command" \\
  "*::arg:->arg"

case \$state in
  (command)
    typeset -a commands
    commands=(
$( if [[ -n $cmd_completion ]] print -x6 -l -- ${cmd_completion} )
    )
    _describe -t commands command commands
  ;;
  (arg)
    typeset -a args
    args=(
      # Completion for commands' arguments
    )
    _describe -t args arg args
  ;;
esac

return 0
EOF
        
        return 0
    }
    
    # Options
    typeset -A optlist
    get_options optlist 'hp:P' "$@" 2>/dev/null
    shift $optlist[length]
    
    typeset show_help name_prefix
    show_help=${optlist[h]}     # -h
    name_prefix=${optlist[p]}   # -p <prefix>
    
    if [[ -n $show_help ]]; then
        fn print-commands $0
        zfc list --short
        return 0
    fi

    case $# in
        0) fn print-commands $0
           return 2 ;;
        1) error 'Function name is not specified.'
           return 2 ;;
    esac
    
    # fn command argument
    typeset cmd=$1
    shift
    if ! ( functions + | grep -w -e "fn[-_]$cmd" &>/dev/null ); then
        error "Unknown command: %F{1}$cmd%f."
        return 127
    fi
    
    typeset fn_name="$@"
    if [[ $cmd == 'isdef' ]]; then
        ${0}_${cmd} $fn_name
        return $?
    fi
    
    # Return if function is not defined
    if [[ ${+functions[$fn_name]} -eq 0 ]]; then
        error "Function %F{1}$fn_name%f is not defined."
        return 1
    fi
    
    # Execute the command
    autoload +X $fn_name
    ${0}_${cmd} $fn_name
    if [[ $? -ne 0 ]]; then
        local cmd_text="$0 $cmd $fn_name"
        error -1 'Command error: $cmd_text.'
    fi
    return 0
)
