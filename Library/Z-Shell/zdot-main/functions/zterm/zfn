#!/bin/zsh

#  zfn
#  zTerm (id: 179)
#
#  Generated by 'ztemplate' (zterm/zsh/functions) on 2020-10-19
#  Copyright © 2020 Maxim Puchkov. All rights reserved.


# zfn
#
# Create, edit, show, and complete
# zsh autoload functions.
#
# Usage:
# zfn [ -Z dir ] [ -d dir ] [ -[iow] ] <command> name[...] [<args...>]
#
# Commands:
# - make, makecomp
# - show, print
# - where, open, rename
# - <#...#>
#
# zfn <command> name [<args>]
emulate -LR zsh
setopt extendedglob

autoload -Uz error pipeset ztemplate
autoload -Uz spectrum && spectrum -dz

typeset PROG="${0##*/}"




#MARK: - Function options
# @define option
# @define command   1
# @define arg       *: :_zfn_functions
#
# @option       -Z <dir>
# +description  Set root autoload function directory.
# +completion   :dir:_files -/ -W $ZDOTDIR/..
#
# @option       -d <dir>
# +description  Set function subdirectory relative to the root directory.
# +completion   :subdir:( $ZDOTDIR/{functions,completions}/**(/\:t) )
#
# @option       -w
# +description  Write 'ztemplate' files to output path.
#
# @option       -o
# +description  Open function source file if it exists or if it will be created.
#
#!!!: @option       -i
#: +description  Ignore cached files.
local -AU opts
opts=( [-Z]="$ZDOTDIR" )
local -aU specs
specs=( ${(k)^opts#-}':' 'd:' 'w' 'o' 'i' )
if [[ $# -gt 0 ]] &&
   {! zparseopts -D -E -F -K -M -A opts - $specs}; then
  return 1
fi




# ZFN-AWK environment.
export ZFN_DELIMITER=":%:"
export -aUT ZFN_METACHARS metachars=('@' '+')
export -aUT ZFN_TAGWORDS tagwords=('description' 'completion')


# ZFN function directories.
local ROOT_DIR="${opts[-Z]}"
local FDIR="$ROOT_DIR/functions"
local CDIR="$ROOT_DIR/completions"

# ZFN files.
local zfn_dir="$FDIR/zterm"
local zfn_log_file="$ZTERMDIR/var/log/functions.log"


# ZTEMPLATE options and text macros.
local -A zt_options
local -A zt_macros
zt_macros=([--generator]="'${0%%_*}'")








#MARK: - Private Functions
# Unset all zfn functions and
# exported variables on exit.
function __zfn_exit() {
  unset -f -m "(__)#zfn*?"
  unset -m 'ZFN_*'
  return 0
}
trap __zfn_exit EXIT  #MARK: EXIT trap


# Warn that new files are not written to the
# output path unless '-w' option is set.
function __zfn_require_write_permission() {
  local option_name='-w'
  printf "$fg[4]%s$fg[-]: cannot make functcion '$fg[1]%s$fg[-]' if '$fg[4]%s$fg[-]' is not set\n" \
         "$PROG" "$function_name" "$option_name" >&2
  return 0
}


# Log date and time when an autoload or completion function is created.
function __zfn_log() {
  builtin strftime "%v at %T%t${argv}" >>$zfn_log_file
  return 0
}









#MARK: Completion Functions
# @command      tags
# +description  Parse function source file to generate completion tags.
function zfn_tags() {
  # Outputs:
  #:  @define[ ]^option[ ]
  #:  @option[ ]-o[ ]description[ ]completion[ ]
  #:  ...
  # Symbol '^' replaces '@'. Delimiter is shown with [ ].
  #TODO: -
  if [[ ${opts[-i]} -eq 1 ]]; then
    
  fi
  local program="$zfn_dir/${0}.awk"
  /usr/bin/awk      \
      -f "$program" \
      -v v_prefix="${function_name}_" \
         ${argv[@]} \
      $function_file
  #TODO: - Cache output
}


# @command      complete
# +description  Parse completion tags to generate completion function.
function zfn_complete() {
  # Pipe 'tags' into 'complete' to generate completion function.
  # Outputs:
  #:  _arguments '(-o --option)'{-o,--option}'[desc]action' 'n: :->cmd'...
  #:  case $state in (cmd) local -a cmds=(...); _describe -t cmds 'cmd' cmds;;... esac
  #:  ...
  local program="$zfn_dir/${0}.awk"
  zfn tags "$function_name" |
  /usr/bin/awk ${argv[@]} -f "$program"
}


# @command      help
# +description  Parse completion tags to list available function commands.
function zfn_help() {
  local program="$zfn_dir/${0}.awk"
  zfn tags "$function_name" |
  /usr/bin/awk \
    -F "$ZFN_DELIMITER" \
    -f "$program"
  #TODO: - Set 'options' and 'commands' arrays
  
  #TODO: - Print function options and commands
}









#MARK: - Display Functions
# @command      isdef
# +description  Check if autoload function is defined (loaded).
function zfn_isdef() {
  set -- $function_name $argv
  local reply name
  local -i return_code=0
  for name; do
    
    if [[ ${+functions[$name]} -eq 0 ]]; then
      # Not function (2).
      reply="$fg[1]not a function"
      let return_code=2
    else
      # Function, check if defined.
      builtin functions $function_name                        |
      /usr/bin/sed -n -e '/^[[:blank:]]*# undefined$/{n; p;}' |
      /usr/bin/grep -F -q -e 'builtin autoload -X'
      
      if [[ $? -eq 0 ]]; then
        # Function, not defined (1).
        reply="an $fg[3]undefined autoload function"
        let return_code=1
      else
        # Function, defined (0).
        reply="a $fg[2]defined function"
        let return_code=0
      fi
    fi
    
    # Print reply message.
    if [[ "$subcommand" == "${0##${PROG}_}" ]]; then
      printf "$fg[4]%s$fg[-]: %s is %s$fg[–]\n" \
             "$PROG" "$name" "$reply"
    fi
  done
  return $return_code
}


# @command isrec
# +description Check if the function is called recursively.
function zfn_isrec() {
  local -i call_count
  let call_count="${(M)#funcstack#$function_name}"
  return "$call_count == 0"
}


# @command       show
# +description   Show function source code.
function zfn_show() {
  local file
  for file in $matching_files; do
    highlight $file 2>/dev/null
  done
  return $?
}


# @command      print
# +description  Print unformatted source code.
function zfn_print() {
  local file
  for file in $matching_files; do
    /bin/cat -- "$file"
  done
  return $?
}


# @command      open
# +description  Open function source file in Xcode.
function zfn_open() {
  /usr/bin/open -a Xcode -- $matching_files
  return $?
}


# @command      where
# +description  Print location of the source file.
function zfn_where() {
  local file
  for file in $matching_files; do
    if [[ ! -p /dev/stdout ]] &&
       [[ -t 1 ]]; then
      printf "$fg[6]%s$fg[-]: " "${file:t}"
    fi
    printf '%s\n' "$file"
  done
}


# @command      trace
# +description  Trace function execution.
function zfn_trace() {
  builtin functions -T $function_name
  printf "$fg[1]Trace$fg[-]: %s with arguments $fg[u]%s"
  # Call function with arguments.
  $function_name $argv
  builtin functions +T $function_name
}









#MARK: - Make Functions
# @command      make
# +description  Make a new autoload function.
function zfn_make() {
  # Create a new 'ztemplate' file.
  local -a zt_templates=('zsh' 'file-header' 'function-header' 'options' 'function-commands')
  ztemplate ${(@kv)zt_options} ${(@kv)zt_macros} make '-'${(@)^zt_templates}
  
  if [[ -e $out_path ]]; then
    # Print success message.
    printf "Autoload function created: $fg[2]%s$fg[-]\n" "$out_path"
    # Log created function.
    __zfn_log "$out_path"
    
    # Open file if '-o' is set.
    if [[ ${+opts[-o]} -eq 1 ]]; then
      /usr/bin/open -a Xcode -- $out_path
    fi
    return 0
  fi
  return 1
}


# @command      makecomp
# +description  Make a new completion function.
function zfn_makecomp() {
  # Create a new 'ztemplate' file.
  local -a zt_templates=('completion')
  ztemplate ${(@kv)zt_options} ${(@kv)zt_macros} make '-'${(@)^zt_templates}
  
  if [[ -e $out_path ]]; then
    # Write completion function to file.
    printf 'builtin eval "$(autoload -Uz %s && %s complete %s)"\n' \
            "$PROG" "$PROG" "$function_name" >>$out_path
    # Print success message.
    printf "Completion function created: $fg[2]%s$fg[-]\n" "$out_path"
    # Log created function.
    __zfn_log "$out_path"
    
    # Open file if '-o' is set.
    if [[ ${+opts[-o]} -eq 1 ]]; then
      /usr/bin/open -a Xcode -- $out_path
    fi
    return 0
  fi
  return 1
}


# @command      rename
# +description  Rename a function.
function zfn_rename() {
  # Get new name.
  local new_name=$1
  if [[ -z "$new_name" ]]; then
    error -1 -m 'new function name is not specified'
  fi
  # Set old and new file names.
  local renamed
  if [[ ! -f "$function_file" ]]; then
    error -1 -m 'cannot rename ${function_name} - source file not found'
  fi
  renamed="${function_file:h}/${new_name}"
  
  # Rename function file and replace all occurrences
  # of previous name with new function name.
  /bin/mv -i -- $function_file $renamed &&
  /usr/bin/sed -I "" -e "s/${function_file:t}/${renamed:t}/" -- $renamed &&
  printf "$fg[4]%s$fg[-]: Function renamed: $fg[1]%s$fg[-] --> $fg[2]%s$fg[-]\n"
         "$PROG" "${function_file:t}" "${renamed:t}" &&
  __zfn_log "${function_file} --> ${renamed:t}"
  
  # Open file if '-o' is set.
  if [[ ${+opts[-o]} -eq 1 ]]; then
    /usr/bin/open -a Xcode -- $renamed
  fi
  return 0
}








#MARK: - Positional Arguments
# Verify argument count.
#case $# in
#  (0) zfn help "$PROG" && return 2 ;;
#  (1) error -1 -m 'not enough arguments' ;;
#esac

if [[ $# -eq 0 ]]; then
  error -1 -m 'no command'
fi

# Set zfn subcommand ($1).
local subcommand=$1
if [[ ${+functions[${PROG}_${subcommand}]} -eq 0 ]]; then
  error -127 -m '${subcommand} is not a command'
fi
shift

# Set function name ($2).
local function_name="${1##*/}"
if [[ -z "$function_name" ]]; then
  error -1 -m 'function name is not specified'
fi
shift










# Set initial output path for commands.
local out_path
case $subcommand in
  # Completion commands.
  (tags|complete|makecomp) out_path="$CDIR" ;;
  # Autoload function commands.
  (*) out_path="$FDIR" ;;
esac

# Set output subdirectory with: -d <dir>.
if [[ ${+opts[-d]} -eq 1 ]]; then
  out_path+="/${opts[-d]}"
fi

# Check that output directory exists.
if [[ ! -d $out_path ]]; then
  error -1 -m 'invalid function subdirectory: ${out_path}'
fi









# Set function file to the file path stored in 'functions_source[]'
local function_file
function_file=${functions_source[$function_name]}

# Set list of all files in fpath that match function name.
local -aU matching_files
matching_files=($function_file)


# Verify function name or extend list of matching
# files, depending on the subcommand.
case $subcommand in
  # zfn make
  (make)     out_path+="/$function_name"       ;|
  (makecomp) out_path+="/_$function_name"      ;|
  (make|makecomp)
    # Check that function file does not exist.
    if [[ -e $out_path ]]; then
      # Open file if '-o' is set.
      if [[ ${+opts[-o]} -eq 1 ]]; then
        /usr/bin/open -a Xcode -- $out_path
        return 0
      fi
      error -1 -m 'file already exists: ${out_path}'
    fi
    
    # If '-w' is set, write template to output path.
    if [[ ${+opts[-w]} -eq 1 ]]; then
      zt_options=([--out]="$out_path")
    else
      __zfn_require_write_permission
    fi
  ;;
  
  
  # Display commands allow function name to be a pattern.
  (open|where|print|show)
    local -a search_paths
    search_paths=($fpath)
    if [[ ${+opts[-d]} -eq 1 ]]; then
      search_paths=($out_path)
    else
      search_paths=($fpath)
    fi
    # Find all files that match 'function_name' and
    # add them to 'matching_files[]'.
    /usr/bin/find --               \
        $search_paths              \
        -name "${~function_name}"  \
        -type f                    \
        -mindepth 1 -maxdepth 1    \
        2>/dev/null |
    pipeset -aU matching_files
    
    # Check that there is at least one matching source file.
    if [[ ${#matching_files} -eq 0 ]]; then
      error -1 -m 'function not found: ${function_name}'
    fi
  ;;
  
  
  # Other commands require function name must refer to an existing function.
  (*)
    # Check that 'function_name' is a function.
    if [[ ${+functions[$function_name]} -eq 0 ]]; then
      error -1 -m '${function_name} is not a function'
    fi
    # If autoload function 'function_name' is undefined, load it.
#    zfn_isdef $function_name
#    if [[ $? -eq 1 ]]; then
#      autoload +X -- $function_name
#    fi
  ;;
esac




# Invoke subcommand with arguments.
${PROG}_${subcommand} ${argv}
return $?
