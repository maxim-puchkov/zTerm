#!/bin/zsh

#  prex
#  zTerm (id: 128)
#  @zfn
#
#  Generated by 'zfn' on 2020-11-03
#  Copyright Â© 2020 Maxim Puchkov. All rights reserved.


# prex
#
# Add and remove preexec functions.
#
# Usage:
# prex [-q]
#   add <name>
#   rm <name>
#   ls [<name>]
#   count [<name>]
emulate -LR zsh
typeset PROG="${0##*/}"




#MARK: - Options
# @define option
# @define command 1
# @define args *: :_functions
# @annotation command @cmd
# @annotation option  @opt
#
# @opt -q,--quiet: Supress normal output.
local -A opts
local -a specs=('q' '-quiet=q')
if [[ $# -gt 0 ]] &&
   {! zparseopts -D -E -F -K -M -A opts - $specs}; then
  return 1
fi


# Quiet output if '-q' is set.
local print='print'
if [[ ${+opts[-q]} -eq 1 ]]; then
  print=":"
fi







#MARK: - Commands
# @cmd ls: List preexec functions.
function prex_ls() {
  local -a list=(${(@M)preexec_functions:#${~fn}*})
  if [[ ${#list} -eq 0 ]]; then
    error -1 -m 'preexec functions not found: ${fn}'
  fi
  # Print list of matching functions.
  $print -nr -aC1 -- "${list[@]}"
  return 0
}


# @cmd count: Print number of preexec functions.
function prex_count() {
  local -a list=(${(@M)preexec_functions:#${~fn}*})
  if [[ ${#list} -eq 0 ]]; then
    error -1 -m 'preexec functions not found: ${fn}'
  fi
  # Count matching functions.
  local -i count=${#list}
  $print -- "$count"
  return 0
}


# @cmd add: Add preexec function.
function prex_add() {
  if [[ ${preexec_functions[(I)$preexec_fn]} -ne 0 ]]; then
    error -1 -m 'function is already preexec: ${preexec_fn}'
  fi
  # Add function and print its name.
  $print -P -- "%F{green}+ $preexec_fn%f"
  preexec_functions+=($preexec_fn)
  return 0
}


# @cmd rm: Remove preexec function.
function prex_rm() {
  if [[ ${preexec_functions[(I)$preexec_fn]} -eq 0 ]]; then
    error -1 -m 'function is not preexec: ${preexec_fn}'
  fi
  # Remove function and print its name.
  $print -P -- "%F{red}- $preexec_fn%f"
  set -A preexec_functions ${(@)preexec_functions:#$preexec_fn}
  return 0
}









#MARK: - Arguments
if [[ $# -eq 0 ]]; then
  error -1 -m 'not enough arguments'
fi


# PREX subcommand.
local subcommand=$1
if [[ ${+functions[${PROG}_${subcommand}]} -eq 0 ]]; then
  error -1 -m '${subcommand} is not a subcommand'
fi
shift


# Function name.
local fn=$1
shift


# add,rm: Copy 'fn' to 'fn_preexec' if needed.
case $subcommand in
  (add) [[ -z "$fn" ]] && error -1 -m 'function name is not specified'        ;|
  (rm)  [[ -z "$fn" ]] && error -1 -m 'preexec function name is not specifed' ;|
  (add|rm)
    if [[ ${+functions[$fn]} -eq 0 ]]; then
      error -1 -m '${fn} is not a function'
    fi
    # Preexec function name.
    local suffix="_preexec"
    local preexec_fn="${fn%$suffix}${suffix}"
    if [[ ${+functions[$preexec_fn]} -eq 0 ]]; then
      builtin functions -c $fn $preexec_fn ||
      error -1 -e
    fi
  ;;
esac




${PROG}_${subcommand} ${argv}
return 0
