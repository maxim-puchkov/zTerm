#!/bin/zsh

#  zparseopts-generate
#  /usr/local/zterm/zsh/zparseopts-generate (id: 31)
#
#  Generated by 'ztemplate' (zterm/zsh/sources) on 2020-10-10
#  Copyright Â© 2020 Maxim Puchkov. All rights reserved.


#MARK: - zparseopts-generate
# Description:
# `zparseopts-generate' parses options specified
# in association
#
# zparseopts-generate:
# Automatically parse function options with `zparseopts'
# builtin. The keys of the specified associative <array>
# are long option names and the values are default
# option values.
#
# Usage:
# zparseopts-generate [-A <array>] [--short-options]
#        [--custom <o:=-option>] [--ignore <name>] [--] argv
#
#
### Example 1.
# - Association 'opts' maps a function's
#   long option name to the option's value:
#       typeset -A opts
#       opts=([--regexp]=".*" [--max-count]="5" ...)
# - Recognized options are added to the associative array and
#   removed from the positional arguments of the caller.
#       set -- --regexp "new" --max-count 20 --REST a1 a2 a3
#       zparseopts-generate -A opts -- $argv
#       opts:  ([--regexp]="new" [--max-count]="20")
#       argv:  (--REST a1 a2 a3)
#
### Example 2.
# - With '--short-options' option, a short option name is generated
#   for each long option.
#       opts=([--file]="" [--regexp]="" [--context]="")
#       zparseopts-generate -A opts --short-options -- $argv
# - The respective short option names for --file, --regexp,
#   and --context are: -f, -r, and -c.
#
emulate -LR zsh
setopt extendedglob

local -i exit_code=0
local zparseopts_trap='return ${exit_code};'

# Options
local association_id
local -a {,custom_}specs {generated,ignored}_names argument_values
local -i generate_short_names=0
while [[ "$1" =~ ^[-] ]]; do
  case "$1" in
    # -A <association>: specify association in which to store parsed options.
    (-A)
      if [[ -z "$2" ]]; then
        error -1 -m 'option needs a name of an associative array'
      fi
      association_id=$2
      shift ;;
    
    # --short-options: generate specs for short option names.
    (-s|--short-options)
      let generate_short_names=1 ;;
    
    # --custom <o:=-option>: append custom option specs to generated specs.
    (-c|--custom)
      if [[ -z "$2" ]]; then
        error -1 -m 'option needs an argument' \
                 -u 'To map -o to --option, use:; ${0} --custom o:=-option'
      fi
      custom_specs+=(${(s:=:)2})
      shift ;;
    # -f <spec>
    (-f)
      if [[ -z "$2" ]]; then
        error -1 -m 'option needs an argument'
      fi
      custom_specs+=($2)
      shift ;;
    
    # --ignore <--option>: ignore a specific long option when generating short names.
    (-i|--ignore)
      if [[ -z "$2" ]]; then
        error -1 -m 'option needs an argument' \
                 -u 'To ignore --option, use:; ${0} --ignore option'
      fi
      ignored_names+=(--$2)
      shift ;;
    
    (--) shift && break ;;
    (*)  break ;;
  esac
  shift
done
if [[ $# -eq 0 ]]; then
  return 1
fi
if [[ -z "$association_id" ]]; then
  error -1 'association is not specified'
fi


# Generate option specs.
local arg{,spec} {long,short}name
for arg in ${(Pk)association_id}; do
  argspec=":"
  longname="${arg#-}"
  specs+="${longname}${argspec}"
  if [[ $generate_short_names -eq 1 ]] &&
     [[ ${+ignored_names[(r)$arg]} -ne 1 ]]; then
    shortname="${${arg#-##?}[1]}"
    if [[ ${+generated_names[(r)$shortname]} -eq 1 ]]; then
      shortname=${(U)shortname}
    fi
    if [[ ${+generated_names[(r)$shortname]} -eq 1 ]]; then
      continue
    fi
    generated_names+="$shortname"
    specs+="${shortname}${argspec}=${longname}"
  fi
done
# Append custom specs.
if [[ ${#custom_specs} -gt 0 ]]; then
  specs+=($custom_specs)
fi


# Parse argument values given '$specs'.
# Store the result in '$association_id'.
builtin zparseopts -D -E -K -M -A $association_id - $specs
let exit_code=$?
if [[ $exit_code -eq 0 ]]; then
  zparseopts_trap="set -- ${(@q)argv};"
fi
trap "$zparseopts_trap" EXIT


return 0

