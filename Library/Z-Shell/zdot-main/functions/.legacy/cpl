#!/bin/zsh

#  cpl
#  /usr/local/zterm/zsh/functions (id: 39)
#
#  Generated by 'ztemplate_apply' (zterm/zsh/sources) on 2020-10-12
#  Copyright Â© 2020 Maxim Puchkov. All rights reserved.


# cpl
# Make completion for zsh functions.
#
# Usage:
# cpl  <#...#>
emulate -LR zsh



function plist-count() {
  local -A opts
  opts=( [--depth]='0' )
  zparseopts -D -E -K -M -A opts - -depth: d:=-depth
  local plist=${1:?Property list file is not set}
  local object=${2:?Object is not set}
  local depth=${opts[--depth]}
  local indent_1='    '
  local indent=''
  repeat $depth; do indent+="$indent_1"; done
  local pattern="^${indent}${object}"
  
  /usr/libexec/PlistBuddy -c 'print' output.plist |
  grep -e $pattern -c
}


local name=${1:?Function name is not specified.}
local file=${functions_source[$name]}


awk '/##/ {print $0}' $file




#local input=${1:?Input property list is not set.}
#shift
#/usr/bin/plutil -extract 'Options' xml1 -o output.plist -- $input
#plist-count output.plist Dict -d 2
#
#/usr/libexec/PlistBuddy -c 'print ' output.plist |
#/usr/bin/grep -c -e '^    Dict'                  |
#pipeset -i count
#
#
#
#
#
#
#
#
#
#
##compdef "_arguments '(-short --long)'{-short,--long}'[description]: :_completion'" foo
#
#
#() {
#  local compresult=$1
#  local optresult=$2
#  # Parse every dictionary in the array
#  for (( i = 0; i < $count; i++ )); do
#    # Get the i'th dictionary
#    /usr/libexec/PlistBuddy -c "print $i" output.plist |
#    /usr/bin/grep -F '='                               |
#    /usr/bin/sed -e 's/^[[:space:]]*//' -e 's/ = /\n/' |
#    pipeset -A dict
#
#    # Default option argument completion
#    [[ -n "${dict[Argument Completion]}" ]] ||
#    typeset "dict[Argument Completion]"='_default'
#    # Default option description
#    [[ -n "${dict[Description]}" ]] &&
#    typeset "dict[Description]"='['${dict[Description]}']'
#
#
#    # Generate substitution commands
#    local -a compsubs=() optsubs=()
#    local spec="${dict[Specification]:-:}"
#    for k v in ${(kv)dict}; do
#      compsubs+='s/'"${k}"'/'"${v}"'/g'
#      optsubs+='s/'"${k}"'/'"${v#-}${spec}"'/g'
#    done
#    set -A compsubs  '-e '${^compsubs}
#    set -A optsubs   '-e '${^optsubs}
#
#
#    # Generate zsh function completion for options
#    local comp='' specs=''
#    [[ true ]] && comp+="'(Short Name Long Name)'"
#    comp+="{Short Name,Long Name}'Description: :Argument Completion'"
#    print -- "$comp" | sed $compsubs >>$1
#
#    # Generate zparseopts command
#    specs="Long Name\nShort Name=Long Name"
#    print -- "$specs" | sed $optsubs >>$2
#
#  done
#
#
#
#
#
#red 'zparseopts'
#cat <<EOF
## Parse options
#local -a specs=(
#$(print -nr -aC2 -x4 -- $'\t'${(@f)^"$(cat  $optresult)"})
#)
#local -A opts
#builtin zparseopts -D -E -K -M -A opts - \$specs
#
#EOF
#
#
#
#
#
#blue '_arguments'
#cat <<EOF
##compdef ...
#
#
#local -i ret=1
#_arguments -C \\
#$(print -nrC1 -x4 -- $'\t'${(@f)^"$(cat  $compresult)"}" \\")
#    && ret=0
#
#return \$ret
#EOF
#
##  cat $compresult
##  cat $optresult
#} =() =()
