#!/bin/zsh

#  mkfn
#  zTerm (id: 131)
#
#  Generated by 'ztemplate' (zterm/zsh/functions) on 2020-10-17
#  Copyright Â© 2020 Maxim Puchkov. All rights reserved.


# mkfn
#
# Make zsh functions.
#
# Options:
# -a :: Create an autoload function
# -A :: Navigate to autoload function directory
# -d <dir> :: Create autoload function subdirectory
# -D :: List all function directories
# -s <dir> :: Specify function subdirectory for created functions
# -m :: Sort autoload functions by modification time
# -X <width> :: Specify tab width

# Usage:
# `mkfn -A'
# `mkfn -d <dir>'
# `mkfn [-s <dir>] [-a] [-X <tab-width>] function'
emulate -LR zsh
setopt noclobber


# Function options
local -A opts
opts=([-X]='2')
local -a specs
specs=('A' 'a' 'D' 'd:' 's:' 'm')
specs+=(${(k)^opts#-}':')
if [[ $# -gt 0 ]] &&
   {! zparseopts -D -E -K -M -A opts - $specs}; then
  return 1
fi


# Autoload functions' directory.
local functions_dir="$ZDOTDIR/functions"




# `mkfn' will return if any of the following options is set.
case 1 in
  # -d <directory>: Create a new function subdirectory in $ZDOTDIR/functions and return.
  ${+opts[-d]})
    local new_dir="${functions_dir}/${opts[-d]}"
    if /bin/mkdir -- $new_dir; then
      print -P -- "$0: function directory created: %F{2}${new_dir:t}%f"
      return 0
    else
      error -1 -m 'cannot create function directory: ${new_dir}'
    fi ;;
  
  # -D: Show function directories.
  ${+opts[-D]})
    if [[ ${+functions[nf]} -eq 1 ]]; then
      nf -r "$ZDOTDIR/functions"
    else
      /usr/bin/find $ZDOTDIR/functions -type d 2>/dev/null
    fi
    return $? ;;
  
  # -A: Change working directory to root directory of zsh autoload functions.
  ${+opts[-A]})
    print -P "Function directory: %F{6}${functions_dir}%f"
    builtin cd -q $functions_dir &&
    /bin/ls -BFGHhk
    return 0 ;;
  
  # -m: Order and list functions by modification time.
  ${+opts[-m]})
    # Header
    print -P -- "$0: listing functions from oldest (top) to recent modification time (bottom)"
    println -F 12 -L
    # Get all functions and their modification time
    builtin cd -q $functions_dir &&
    /usr/bin/stat -t '%F at %T' -f '%N%n%Sm' **/*(Om) |
    pipeset -a result &&
    builtin cd -q $OLDPWD
    # Print body
    result[1]+=" $(red '(oldest)')"
    result[-2]+=" $(green '(newest)')"
    print -nr -aC2 -- ${result}
    # Footer
    println -F 12 -L
    return 0 ;;
esac



# Check function name.
local name=$1
if [[ -z "$name" ]]; then
  error -1 -m 'function name is not set'
fi
if [[ ${+functions[$name]} -eq 0 ]]; then
  error -1 -m 'function ${name} is not defined'
fi
if [[ ${functions[$name]} =~ '^builtin autoload -X' ]]; then
  error -1 -m '${name} is an autoload function'
fi
if [[ -e ${functions_source[$name]} ]]; then
  error -1 -m 'function ${name} already exists'
fi


# If a subdirectory is specified with '-s', append it.
if [[ ${+opts[-s]} -eq 1 ]]; then
  functions_dir+="${opts[-s]%/}"
fi
# Set output file path.
local outpath
if [[ ${+opts[-a]} -eq 1 ]]; then
  outpath="${functions_dir}/${name}"
fi


# Create function source file.
{ # Write file header.
  local -A text_macros
  text_macros=([--filename]="$name" [--generator]="'$0'")
  local -a templates
  templates=('-zsh' '-file-header' '-function-header')
  ztemplate ${(@kv)text_macros} ${(@)templates}
  
  # Write the function.
  local -i tab_width=${opts[-X]}
  { print -r -X $tab_width -- "${functions[$name]}" |
    /usr/bin/sed -E -e 's/^[[:blank:]]{'$tab_width'}//' }
} |
tee $outpath


# If function is written to file, open the file.
if [[ -e $outpath ]]; then
  print -P -- "$0: new function created: %F{2}${outpath:t}%f"
  /usr/bin/open -a Xcode -- "$outpath"
fi
return 0
