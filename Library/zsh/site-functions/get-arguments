#!/bin/zsh

#  get-arguments
#  Z-Function (46)
#
#  Created by Maxim Puchkov on 2020-06-01.
#  Copyright Â© 2020 Maxim Puchkov. All rights reserved.


# Name:
#   get-arguments
#
# Usage:
#   get-arguments
#     [-[Aa] array_id]
#     [-f name[, ...]]
#     [-o name[, ...]]
#   --
#     args
#
# Description:
#   Parse arguments, store recognized flags
#   and options in an array, and remove
#   them from positional arguments.
#
# Examples:
# 1. Parse options X,Y,Z and store their values in 'optlist':
#       set -- -Z opt-Z -X opt-x -Y opt-y
#       get-arguments -o X Y Z -- $argv
# 2. Parse flags A,B, options C,D, and store result in 'myArray':
#       set --  -C opt-C -A -D opt-D -B
#       typeset -A myArray
#       get-arguments -A myArray -f A B -o C D -- $argv
function get-arguments() {
    # Load 'zsh/zutil' module
    local zsh_module='zsh/zutil'
    if ! zmodload -e $zsh_module; then
        error -1 'Cannot load zsh module: $zsh_module.'
    fi
    
    # Find argument specification and value delimiter
    local delimiter='--'
    local -i delimiter_index=${argv[(i)$delimiter]}
    # Missing '--' argument delimiter
    if [[ $delimiter_index -gt $# ]]; then
        error -1 \
            "Argument %Uspecification%u and argument %Uvalues%u must be delimited with two dashes '\$delimiter':" '\n' \
            "'%B${0}%b %U-f a b c -o x y z%u \$delimiter %U-a -x X -y Y other args%u"
    fi
    # If delimiter '--' is the last argument, there is nothing to parse
    if [[ $delimiter_index -eq $# ]]; then
        return 1
    fi
    
    
    #MARK: - Parameters for 'get-arguments'
    # Names of flags and options
    typeset -aU flag_names option_names
    flag_names=()
    option_names=()
    # Default values
    typeset -A defaults
    defaults=( [opt-unset]="''"
               [flag-set]=1
               [flag-unset]=0 )
    # Result array name and type
    typeset array_{id,type}
    array_id='optlist'
    array_type='-A'
    
    
    
    
    #MARK: - Set 'get-arguments' Options
    # Parse arguments which begin with '-'
    # or '+' (command options)
    while [[ $1 =~ '^[-+]' ]] &&
          [[ $1 != '--' ]]; do
        # Arguments until the next command option
        # are parameters for the current option
        local -a list=()
        let last_index=${${argv:2}[(i)[-+]*]}
        set -A list ${argv[2,$last_index]}
        
        case $1 in
            # Flags
            -f|--flags)
                shift
                flag_names+=($list)
                shift ${#list}
            ;;
            
            # Options
            -o|--opts|--options)
                shift
                local opt_spec=''
                for opt_spec in $list; do
                    case $opt_spec in
                        *:*)
                            name=${opt_spec%:*}
                            value=${opt_spec#*:}
                            defaults+=( [-$name]=$value )
                        ;;
                        *)  name=$opt_spec
                        ;;
                    esac
                    option_names+=($name)
                done
                shift ${#list}
            ;;
            
            # Specify output array name and type
            -A|-a)
                array_type=$1
                array_id=$2
                shift 2
            ;;
            
            # Stop parsing parameters
            *)  break ;;
        esac
    done
    [[ $1 == '--' ]] && shift
    
    
    # Exit if no flag or option names were recognized
    if [[ -z $flag_names ]] &&
       [[ -z $option_names ]]; then
        error -1 'Missing descriptions of flags and/or options.'
    fi
    
    
    
    
    
    #MARK: - Parse Arguments
    # Recognized flags/options
    typeset -a flags
    typeset -A opts
    flags=()
    opts=()
    # Set 'specs' for the 'zparseopts' builtin
    typeset -a specs
    specs=( ${^flag_names}'=flags' ${^option_names}':=opts' )
    
    # Parse parameters
    builtin zparseopts -D -E -- $specs &>/dev/null
    local -i parse_status=$?
    if [[ $parse_status -ne 0 ]] then
        ( name='zparseopts' \
            error -$parse_status -c "Invalid '%U\${name}%u' specs: {\${specs}}." )
    fi
    
    # Recognized options and options with default values
    typeset -a {opts,def}_keys
    opts_keys=(${(k)opts})
    def_keys=(${(Mk)defaults:#-*})
    # Non-recognized flags/options
    typeset -a unset_{flags,opts}
    unset_opts=(${${:-'-'${^option_names}}:|opts_keys})
    unset_flags=(${${:-'-'${^flag_names}}:|flags})
    
    # Set remaining arguments of the caller
    trap '{ set -- '"$argv"'; [[ $1 == "--" ]] && shift; }' EXIT
    
    
    
    
    #MARK: - Result Array
    # Initialize the result array
    typeset -A result
    result=()
    # Append recognized 'flags' to 'result'
    # as (flag_name, 1) pairs
    for name in $flags; do
        result+=( [$name]=$defaults[flag-set] )
    done
    # Append recognized 'opts' to 'result' as
    # (option_name, option_value) pairs
    for name value in ${(kv)opts}; do
        result+=( [$name]=$value )
    done
    
    
    # If an option is not set but has a default value,
    # set option to its default value
    local {default,given}_value
    for name in $def_keys; do
        default_value=${defaults[(k)$name]}
        given_value=${result[(k)$name]}
        if [[ -n $default_value ]] &&
           [[ -z $given_value ]]; then
            result+=( [$name]=$default_value )
        fi
    done
    
    
    # Set the output [associative] array to the
    # (name, value) pairs of result array
    unset $array_id
    typeset $array_type -g $array_id
    set -A $array_id ${(kv)result}
    return 0
}
