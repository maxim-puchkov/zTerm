#!/bin/zsh

#  .zprofile
#  Z shell
#
#  User-specific profile for interactive zsh(1) shells.
#  Created on March 30, 2020.


typeset _repl='\e[32m__REPLACED TEXT (\1)__\e[39m'

alias r101='open -a Safari https://regex101.com'
alias mcat='() { man $1 | col -b; }'
alias mtbl='() { tbl $(man -w $1); } '


#!!!: Keep
function xcopen() {
  open -a Xcode $argv
}

function calculate() {
  print -- "$(( ${argv} ))"
}

function clears() {
  clear && printf "\e[3J"
}

function styles() {
  print -aC2 -nr -- ${(kvq)ZSH_HIGHLIGHT_STYLES} |
  hgrep -E "${argv:=}"
}

#function edits() {
#  local command_name=$1
#  typeset -a files
#  set -A files ${(@f)"$(find -L -- $path $fpath $PWD -name $command_name 2>/dev/null)"}
#  echo $#files
#  case ${#files} in
#    0) error -1 'Command not found: ${command_name}' ;;
#    1) echo open -a Xcode "${files[1]}" ;;
#    *) echo \* ;;
#  esac
#  echo $files
#}





function print-argv() {
  trap 'builtin print -Pf "%s%s argv[%i] = {%s}%s\n" -- "%F{7}" "%U${0}%u" $# "$*" "%f"' EXIT
}








# takef:   Make new executable files.
# version: 1
function takef() {
  # Check input
  if [[ $# -eq 0 ]]; then
    usage "Create and edit executable files" - "$0 file [file...]"
    return 1
  fi
  
  # Create files using parameters below:
  local PROG DESC DATE YEAR
  PROG=${"$(/usr/bin/dscl . read $HOME UserShell)"#UserShell: } # Shebang
  DESC="'${0}' (${functions_source[$0]:t2})" # "Generated by"
  DATE=$(/bin/date -j +'%F') # YYYY-MM-DD
  YEAR=$(/bin/date -j +'%Y') # YYYY
  
  # If a file does not exist, create it
  local file
  for file; do
    if [[ ! -e "$file" ]]; then
      cat <<EOF >"$file"
#!${PROG}

#  ${file}
#
#
#  Generated by ${DESC} on ${DATE}.
#  Copyright Â© ${YEAR} ${USER}. All rights reserved.

EOF
      chmod a+x "$file"
    fi
  done
  
  # Open all files in Xcode
  open -a Xcode -- $argv
  return 0
}




#!!!: Keep
# synopsis:  Print command synopsis.
function synopsis() {
  local name
  local section="${(U)0}"
  for name; do
    if ! (man -W $name &>/dev/null); then
      error -1 'No manual page for ${name}.'
    fi
    man $name |
    col -b |
    awk '
      /^'$section'/, /^$/ {
        gsub(/^([[:blank:]]*|'$section')/, "", $0);
        if (NF > 0) {
          print $0;
        }
      }
    '
  done
  return 0
}
#compdef '_man' synopsis


#!!!: Keep
# highlight-column:   colorize a column
# usage:              `highlight-column [number] [text]'
function highlight-column() {
  local color=${fg[cyan]} default=${fg[default]}
  awk -v column=$1 'sub($column, "'$color'"$column"'$default'", $0);'
}











#???:
function functions_source() {
  local name file
  for name; do
    # Check if name is function
    if [[ ${+functions[$name]} -ne 1 ]]; then
      error -1 '${name} is not function'
    fi
    # Get source file
    file=${functions_source[$name]}
    if [[ -z "$file" ]]; then
      error -1 'cannot find function source for ${name}'
    fi
    # Print path to source file
    print $file
  done
}

#???:
# line-num:   Print specified lines in file.
# usage:     `line-num file number [number...]'
function line-num() {
    local file=$1
    shift
    
    local -a line_numbers=($argv)
    local regex=${(j:|:)line_numbers}
    #S "file = $filename ; ln# = ${(j:,:)line_numbers}"
    
    awk -v lines="${(j:,:)line_numbers}" ' \
    BEGIN { \
      split(lines, line_numbers, ""); \
      for (i=0; i<length(lines); i++) { \
        print i; \
        print "line at "i" = "lines[i]; \
      }\
    } \
    END { \
      \
    }' <$file
}
    
#???: random
# random:   Generate a random number from 'min' to 'max'.
# usage:   `random [-min number] [-max number]'
function random() {
  typeset -A opts
  zparseopts -D -E -A opts - min: max:
  typeset -i min max
  let min=${${opts[-min]}:-0}
  let max=${${opts[-max]}:-100}
  if [[ $max -eq 0 ]]; then
    let max="100"
  fi
  [[ -t 1 ]] && print -Pn -u2 -- "${0}[${min}, ${max}): %F{6}%U"
  print -- "$(( $RANDOM % $max + $min ))"
  [[ -t 1 ]] && print -Pn -u2 -- "%u%f"
}










#!!!: keep
# cplines:   Copy empty lines to pasteboard.
# usage:    `cplines [number]'
function cplines() {
  local -i count=$1
  local newline=$'\n'
  if pbcopy < <(print -n -- "${(pl:$count::$newline:)}"); then
    print -Pf '%s: %s lines copied to pasteboard\n' \
              "%U${0}%u" "%F{2}${count}%f"
    return 0
  else
    return 1
  fi
}


function wlines() {
  local -i count=${1:=5}
  local text="${2:=Line Text}"
  local -i i=1
  for i in {1..$count}; do
    print -- "${text} ${i}"
  done
  return 0
}


#!!!: keep
# watch2: watch files
function watch2() {
  # Options
  local -i interval=2
  while [[ $1 =~ ^- ]]; do
    case $1 in
      # Interval
      (-n|--interval)
        interval=$2
        if [[ $interval -le 0 ]]; then
          error -1 'invalid update interval : ${interval}'
        fi
        shift
      ;;
    esac
    shift
  done
  
  # Text
  local clear='/usr/bin/clear'
  local -i w=$(( $COLUMNS / 2 ))
  local -L $w left_text
  local -R $w right_text
  left_text="Every ${interval} seconds:"
  
  
  # Functions
  function update-header() {
    # Print header
    right_text="$(date -j +'%c')"
    print -- "${left_text}${right_text}"
    # Print line
    line="${(l:$COLUMNS::-:)}"
    print -- "${line}\n\n"
  }
  
  function next-cmd() {
    cmd=${cmds[$i]}
    if [[ $cmd =~ ' ' ]]; then
      #TODO:
    fi
    cmd_name="${cmd%% *}"
    cmd_args="${cmd#* }"
  }
  
  function main-loop() {
    # Commands
    if [[ $# -eq 0 ]]; then
      error -1 'watch commands are not specified'
      return 1
    fi
    local -a cmds=($argv)
    local cmd cmd_args cmd_name
    local -i i
    # Main loop
    $=clear
    while true; do
      # Redraw header
      update-header
      # Run each command
      let i=1
      while [[ $i -le ${#cmds} ]]; do
        next-cmd
        # Print command header
        print -Pf '\e[92m%s %s %s\e[0m\n' -- \
                  "%B[${i}]%b" \
                  "%U$cmd_name%u" \
                  "$cmd_args"
        # Evaluate command
        eval "${=cmd}"
        # Print command footer
        print -Pf '\e[2m%s %s %s\e[0m\n\n\n' --   \
                  "[${i}]" "%U$cmd_name%u" "$cmd_args"
        let i="$i + 1"
      done ##(2)while
      # Wait and clear
      sleep $interval
      $=clear
    done ##(1)while
    return 0
  }
  
  main-loop $argv
  return $?
}

#!!!: keep
function watchfile() {
  local default_file='/usr/local/Terminal/share/zsh/watchfunction'
  local file="${1:=$default_file}"
  if [[ ! -f "$file" ]]; then
    error -1 'file is not found: ${file}'
  fi
  
  function $file() {
    eval "$(< $file)"
  }
  watch2 $argv $file
}


function watchfunction() {
  
}










#???:
function interpret() {(
  local expr
  local -i i=1 expr_status=0
  
  # Read expressions until keyword "quit"
  while [[ "$expr" != "quit" ]]; do
    # Read
    print -Pf '[%i] %b' -- "$i" '%F{6}'
    read -r -E expr
    print -Pf '%b' '%f'
    # Evaluate
    #osascript -e "$expr"
    $=expr
    # Status
    let expr_status=$?
    print -Pf 'Status: %i\n\n' $expr_status
    let i="$i + 1"
  done
)}















#MARK: - List Functions
# list-links:  List symbolic links in a directory
function list-links() {(
  local _g=${fg[green]} _r=${fg[red]} _def=${fg[default]}
  if [[ -n $1 ]]; then
    cd -q $1 ||
    return 1
  fi
  { stat -f "%N $_g->$_def %Y" -- **(@)  &&
    stat -f "%N $_r->$_def %Y" -- **(-@) } 2>/dev/null ||
  return 1
)}


# list-services:  Display local launchctl services.
function list-services() {
  /bin/launchctl list |
  /usr/bin/grep --color='always' -F 'com.maximpuchkov'
}


# list-times:   Display AMCB times for file.
# usage:       `list-times [-amcb] file...'
function list-times () {
  # Configure time options
  local -a opts=()
  while [[ "$1" =~ ^- ]]; do
    opts+=( ${(s::)1##-#} )
    shift
  done
  [[ "$1" == '--' ]] && shift
  
  # Check files
  if [[ $# -eq 0 ]]; then
    error -1 'Files are not specified'
  fi
  
  # If not specified, display file birth time
  if [[ ${#opts} -eq 0 ]]; then
    opts=( b )
  fi
  # Stat format
  local opt stat_fmt
  stat_fmt='File:      %t%N%n'
  for opt in $opts; do
    case "$opt" in
      (a) stat_fmt+='Accessed:%t%Sa%n'   ;;
      (m) stat_fmt+='Modified:%t%Sm%n'   ;;
      (c) stat_fmt+='Changed: %t%Sc%n'   ;;
      (b) stat_fmt+='Birthed: %t%SB%n'   ;;
      (*) error -1  'bad option: ${opt}' ;;
    esac
  done
  
  # Time format: 'mmm dd yyyy[ tab ]HH:MM:SS'
  local strf_time_fmt='%b %d %Y%t%X'
  stat -f "${stat_fmt}%n" -t $strf_time_fmt $argv
  return 0
}


# list-pdf-objects:  Display <obj> and <endobj> PDF tags.
function list-pdf-objects() {
  # Check input file
  local file="$1"
  if [[ ! -f $file ]]; then
    error -1 'Bad input file'
    return 1
  fi
  # Blue separator line
  local line
  print -v line -P -- "%F{4}${(r:$COLUMNS::-:)}%f"
  # PDF object tags
  local object_begin='obj' object_end='endobj'
  # Print all PDF objects
  print -P -- "%BPDF document%b: %U${file}%u\n"
  print -- "$line"
  awk '
    /[0-9]+[ ]+[0-9]+[ ]+'$object_begin'/, /^'$object_end'/ {
    if ($0 == "'$object_end'") {
      $0=$0"\n'$line'"
    }
    print $0
  }' <$file
}

# list-properties:  List properties of an application.
function list-properties() {
  tell -a "$1" 'return properties' |
  grep -E '([^,[[:space:]]?)*(,|$)' -o
}

# list-spec:  list foreground and background
#             spectrum colors from `$1' to `$2'.
# usage:     `list-spec [begin] [end]'
#            `list-spec 0 255'
function list-colors() {
  local -a result=()
  local reset=$'\e[0m' value=''
  local -i -Z3 begin=${1:=0} end=${2:=255} i=0
  shift 2
  print -P -- "$0: spectrum range from $begin to $end"
  for i in {$begin..$end}; do
    print -v value -P -- "\e[2m[${i}]\e[0m  ${FG[$i]}${argv:=TEXT}${reset} | ${BG[$i]}${argv:=TEXT}${reset}"
    result+=("$value")
  done
  print -c -- $result
}


# list-awk:  List `awk' variables.
function list-awk() {
  awk '
    BEGIN {
      print "ARGC = "ARGC;
      print "ARGV = "ARGV[0];
      
      print "CONVFMT = "CONVFMT;
      print "OFMT    = "OFMT;
      
      print "ENVIRON = <...>";
      print "FILENAME = "FILENAME;
      print "FS = "FS;
    }
    {
      print "FNR = "FNR;
      print "NF = "NF;
      print "NR = "NR;
      print "ORS = "ORS
    }
    END {
#length
#rand
#srand
#int
#substr(s,m,[,n])
#index(s,t)
#match(s,r)
#split(s,a,[,fs])
#sub(r,t,[,s])
#gsub(r,t,[,s])
#sprintf(fmt,expr,...)
#system(cmd)
#tolower(str)
#toupper(str)
#
#~
#!~
#/re/
#RLENGTH
#RS
#RSTART
#SUBSEP
  }
  ' ${1:=~text/lines-10}
}





#MARK: - Misc. Utility Functions
# difc:   compare output of two commands.
# usage: `difc command1 [arg...] -- command2 [arg...]'
function difc() {
  # Find index of '--'
  local -i i=${argv[(i)--]}
  if [[ $i -eq 0 ]]; then
    error -1 -- 'Not found: --'
  fi
  # Split on '--'
  typeset -a cmd1 cmd2
  set -A cmd1  ${argv:1:$(( $i - 1 ))}
  set -A cmd2  ${argv:$(( $i + 1 ))}
  # Compare two commands
  () {
    diff --suppress-common-lines --side-by-side --color=always -- "$1" "$2"
    return $?
  } =($cmd1) =($cmd2)
  # Print result
  if [[ $? -eq 0 ]]; then
    print -P "\n%F{2}Identical%f"
  else
    print -P "\n%F{1}Different%f"
  fi
}


# bindkey-key: Print bindkey command for a key.
function bindkey-key() {
  local key cmd
  read -r -k2 -s key
  cmd="bindkey $(cat -vt <<<$key)"
  printf '%s\n\t->\t' "$cmd"
  $=cmd
}

# printz: Print input and arguments to editing buffer stack.
function printz() {
  local -a input
  read-input input
  set -- ${(F)input} $argv
  print -r -z -- "$argv"
}



# header:  print line with background
function header() {
  set -- " $@"
  print -P -- "%B%K{168}${(pr:$COLUMNS:)@}%k%b"
}

function dim() {
  printf '\e[2m%s\e[0m\n' "$*"
}
#MARK: -
























#MARK: - History
# Search history or list recent events
function hist() {
  if [[ -n "$1" ]]; then
    fc -l 1 | grep -E $1 --color='always'
  else
    fc -l -40
  fi
}

# History statistics for N commands
function histat() {
  local -i N=${1:=25}
  fc -l 1    |
  awk '(! /\.\//) \
    { CMD[$2]++; count++; }\
    END { for (a in CMD) print CMD[a] " " CMD[a]*100/count "% " a; }'|
  sort -nr   |
  head -n $N |
  column -t  |
  nl
}
#MARK: -











##
# nbytes:  print size of file (number of bytes)
function nbytes() {
  stat -f '%z' -- "$@"
}
# filesize:  print size of file (human-readable)
function filesize() {
  simplify-size $(nbytes "$@")
}
# diffsize:  compare size of two files
function diffsize() {
  typeset -i size1 size2 diff
  size1=$(nbytes "$1")
  size2=$(nbytes "$2")
  let diff="($size1 - $size2)"
  printf '%s\n' "$(simplify-size $diff)"
}
##






#???:
# interactive diff
function difi() {
  if [[ "$1" == '-K' ]]; then
    shift
  fi
  print -P "Comparing output of commands\n"
  local cmd
  for cmd in cmd{1,2}; do
    print -Pn -- "%U${cmd}%u:\t"
    if [[ -v $cmd ]]; then
      print -- "${(P)cmd}"
    else
      read $cmd
    fi
  done
  
  () {
    diff_cmd=( /usr/local/bin/diff '-qs' '--color=always'
               '--suppress-common-lines' '--side-by-side' )
               
    dim "$diff_cmd"
    $diff_cmd "$1" "$2"
  } =($=cmd1) =($=cmd2)
}






function match() {
  # Choose match lists
  local -a lists=()
  local otype oname
  while [[ "$1" =~ ^[-+] ]]; do
    otype=${1[1]}
    oname=${1##[-+]#}
    case "$oname" in
      p) lists+="typeset -p ${otype}m *"  ;;
      a) lists+="alias -L ${otype}m *"    ;;
      f) lists+="typeset ${otype}f -m *"  ;;
      *) error -1 "bad option: $1"        ;;
    esac
    shift
  done
  # Search for specific name
  local name=$1
  for list in $lists; do
    $=list
  done |
  grep -E -e "$name"
}





#!MARK: - printzf
# printzf:  Print zformat.
# usage:   `printzf format spec'
#
# Examples:
#   `printzf "The condition is %1(x.TRUE.FALSE)" x:2'
function printzf() {
  local -A opts
  zparseopts -D -E -A opts -
  local args
  zformat -f args $argv
  print -r -- "$args"
}



#function template2() {
#  local -A macros
#  macros=(
#    [filename]='New File'
#    [project]=''
#    [date]=''
#    [year]=''
#  )
#  local -a cmds
##  print -nr -aC2 -- ${(kv)macros} |
##  awk 'gsub($1,$2);'
#}


function example() {
  function example_alice() {
    print -P "1:   %F{1}${0}%f ($#): $@"
  }
  function example_bob() {
    print -P "2:   %F{1}${0}%f ($#): $@"
  }
}



template2a() {
  typeset -Ag option_names
  local long short
  print -P -- 'Enter long and short option names or %F{1}Quit%f to end.'
  print -P -- 'Example: --long -l'
  while [[ $long  != 'Quit' ]] ||
        [[ $short != 'Quit' ]]; do
    read long'?Long option: '
    read short'?Short option: '
    option_names+=($long $short)
  done
  
}






# template2f
function template2f() {
#  if [[ ! -v OPTION_NAMES ]]; then
#    local file=${1:=$HOME/private/home/option_names.txt}
#    if [[ ! -f $file ]]; then
#      error -e 1 'Bad option names file: ${file}'
#    fi
#    set -A OPTION_NAMES ${(@f)$(<$file)}
#    shift
#  fi
#  export OPTION_NAMES
  
#  local -a sargs=(a)
#  local sarg
#  select sarg in $sargs; do
#    case $sarg in
#      1) echo 1 ;;
#    esac
#  done


#  while [[ $input != 'Quit' ]]; do
#    printf 'Enter long option'
#  done
  local -A option_names
  local file=${1:=$HOME/private/home/option_names.txt}
  shift
  if [[ ! -f $file ]]; then
    error -e 1 'Bad option names file: ${file}'
  fi
  set -A option_names ${(@f)$(<$file)}
  
  local -a specs
  local opt name{,s}
  for opt names in ${(kv)option_names#-}; do
    specs+=( $opt ${(s.;-.)^names}'='$opt )
  done
  

printz <<EOF

local -a specs
specs=( $specs )

local -A opts
zparseopts -D -E -M -A opts - \$specs

if [[ \$# -eq 0 ]]; then
  error -e 1 -- 'not enough arguments'
fi

local cmd=\$1
shift
if [[ \${+functions[\${0}_\${cmd}]} -ne 1 ]]; then
  error -e 127 -- 'invalid command: \${cmd}'
fi

\${0}_\${cmd} \${argv}
return \$?

EOF
  return 0
}








# is: Evaluate expression and print its truth value.
# usage: `is [expression]'
function is() {
  if [[ -z "$argv" ]]; then
    error -1 'No expression'
  fi
  eval '[[ '"$argv"' ]]' 2>/dev/null
  local -i s=$?
  case $s in
    (2) expr=$argv error -2 'Invalid conditional expression: [[ ${expr} ]].'
  esac
  printzf "%0(s.yes.no)" s:$s
  return $s
}

# `isset parameter' -> yes/no
function isset() {
  if [[ $# -eq 0 ]]; then
    return 1
  fi
  local name
  for name; do
    [[ -v $name ]]
    printzf "${name} is %0(s..not )set" s:$?
  done
}


# every: Do something every interval.
# usage: `every seconds commands...'
function eval-every() {
  local -i interval end
  let interval="$1"
  let end="$SECONDS + $interval"
  shift
  # Evaluate every interval
  while [[ $SECONDS -ne $end ]]; do
    print -P -- "%F{7}[%*] Every ${interval}s: %B%U$1%u%b ${@:2}%f"
    eval "$@"
    sleep $interval
    let end="$SECONDS + $interval"
  done
}




function append() {
  cat <<EOF >>$ZDOTDIR/.zprofile
# $(date)
$argv

EOF
}


#MARK: - append zprofile
# Tue  6 Oct 2020 04:48:00 PDT
alias funcs1='source ~zdot/disabled/zdot/.zprofile-functions'



# Tue  6 Oct 2020 05:06:32 PDT
#tell -a "google chrome" 'repeat with w in every window
#if name of w is not "Ann" then
#log w
#end if
#end repeat'




# nf:  print number of files in a directory.
# usage: `nf [-r]'
function nf~1() {
  local dir
  local -i num
  local -A opts
#  zparseopts -D -E -M -A opts -
  for dir in ${@:-$PWD}; do
    find -L -- "$dir" \
      ! -path "$dir"  \
      -prune -print |
    wc -l |
    read num
    print -PD -- "${dir}: %F{4}%U${num}%u%f files"
  done
}


function Dir() {
  local -i i count
  local d file prefix
  for d in dir-*/*; do
    count=${d##*-}
    prefix=${(M)d%*?-*}
    for i in {1..$count}; do
      file="file-${prefix}-${i}.txt"
      printf '%s' "$file" >"${d}/${file}"
    done
done
}


# rmcolor: Remove all color escape sequences from text.
#
function rmcolor() {
  if zselect -t 10 -r 0; then
    echo $argv
    set -- ${(@f)"$(<&0)"} $argv
    echo $argv
  fi
  if [[ $# -eq 0 ]]; then
    return 2
  fi
  print -r -- "$argv" |
  perl -pe 's/(\e|\\e)\[[0-9;]+m//g; s/%[FKBUS]\{\w*\}//g; s/%[fkbus]//g'
}


typeset -a fds=()

alias zs='zselect -a fds -t 0 -r 0 -w 1 && print -u 2 -- "$fds"'
function fd3() {
  local -i fd color
  for fd in 0 1 2; do
    let color="(2 - $fd) % 5 + 1"
    print -P -- "%F{$color}File Descriptor: ${fd}%f" >&${fd}
  done
}


function nf() {
  # Options
  local -A opts
  local -a specs
  specs=( '-recursive' 'r=-recursive'
          '-depth:'    'd:=-depth' )
  zparseopts -D -E -M -A opts - $specs ||
  error -2 'invalid options'
  set -- ${argv:=$PWD}
  
  # Recursive
  if [[ ${+opts[--recursive]} -eq 1 ]]; then
    # Recursion depth
    local depth=""
    if [[ ${+opts[--depth]} -eq 1 ]]; then
      depth="-maxdepth ${opts[--depth]}"
    fi
    set -- "${(@fo)$(find -L -- $argv -type d $=depth)}"
  fi
  
  # Get number of files in directories
  local -A result
  local -i num total_num
  local dir
  for dir; do
    find -L -- $dir -mindepth 1 -maxdepth 1 |
    wc -l |
    read num
    let total_num="$total_num + $num"
    result+=("$dir" "$num")
  done
  
  # Print result
  if [[ ${#result} -eq 1 ]]; then
    print -r -- ${(v)result}
  else
    print -nr -aC2 -- ${(@Dkv)result}
    print -P -- "%F{7}${(l:$COLUMNS::-:)}%f"
    print -- "Total: $total_num files"
  fi
  
  return $?
}


# Fri  9 Oct 2020 02:41:33 PDT
alias ddate='/bin/date -j +"%Y-%m-%d"'

# Fri  9 Oct 2020 02:48:10 PDT
alias ldate='/bin/date -j +"%B %-e, %Y"'

