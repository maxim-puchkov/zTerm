#!/bin/zsh

#  iff
#  Z-Function (74)
#
#  Created by Maxim Puchkov on 2020-06-25.
#  Copyright Â© 2020 Maxim Puchkov. All rights reserved.


# iff:  evaluate and display the result of conditional expressions.
# Examples:
#   1. iff -i x=10,20,30  25 -gt x
#   2. iff -i a=1,2 -i b=2,1  a -eq b
typeset -a var_specs
zparseopts -D -E -a var_specs - i+:


#
typeset -a exprs
local -a expr
while [[ -n $1 ]]; do
  case $1 in
    (--)
      exprs+=("${expr}")
      expr=()
      shift
      continue
    ;;
    (*)
      expr+=($1)
      shift
    ;;
  esac
done
exprs+=("${expr}")



# var_specs are (-i x=10,20,30 -i y=...)
# opt is '-i'
# spec is 'x=10,20,30', 'y=...'
local var_expr
for opt spec in $var_specs; do
  local var_name=${spec%%=*}
  local -a var_values=(${(s:,:)${spec#*=}})
  # Find expression with variables and replace it
  # with new expressions for each variable value
  local -a matches=(${(M)exprs:#*$var_name*})
  #local exprs var_name var_values matches
  exprs=(${exprs:|matches})
  for var_expr in $matches; do
    for var_value in $var_values; do
      exprs+=(${var_expr/${var_name}/${var_value}})
    done
  done
done



# Evaluate [[ conditional expressions ]]
local expr
for expr in $exprs; do
  is $=expr
done
return 0









#  red $opt $spec
#  blue $name '|' $values
#  echo

#function iff() {(
#    export prog=$0
#    ## iff -i var: specify variable names ##
#    if [[ $1 == '-i' ]]; then
#        typeset -a vars=(${(s:,:)2})
#        shift 2
#    fi
#    [[ $1 == '--' ]] && shift
#
#    for v in $vars; do
#        show "Var is $v"
##        for m in ${(M)argv:#$v}; do
##            show 'Matching element: $m'
###            argv[(i)$m]=$
##        done
###        set -- ${argv//$v/$REPL}
##        for vexp in ${(M)argv:#(|* )${v}( *|)}; do
##            print $vexp
##        done
#    done
#
#    # Evaluate each argument
#    local -i result
#    local result_label
#    print-var argv
#    if [[ $# -eq 0 ]]; then
#        usage 'Bad input.' \
#            '$prog "1 -lt 2"' \
#            '$prog -v X "X -gt 0"'
#    fi
#    while [[ -n $1 ]]; do
##        if [[ $1 =~ '' ]]; then
#
##        fi
#
#        builtin eval "[[ $1 ]]" &>/dev/null
#        let result=$?
#        case $result in
#            0) result_label='%F{2}true%f'  ;;
#            1) result_label='%F{1}false%f' ;;
#            *) result_label='%F{3}invalid expression%f' ;;
#        esac
#        builtin print -P -- "[[ $1 ]]:  $result_label"
#        shift
#    done
#    return 0
#)}

# vars=(X Y) X=(1 2) Y=(3 4) iff 'X -lt Y'
# 1<3, 1<4, 2<3, 2<4
# iff -v X Y Z
