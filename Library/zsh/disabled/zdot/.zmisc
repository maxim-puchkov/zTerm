# User-specific miscellaneous additions for interactive zsh(1) shells.


#MARK: - Aliases
# <#Insertion Point: addalias#>


#MARK: - Exported Variables
export enckey1="f978c11e9a04fbda0ad2bbcd20ca8274ec2daa6f776b2192b8e20a060b765492"    # enckey1: 13 May 22:00
export enciv1="be87368daada310f928cbbc33591a125"    # enciv1: 13 May 22:00
export var="My new variable"    # var: 04 Jun 15:49
export varb="%BMy new bold variable%b"    # varb: 07 Jun 19:13

export -a iff_exprs=(
    '-n A' '[ -n B ]' '[[ -n C ]]'
    '[[ -n D1 ]] && [[ -n D2 ]]'
    '-n E1 && -n E2 || -n E3'
    "$texpr" "$fexpr"
)
# <#Insertion Point: addexp#>




#MARK: - Functions
# <#Insertion Point: addfunc#>









#MARK: - Misc
function def_misc() {




#MARK: - Incomplete functions

function ow() {
    stat -f "%Sp -> owner=%SHp group=%SMp other=%SLp"
}
function recent_files() {
    stat -f "%m%t%Sm %N" ${argv:-$PWD}/* | sort -rn | head -3 | cut -f2-
}

# Write '$1' lines of '$2' random characters
function write-lines() {
    local line_count text_length
    line_count=${1:-1}
    text_length=${2}
    local line pad length
    for line in {1..$line_count}; do
        pad=$(( ${#line_count} + 1 ))
        length=${text_length:-$line}
        text=$( printf '%s' $(dd if=/dev/random bs=1 count=$length 2>/dev/null |
            xxd -p) )
        print ":${(r:$pad:)line}   ${text:0:$length}   ${(l:$pad:)line}:"
    done
}

# Compress a file N(3) times
function compress3 {
    local file=$1
    local filename=${file:r}
    local fileext=${file:e}
    
    if [[ -z $file ]]; then
        error 'No file to compress'
        return 2
    fi
    if [[ $file != $filename ]]; then
        mv -- $file $filename
    fi
    
    local tools=(
        "zip -1 ${filename:r}.zip1 $filename"
        "zip -9 ${filename:r}.zip9 $filename"
        "gzip -1 -k ${filename:t}"
        
    )
    for t in $tools; do
        echo $t
    done
    
    if [[ $file != $filename ]]; then
        mv -- $filename $file
    fi
}




#MARK: Completion
function le() {
    unfunction _$0
cat >"$zdot/completions/_$0" <<EOF
#compdef $0

# _$0
#
#
# zsh function completion
#

typeset -a args=()

args=(
    "-n[create an empty filename (the disk blocks aren't allocated until data is written to them)]"
    "-v[report the names and sizes of created files]"
    $(print -Pl -- ${(qq)argv};)
)

#_arguments -s -S \$args
_arguments -s \$args \
    '-E[specify EOF marker]:end-of-file marker' \
    '(-x -i)-I[specify replacement string for command line]:replacement string' \
    '(-n -l)-L[call program for every number of lines]:number of input lines' \
    '(-)1: :(b k m g)' \
    '*::args: _normal'


return 0
EOF
    OK ; pass
    
    compdef _$0 $0
    autoload -Uz _$0
    return 0
}






#MARK: Pygments
function testpyg() {
    for style in xcode{dark,light}; do
        pygmentize -O style=$style $argv
        print-line
    done
}
function pyg-rtf() {
    local file=$1
    shift
    pygmentize -f 'rtf' ${=argv}
}





#MARK: File Descriptors
function fdw() {
#    typeset filepath=/tmp/$0.txt
    typeset file="$0_$$_$(date -j +'%H:%M').txt"
    exec 3<>/tmp/$file
    
    print -- "$0" >&3
    print -P -- "Arguments[$#]: {$argv}" >&3
    print -P -- "fds 0..10:" >&3
    fds {0..10} >&3
    
    exec 3>&-
    return $?
}

function fdc() {
    function fdc_open() {
        exec {ifd}<&0 {ofd}>&1 {efd}>&2
    }
    function fdc_close() {
        exec {ifd}>&- {ofd}>&- {efd}>&-
    }
    function fdc_show() {
        for id in {i,o,e}fd; do
            
            if [[ -v $id ]]; then
            
            fi
        done
#        [[ -v ifd ]] && [[ -v ofd ]] && [[ -v efd ]]
    }
    
    typeset -ig {i,o,e}fd
    typeset cmd
    if [[ $# -eq 0 ]]; then
        cmd='show'
    else
        cmd=$1
        shift
    fi
    
    if ! fn isdef ${0}_${cmd}; then
        error err
    fi
    OK ok
}


#
#fdc_foo() {
#    count=$1
#    repeat $count; do
#        local delay=$(( $RANDOM % 10 ))
#        if [[ $delay -gt 2 ]]; then
#            print -P "Error: sleep delay is too long: i=%F{3}${delay}%f" >&2
#        else
#            print -P "OK: sleeping for i=%F{3}${delay}%f seconds..." >&1
#            sleep ${delay:-0}
#        fi
#    done
#}
#
#function fdc() {
#    exec 3<&0
#    exec 4>&1
#    exec 5>&2
#    count=${1:-1}
#    result=$( { time (fdc_foo $count 1>&4 2>&5); } 2>&1 )
#
#    read -t -u0 args0;
#    red "FD0: $args0"
#    echo
#    read -t -u3 args3;
#    blue "FD3: $args3"
#    echo
#
##    cat <&3
##    cat <&4
##    cat <&5
#
#    exec 3>&- 4>&- 5>&-
#    redbg "Result = $result"
#}





expT='1 -le 1'
expF='1 -eq 2'
expB='-3'

ev() {
    for exp in $expT $expF $expB; do
        evexp $exp
    done
}

evexp() {
    eval "[[ ${1:?} ]]"
    print ExpRet: $?
}

}
