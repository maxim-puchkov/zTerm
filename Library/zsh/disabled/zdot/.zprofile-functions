#!/bin/zsh

#  zdot/.zprofile-functions
#
#
#  Generated by 'takef' (zsh/.zprofile) on 2020-10-04.
#  Copyright Â© 2020 admin. All rights reserved.



#MARK: - Compress PDF (zsh)
function compress-pdf-zsh() {
  typeset workflow=~/Library/Services/'Compress Scanned File.workflow'
  integer replace_original_file=0
  # Parse options
  while [[ $1 =~ ^[-] ]]; do
    case $1 in
      # -r: replace original document - do not copy
      (-r|--replace-original-file)
        let replace_original_file=1
        shift ;;
      # bad option
      (*)
        (opt=$1 error +R -- 'bad option: ${opt}')
        shift ;;
    esac
  done
  
  # Get list of files
  typeset -a files=(${argv})
  if [[ ${#files} -eq 0 ]]; then
    error -1 -- 'files not found'
  fi
  integer count=0
  integer total_difference=0
  
  # Compress PDF Files
  printf '%s\n\nCompressing %i PDF documents...\n' "$(date -j)" ${#files}
  printf '%*s\n' $COLUMNS '' | tr ' ' '-'
  
  () {
    # Count compressed files and total compression
    local output=$1 error=$2
    local -i compressed_size  original_size
    local -i difference=0
    # Loop for each file
    local f
    for f in ${files}; do
      # Copy and rename original files (add ~orig suffix)
      if [[ $replace_original_file -ne 1 ]] &&
         [[ ! -e "${f:r}~orig.pdf" ]]; then
        cp -i -- "$f" "${f:r}~orig.pdf"
      fi
      # Apply the quartz filter workflow to PDF files
      printf '\e[2m%s\e[0m\e[36m>\e[0m \e[4m%s\e[0m: ' "$(date -j +'%X')" "${f:t}"
      let original_size=$(stat -f '%z' "${f}")
      /usr/bin/automator -i "$f" "$workflow" 1>|$output 2>|$error
      # Check workflow exit status
      case $? in
        # 0:  Compressed PDF file was saved in 'Compressed Files'
        0)
          let compressed_size=$(stat -f '%z' "${f}")
          let difference="($compressed_size - $original_size)"
          let total_difference="($total_difference + ($difference * -1))"
          printf 'file compressed from %s to %s \e[2m(%s)\e[0m\n'  "$(simplify-size $original_size)" "$(simplify-size $compressed_size)" "$(simplify-size $difference)"
          let count="($count + 1)" ;;
        # >0: File could not be compressed
        *)
          printf '\e[31mnot compressed\e[0m \e[2m(%s)\e[0m\n' "${$(cat <$error):-no description.)}" >&2 ;;
      esac
    done
  } =() =()
  # Print footer and exit
  printf '%*s\n\n' $COLUMNS '' | tr ' ' '-'
  printf 'Files compressed:\t%i\n' $count
  printf 'Memory freed:    \t%s\n' "$(simplify-size $total_difference)"
  return 0
}
#MARK: -





#MARK: - Time
# ti:  measure time needed to complete a command N times
function ti() {
  # Number of times command will be executed
  typeset -i count=1000
  typeset -i output_once=0
  typeset command_output=/dev/null
  while [[ $1 =~ ^[-] ]]; do
    case "$1" in
      (-n)  # (-[0-9]##)
        let count="${2:=0}"  # ="${1#-}"
        if [[ $count -le 0 ]]; then
          error -1 'invalid number of repetitions: ${count}'
        fi
        shift 2 ;;
      (-o)
        command_output=/dev/stdout
        shift ;;
      (-1)
        output_once=1
        shift ;;
      (--)
        shift
        break ;;
      (*)
        opt="$1" error -1 -- 'Bad option ${opt}'
        return 1
      ;;
    esac
  done
  
  # Time command execution
  if [[ -z "$1" ]]; then
    error -1 -- 'command is not set.'
  fi
  typeset cmd="$1"
  trap '{
    header "'$0'>  '"${(q)cmd}"'  (count: '$count')"
    if [[ '$output_once' -eq 1 ]]; then
      {printf "Command: \"%s\"\nOutput: \"" "'$cmd'"
      '$cmd'
      printf "\"\n"} &>/dev/stdout
    fi
    time (repeat '$count'; do
      '$cmd'
    done &>'$command_output')
  } &' EXIT
}


# time-interval:  run a command for the specified number of seconds
function time-interval() {
  let duration="${1:=1}"
  let end="$SECONDS+$duration"
  shift
  while [[ $SECONDS -lt $end ]]; do
    : # run command for '$duration' seconds
    ${(z)=@}
  done
}
#MARK: -





#MARK: - Bytes, File Sizes
#
function getbytes() {
  local -i start end length file_size
  let start="($1 - 1)"
  let end="$2"
  # Check input file
  local file="$3"
  if [[ ! -e $file ]]; then
    error -1 'file ${file} does not exist.'
  fi
  # Check boundaries
  let file_size=$(stat -f '%z' $file)
  let length="($end-$start)"
  if [[ $((start+$length)) -gt $file_size ]] ||
     [[ $start -ge $end ]]; then
    error -1 -- 'bad values (start: ${start}, end: ${end}, length: ${length}) for file ${file} (size: ${file_size}).'
  fi
  xxd -s $start -l $length <$file
}

function getbytesr() {
  getbytes "$@" | xxd -r
}





function older() {
  local _time{,_{f,adj}}
  # Time format
  while [[ $1 =~ ^[-] ]]; do
    case $1 in
      (-a)    _time_f='a' ;; # accessed
      (-m)    _time_f='m' ;; # modified
      (-c)    _time_f='c' ;; # changed
      (-B|-C) _time_f='B' ;; # Created (Birth)
      (*)     _time_f='B' ;; # Default
    esac
    shift
  done
  if [[ -z "$_time_f" ]]; then
    _time_f='B'
  fi
  
  if [[ $# -lt 2 ]]; then
    print -P -- "usage: %U${0}%u num[ymwdHMS] file [file...]"
    return 1
  fi
  
  
  # Adjusted current time back
  _time_adj="$1"
  _time=$(date -j -v-"$_time_adj" +'%s')
  if [[ $? -ne 0 ]]; then
    error -1 'invalid time: ${_time_adj}'
  fi
  shift
  
  local file{,__time} desc
  local -i exit_code=0
  for file; do
    if [[ ! -e $file ]]; then
      error -1 +. +R -- 'file does not exist: ${file}'
      continue
    fi
    file__time=$(stat -f "$_time_f" -- "$file")
    
    if [[ $file__time -lt $_time ]]; then
      desc="%F{2}older%f"
    else
      desc="%F{1}not older%f"
      let exit_code="($exit_code + 1)"
    fi
    print -P -- "%U${file}%u: %F{5}${_time_f}%ftime is ${desc} than %U${_time_adj}%u"
  done
  return
}



#alias -L >~log/0/alias.log
#hash -L  >~log/0/hash.log

#https://dev.to/manan30/what-is-the-best-zshrc-config-you-have-seen-14id

