builtin autoload -XU builtin autoload -XU builtin autoload -XU 	(
		set -e
		builtin cd -q "$ZSH"
		_omz::log info "removing all Oh My Zsh Pull Request branches..."
		command git branch --list 'ohmyzsh/pull-*' | while read branch
		do
			command git branch -D "$branch"
		done
	) builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	typeset -g _ZSH_HIGHLIGHT_PRIOR_BUFFER= 
	typeset -gi _ZSH_HIGHLIGHT_PRIOR_CURSOR=  builtin autoload -XU builtin autoload -XU builtin autoload -XU 	osascript 2> /dev/null <<EOF
    set output to ""
    tell application "Finder" to set the_selection to selection
    set item_count to count the_selection
    repeat with item_index from 1 to count the_selection
      if item_index is less than item_count then set the_delimiter to "
"
      if item_index is item_count then set the_delimiter to ""
      set output to output & ((item item_index of the_selection as alias)'s POSIX path) & the_delimiter
    end repeat
EOF 	local osname osver version_file version_files
	case "$OSTYPE" in
		(darwin*) osname=$(command sw_vers -productName) 
			osver=$(command sw_vers -productVersion) 
			builtin echo "OS Version: $osname $osver build $(sw_vers -buildVersion)" ;;
		(cygwin) command systeminfo | command head -4 | command tail -2 ;;
	esac
	if builtin which lsb_release > /dev/null
	then
		builtin echo "OS Release: $(command lsb_release -s -d)"
	fi
	version_files=(/etc/*-release(N) /etc/*-version(N) /etc/*_version(N)) 
	for version_file in $version_files
	do
		builtin echo "$version_file:"
		command cat "$version_file"
		builtin echo
	done builtin autoload -XU builtin autoload -XU 	setopt localoptions noksharrays bareglobqual
	[[ -d "$1" ]] || {
		print -r -- "zsh-syntax-highlighting: highlighters directory ${(qq)1} not found." >&2
		return 1
	}
	local highlighter highlighter_dir
	for highlighter_dir in $1/*/(/)
	do
		highlighter="${highlighter_dir:t}" 
		[[ -f "$highlighter_dir${highlighter}-highlighter.zsh" ]] && . "$highlighter_dir${highlighter}-highlighter.zsh"
		if type "_zsh_highlight_highlighter_${highlighter}_paint" &> /dev/null && type "_zsh_highlight_highlighter_${highlighter}_predicate" &> /dev/null
		then
			
		elif type "_zsh_highlight_${highlighter}_highlighter" &> /dev/null && type "_zsh_highlight_${highlighter}_highlighter_predicate" &> /dev/null
		then
			if false
			then
				print -r -- "zsh-syntax-highlighting: warning: ${(qq)highlighter} highlighter uses deprecated entry point names; please ask its maintainer to update it: https://github.com/zsh-users/zsh-syntax-highlighting/issues/329" >&2
			fi
			eval "_zsh_highlight_highlighter_${(q)highlighter}_paint() { _zsh_highlight_${(q)highlighter}_highlighter \"\$@\" }"
			eval "_zsh_highlight_highlighter_${(q)highlighter}_predicate() { _zsh_highlight_${(q)highlighter}_highlighter_predicate \"\$@\" }"
		else
			print -r -- "zsh-syntax-highlighting: ${(qq)highlighter} highlighter should define both required functions '_zsh_highlight_highlighter_${highlighter}_paint' and '_zsh_highlight_highlighter_${highlighter}_predicate' in ${(qq):-"$highlighter_dir${highlighter}-highlighter.zsh"}." >&2
		fi
	done builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-forward-word -- "$@" 	_zsh_highlight_call_widget .argument-base -- "$@" builtin autoload -XU builtin autoload -XU 	local ZSH_SPECTRUM_TEXT=${ZSH_SPECTRUM_TEXT:-Arma virumque cano Troiae qui primus ab oris} 
	for code in {000..255}
	do
		print -P -- "$code: $BG[$code]$ZSH_SPECTRUM_TEXT%{$reset_color%}"
	done builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_main__command_type_cache=()  	_zsh_highlight_call_widget .vi-oper-swap-case -- "$@" 	_zsh_highlight_call_widget .end-of-line-hist -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	[[ -n $CURSOR ]] && [[ -n ${_ZSH_HIGHLIGHT_PRIOR_CURSOR-} ]] && (($_ZSH_HIGHLIGHT_PRIOR_CURSOR != $CURSOR)) builtin autoload -XU builtin autoload -XU 	local available_tools=("chroma" "pygmentize") 
	if [ -z "$ZSH_COLORIZE_TOOL" ]
	then
		if (( $+commands[pygmentize] ))
		then
			ZSH_COLORIZE_TOOL="pygmentize" 
		elif (( $+commands[chroma] ))
		then
			ZSH_COLORIZE_TOOL="chroma" 
		else
			echo "Neither 'pygments' nor 'chroma' is installed!" >&2
			return 1
		fi
	fi
	if [[ ${available_tools[(Ie)$ZSH_COLORIZE_TOOL]} -eq 0 ]]
	then
		echo "ZSH_COLORIZE_TOOL '$ZSH_COLORIZE_TOOL' not recognized. Available options are 'pygmentize' and 'chroma'." >&2
		return 1
	elif (( $+commands["$ZSH_COLORIZE_TOOL"] ))
	then
		echo "Package '$ZSH_COLORIZE_TOOL' is not installed!" >&2
		return 1
	fi builtin autoload -XU builtin autoload -XU builtin autoload -XU 	if __git_prompt_git rev-parse --git-dir &> /dev/null
	then
		local commits="$(__git_prompt_git rev-list --count @{upstream}..HEAD 2>/dev/null)" 
		if [[ -n "$commits" && "$commits" != 0 ]]
		then
			echo "$ZSH_THEME_GIT_COMMITS_AHEAD_PREFIX$commits$ZSH_THEME_GIT_COMMITS_AHEAD_SUFFIX"
		fi
	fi 	_zsh_highlight_call_widget .down-line -- "$@" builtin autoload -XU 	_zsh_highlight_call_widget .end-of-line -- "$@" builtin autoload -XU 	if zmodload -e zsh/parameter
	then
		REPLY=${aliases[$arg]} 
	else
		REPLY="${"$(alias -- $arg)"#*=}" 
	fi builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	typeset -gi bind_count=$((_ZSH_AUTOSUGGEST_BIND_COUNTS[$1]+1)) 
	_ZSH_AUTOSUGGEST_BIND_COUNTS[$1]=$bind_count  builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-first-non-blank -- "$@" 	emulate -L zsh
	local INDEX STATUS
	INDEX=$(__git_prompt_git status --porcelain -b 2> /dev/null)  || return 0
	STATUS="" 
	if [[ "${INDEX}" =~ $'(^|
)\?\? ' ]]
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_UNTRACKED$STATUS" 
	fi
	if [[ "${INDEX}" =~ $'(^|
)(A |M |MM) ' ]]
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_ADDED$STATUS" 
	fi
	if [[ "${INDEX}" =~ $'(^|
)([ AM]M| T) ' ]]
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_MODIFIED$STATUS" 
	fi
	if [[ "${INDEX}" =~ $'(^|
)R  ' ]]
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_RENAMED$STATUS" 
	fi
	if [[ "${INDEX}" =~ $'(^|
)([A ]D|D ) ' ]]
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_DELETED$STATUS" 
	fi
	if $(__git_prompt_git rev-parse --verify refs/stash >/dev/null 2>&1)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_STASHED$STATUS" 
	fi
	if [[ "${INDEX}" =~ $'(^|
)UU ' ]]
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_UNMERGED$STATUS" 
	fi
	if [[ "${INDEX}" =~ $'(^|
)## [^ ]\+ .*ahead' ]]
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_AHEAD$STATUS" 
	fi
	if [[ "${INDEX}" =~ $'(^|
)## [^ ]\+ .*behind' ]]
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_BEHIND$STATUS" 
	fi
	if [[ "${INDEX}" =~ $'(^|
)## [^ ]\+ .*diverged' ]]
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_DIVERGED$STATUS" 
	fi
	echo $STATUS 	if __git_prompt_git rev-parse --git-dir &> /dev/null
	then
		local commits="$(__git_prompt_git rev-list --count HEAD..@{upstream} 2>/dev/null)" 
		if [[ -n "$commits" && "$commits" != 0 ]]
		then
			echo "$ZSH_THEME_GIT_COMMITS_BEHIND_PREFIX$commits$ZSH_THEME_GIT_COMMITS_BEHIND_SUFFIX"
		fi
	fi 	local -i retval cursor_loc
	local original_buffer="$BUFFER" 
	BUFFER="$BUFFER$POSTDISPLAY" 
	_zsh_autosuggest_invoke_original_widget $@
	retval=$? 
	cursor_loc=$CURSOR 
	if [[ "$KEYMAP" = "vicmd" ]]
	then
		cursor_loc=$((cursor_loc + 1)) 
	fi
	if (( $cursor_loc > $#original_buffer ))
	then
		POSTDISPLAY="${BUFFER[$(($cursor_loc + 1)),$#BUFFER]}" 
		BUFFER="${BUFFER[1,$cursor_loc]}" 
	else
		BUFFER="$original_buffer" 
	fi
	return $retval builtin autoload -XU 	emulate -L zsh
	local encoded_url=$1 
	local caller_encoding=$langinfo[CODESET] 
	local LC_ALL=C 
	export LC_ALL
	local tmp=${encoded_url:gs/+/ /} 
	tmp=${tmp:gs/\/\\/} 
	tmp=${tmp:gs/%/\x/} 
	local decoded
	eval "decoded=\$'$tmp'"
	local safe_encodings
	safe_encodings=(UTF-8 utf8 US-ASCII) 
	if [[ -z ${safe_encodings[(r)$caller_encoding]} ]]
	then
		decoded=$(echo -E "$decoded" | iconv -f UTF-8 -t $caller_encoding) 
		if [[ $? != 0 ]]
		then
			echo "Error converting string from UTF-8 to $caller_encoding" >&2
			return 1
		fi
	fi
	echo -E "$decoded" builtin autoload -XU builtin autoload -XU 	if [[ -n "${_ZSH_AUTOSUGGEST_DISABLED+x}" ]]
	then
		_zsh_autosuggest_enable
	else
		_zsh_autosuggest_disable
	fi builtin autoload -XU 	local -A opts
	zparseopts -D -E -K -M -A opts - -length l=-length
	local cmd='print line;' 
	if [[ ${+opts[--length]} -eq 1 ]]
	then
		cmd='print length(line);' 
	fi
	print -nrC1 -- ${(Pk)1} | awk '
    (length > maxlength) { maxlength = length; line = $0; }
                     END { '"$cmd"' }
  '
	return 0 builtin autoload -XU builtin autoload -XU builtin autoload -XU 	local command="cd \\"$PWD\\"; clear" 
	(( $# > 0 )) && command="${command}; $*" 
	local the_app=$(_omz_osx_get_frontmost_app) 
	if [[ "$the_app" == 'iTerm' ]]
	then
		osascript <<EOF
      -- tell application "iTerm" to activate
      tell application "System Events"
        tell process "iTerm"
          tell menu item "Split Vertically With Current Profile" of menu "Shell" of menu bar item "Shell" of menu bar 1
            click
          end tell
        end tell
        keystroke "${command} 
"
      end tell
EOF
	elif [[ "$the_app" == 'iTerm2' ]]
	then
		osascript <<EOF
      tell application "iTerm2"
        tell current session of first window
          set newSession to (split vertically with same profile)
          tell newSession
            write text "${command}"
            select
          end tell
        end tell
      end tell
EOF
	elif [[ "$the_app" == 'Hyper' ]]
	then
		osascript > /dev/null <<EOF
    tell application "System Events"
      tell process "Hyper"
        tell menu item "Split Vertically" of menu "Shell" of menu bar 1
          click
        end tell
      end tell
      delay 1
      keystroke "${command} 
"
    end tell
EOF
	else
		echo "$0: unsupported terminal app: $the_app" >&2
		return 1
	fi builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .down-line-or-history -- "$@" 	_zsh_highlight_call_widget .delete-word -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-set-buffer -- "$@" 	if [[ -n $1 ]]
	then
		dirs "$@"
	else
		dirs -v | head -10
	fi 	_zsh_highlight_call_widget .history-incremental-search-backward -- "$@" builtin autoload -XU builtin autoload -X builtin autoload -XU builtin autoload -XU 	local ret=$? 
	if [[ $WIDGET == zle-isearch-update ]] && {
			$zsh_highlight__pat_static_bug || ! (( $+ISEARCHMATCH_ACTIVE ))
		}
	then
		region_highlight=() 
		return $ret
	fi
	local -A zsyh_user_options
	if zmodload -e zsh/parameter
	then
		zsyh_user_options=("${(@kv)options}") 
	else
		local canonical_options onoff option raw_options
		raw_options=(${(f)"$(emulate -R zsh; set -o)"}) 
		canonical_options=(${${${(M)raw_options:#*off}%% *}#no} ${${(M)raw_options:#*on}%% *}) 
		for option in $canonical_options
		do
			[[ -o $option ]]
			onoff=${${=:-off on}[2-$?]} 
			zsyh_user_options+=($option $onoff) 
		done
	fi
	typeset -r zsyh_user_options
	emulate -L zsh
	setopt localoptions warncreateglobal nobashrematch
	local REPLY
	[[ -n ${ZSH_HIGHLIGHT_MAXLENGTH:-} ]] && [[ $#BUFFER -gt $ZSH_HIGHLIGHT_MAXLENGTH ]] && return $ret
	[[ $PENDING -gt 0 ]] && return $ret
	typeset -ga region_highlight
	region_highlight=() 
	{
		local cache_place
		local -a region_highlight_copy
		local highlighter
		for highlighter in $ZSH_HIGHLIGHT_HIGHLIGHTERS
		do
			cache_place="_zsh_highlight__highlighter_${highlighter}_cache" 
			typeset -ga ${cache_place}
			if ! type "_zsh_highlight_highlighter_${highlighter}_predicate" >&/dev/null
			then
				echo "zsh-syntax-highlighting: warning: disabling the ${(qq)highlighter} highlighter as it has not been loaded" >&2
				ZSH_HIGHLIGHT_HIGHLIGHTERS=(${ZSH_HIGHLIGHT_HIGHLIGHTERS:#${highlighter}}) 
			elif "_zsh_highlight_highlighter_${highlighter}_predicate"
			then
				region_highlight_copy=("${region_highlight[@]}") 
				region_highlight=() 
				{
					"_zsh_highlight_highlighter_${highlighter}_paint"
				} always {
					: ${(AP)cache_place::="${region_highlight[@]}"}
				}
				region_highlight=("${region_highlight_copy[@]}") 
			fi
			region_highlight+=("${(@P)cache_place}") 
		done
		() {
			(( REGION_ACTIVE )) || return
			integer min max
			if (( MARK > CURSOR ))
			then
				min=$CURSOR max=$MARK 
			else
				min=$MARK max=$CURSOR 
			fi
			if (( REGION_ACTIVE == 1 ))
			then
				[[ $KEYMAP = vicmd ]] && (( max++ ))
			elif (( REGION_ACTIVE == 2 ))
			then
				local needle=$'
' 
				(( min = ${BUFFER[(Ib:min:)$needle]} ))
				(( max = ${BUFFER[(ib:max:)$needle]} - 1 ))
			fi
			_zsh_highlight_apply_zle_highlight region standout "$min" "$max"
		}
		(( $+YANK_ACTIVE )) && (( YANK_ACTIVE )) && _zsh_highlight_apply_zle_highlight paste standout "$YANK_START" "$YANK_END"
		(( $+ISEARCHMATCH_ACTIVE )) && (( ISEARCHMATCH_ACTIVE )) && _zsh_highlight_apply_zle_highlight isearch underline "$ISEARCHMATCH_START" "$ISEARCHMATCH_END"
		(( $+SUFFIX_ACTIVE )) && (( SUFFIX_ACTIVE )) && _zsh_highlight_apply_zle_highlight suffix bold "$SUFFIX_START" "$SUFFIX_END"
		return $ret
	} always {
		typeset -g _ZSH_HIGHLIGHT_PRIOR_BUFFER="$BUFFER" 
		typeset -gi _ZSH_HIGHLIGHT_PRIOR_CURSOR=$CURSOR 
	} builtin autoload -XU 	cd "$(pfd)" builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-up-line-or-beginning-search -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-down-case -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-autosuggest-enable -- "$@" builtin autoload -XU builtin autoload -XU 	emulate -L zsh
	zparseopts -D -E -a opts r m P
	local in_str=$1 
	local url_str="" 
	local spaces_as_plus
	if [[ -z $opts[(r)-P] ]]
	then
		spaces_as_plus=1 
	fi
	local str="$in_str" 
	local encoding=$langinfo[CODESET] 
	local safe_encodings
	safe_encodings=(UTF-8 utf8 US-ASCII) 
	if [[ -z ${safe_encodings[(r)$encoding]} ]]
	then
		str=$(echo -E "$str" | iconv -f $encoding -t UTF-8) 
		if [[ $? != 0 ]]
		then
			echo "Error converting string from $encoding to UTF-8" >&2
			return 1
		fi
	fi
	local i byte ord LC_ALL=C 
	export LC_ALL
	local reserved=';/?:@&=+$,' 
	local mark='_.!~*''()-' 
	local dont_escape="[A-Za-z0-9" 
	if [[ -z $opts[(r)-r] ]]
	then
		dont_escape+=$reserved 
	fi
	if [[ -z $opts[(r)-m] ]]
	then
		dont_escape+=$mark 
	fi
	dont_escape+="]" 
	local url_str="" 
	for ((i = 1; i <= ${#str}; ++i )) do
		byte="$str[i]" 
		if [[ "$byte" =~ "$dont_escape" ]]
		then
			url_str+="$byte" 
		else
			if [[ "$byte" == " " && -n $spaces_as_plus ]]
			then
				url_str+="+" 
			else
				ord=$(( [##16] #byte )) 
				url_str+="%$ord" 
			fi
		fi
	done
	echo -E "$url_str" 	[[ $WIDGET == zle-line-finish ]] || _zsh_highlight_cursor_moved || _zsh_highlight_buffer_modified 	_zsh_highlight_call_widget .quoted-insert -- "$@" 	local file=$1 
	if [[ -f $file || -h $file ]]
	then
		builtin echo "========== $file =========="
		if [[ -h $file ]]
		then
			builtin echo "==========    ( => ${file:A} )   =========="
		fi
		command cat $file
		builtin echo "========== end $file =========="
		builtin echo
	elif [[ -d $file ]]
	then
		builtin echo "File '$file' is a directory"
	elif [[ ! -e $file ]]
	then
		builtin echo "File '$file' does not exist"
	else
		command ls -lad "$file"
	fi builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-backward-word-end -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	cd "$(pxd)" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-goto-mark -- "$@" 	pbcopy < "${1:-/dev/stdin}" 	_zsh_highlight_call_widget .expand-history -- "$@" 	_zsh_highlight_call_widget .vi-forward-blank-word -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .accept-line -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .spell-word -- "$@" 	local buf highlight style=back-quoted-argument-unclosed style_end 
	local -i arg1=$1 end_ i=$1 last offset=0 start subshell_has_end=0 
	local -a highlight_zone highlights offsets
	reply=() 
	last=$(( arg1 + 1 )) 
	while i=$arg[(ib:i+1:)[\\\`]] 
	do
		if (( i > $#arg ))
		then
			buf=$buf$arg[last,i] 
			offsets[i-arg1-offset]='' 
			(( i-- ))
			subshell_has_end=$(( has_end && (start_pos + i == len) )) 
			break
		fi
		if [[ $arg[i] == '\' ]]
		then
			(( i++ ))
			if [[ $arg[i] == ('$'|'`'|'\') ]]
			then
				buf=$buf$arg[last,i-2] 
				(( offset++ ))
				offsets[i-arg1-offset]=$offset 
			else
				buf=$buf$arg[last,i-1] 
			fi
		else
			style=back-quoted-argument 
			style_end=back-quoted-argument-delimiter 
			buf=$buf$arg[last,i-1] 
			offsets[i-arg1-offset]='' 
			break
		fi
		last=$i 
	done
	_zsh_highlight_main_highlighter_highlight_list 0 '' $subshell_has_end $buf
	for start end_ highlight in $reply
	do
		start=$(( start_pos + arg1 + start + offsets[(Rb:start:)?*] )) 
		end_=$(( start_pos + arg1 + end_ + offsets[(Rb:end_:)?*] )) 
		highlights+=($start $end_ $highlight) 
		if [[ $highlight == back-quoted-argument-unclosed && $style == back-quoted-argument ]]
		then
			style_end=unknown-token 
		fi
	done
	reply=($(( start_pos + arg1 - 1 )) $(( start_pos + i )) $style $(( start_pos + arg1 - 1 )) $(( start_pos + arg1 )) back-quoted-argument-delimiter $highlights) 
	if (( $#style_end ))
	then
		reply+=($(( start_pos + i - 1)) $(( start_pos + i )) $style_end) 
	fi
	REPLY=$i  builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	builtin echo "Core command check:"
	local redefined name builtins externals reserved_words
	redefined=() 
	reserved_words=(do done esac then elif else fi for case if while function repeat time until select coproc nocorrect foreach end '!' '[[' '{' '}') 
	builtins=(alias autoload bg bindkey break builtin bye cd chdir command comparguments compcall compctl compdescribe compfiles compgroups compquote comptags comptry compvalues continue dirs disable disown echo echotc echoti emulate enable eval exec exit false fc fg functions getln getopts hash jobs kill let limit log logout noglob popd print printf pushd pushln pwd r read rehash return sched set setopt shift source suspend test times trap true ttyctl type ulimit umask unalias unfunction unhash unlimit unset unsetopt vared wait whence where which zcompile zle zmodload zparseopts zregexparse zstyle) 
	if is-at-least 5.1
	then
		reserved_word+=(declare export integer float local readonly typeset) 
	else
		builtins+=(declare export integer float local readonly typeset) 
	fi
	builtins_fatal=(builtin command local) 
	externals=(zsh) 
	for name in $reserved_words
	do
		if [[ $(builtin whence -w $name) != "$name: reserved" ]]
		then
			builtin echo "reserved word '$name' has been redefined"
			builtin which $name
			redefined+=$name 
		fi
	done
	for name in $builtins
	do
		if [[ $(builtin whence -w $name) != "$name: builtin" ]]
		then
			builtin echo "builtin '$name' has been redefined"
			builtin which $name
			redefined+=$name 
		fi
	done
	for name in $externals
	do
		if [[ $(builtin whence -w $name) != "$name: command" ]]
		then
			builtin echo "command '$name' has been redefined"
			builtin which $name
			redefined+=$name 
		fi
	done
	if [[ -n "$redefined" ]]
	then
		builtin echo "SOME CORE COMMANDS HAVE BEEN REDEFINED: $redefined"
	else
		builtin echo "All core commands are defined normally"
	fi builtin autoload -XU 	if (( ${+ZSH_AUTOSUGGEST_USE_ASYNC} ))
	then
		_zsh_autosuggest_async_request "$BUFFER"
	else
		local suggestion
		_zsh_autosuggest_fetch_suggestion "$BUFFER"
		_zsh_autosuggest_suggest "$suggestion"
	fi builtin autoload -XU builtin autoload -XU 	local opt autol type func delete eval new i ret=0 cmd svc 
	local -a match mbegin mend
	emulate -L zsh
	setopt extendedglob
	if (( ! $# ))
	then
		print -u2 "$0: I need arguments"
		return 1
	fi
	while getopts "anpPkKde" opt
	do
		case "$opt" in
			(a) autol=yes  ;;
			(n) new=yes  ;;
			([pPkK]) if [[ -n "$type" ]]
				then
					print -u2 "$0: type already set to $type"
					return 1
				fi
				if [[ "$opt" = p ]]
				then
					type=pattern 
				elif [[ "$opt" = P ]]
				then
					type=postpattern 
				elif [[ "$opt" = K ]]
				then
					type=widgetkey 
				else
					type=key 
				fi ;;
			(d) delete=yes  ;;
			(e) eval=yes  ;;
		esac
	done
	shift OPTIND-1
	if (( ! $# ))
	then
		print -u2 "$0: I need arguments"
		return 1
	fi
	if [[ -z "$delete" ]]
	then
		if [[ -z "$eval" ]] && [[ "$1" = *\=* ]]
		then
			while (( $# ))
			do
				if [[ "$1" = *\=* ]]
				then
					cmd="${1%%\=*}" 
					svc="${1#*\=}" 
					func="$_comps[${_services[(r)$svc]:-$svc}]" 
					[[ -n ${_services[$svc]} ]] && svc=${_services[$svc]} 
					[[ -z "$func" ]] && func="${${_patcomps[(K)$svc][1]}:-${_postpatcomps[(K)$svc][1]}}" 
					if [[ -n "$func" ]]
					then
						_comps[$cmd]="$func" 
						_services[$cmd]="$svc" 
					else
						print -u2 "$0: unknown command or service: $svc"
						ret=1 
					fi
				else
					print -u2 "$0: invalid argument: $1"
					ret=1 
				fi
				shift
			done
			return ret
		fi
		func="$1" 
		[[ -n "$autol" ]] && autoload -Uz "$func"
		shift
		case "$type" in
			(widgetkey) while [[ -n $1 ]]
				do
					if [[ $# -lt 3 ]]
					then
						print -u2 "$0: compdef -K requires <widget> <comp-widget> <key>"
						return 1
					fi
					[[ $1 = _* ]] || 1="_$1" 
					[[ $2 = .* ]] || 2=".$2" 
					[[ $2 = .menu-select ]] && zmodload -i zsh/complist
					zle -C "$1" "$2" "$func"
					if [[ -n $new ]]
					then
						bindkey "$3" | IFS=$' 	' read -A opt
						[[ $opt[-1] = undefined-key ]] && bindkey "$3" "$1"
					else
						bindkey "$3" "$1"
					fi
					shift 3
				done ;;
			(key) if [[ $# -lt 2 ]]
				then
					print -u2 "$0: missing keys"
					return 1
				fi
				if [[ $1 = .* ]]
				then
					[[ $1 = .menu-select ]] && zmodload -i zsh/complist
					zle -C "$func" "$1" "$func"
				else
					[[ $1 = menu-select ]] && zmodload -i zsh/complist
					zle -C "$func" ".$1" "$func"
				fi
				shift
				for i
				do
					if [[ -n $new ]]
					then
						bindkey "$i" | IFS=$' 	' read -A opt
						[[ $opt[-1] = undefined-key ]] || continue
					fi
					bindkey "$i" "$func"
				done ;;
			(*) while (( $# ))
				do
					if [[ "$1" = -N ]]
					then
						type=normal 
					elif [[ "$1" = -p ]]
					then
						type=pattern 
					elif [[ "$1" = -P ]]
					then
						type=postpattern 
					else
						case "$type" in
							(pattern) if [[ $1 = (#b)(*)=(*) ]]
								then
									_patcomps[$match[1]]="=$match[2]=$func" 
								else
									_patcomps[$1]="$func" 
								fi ;;
							(postpattern) if [[ $1 = (#b)(*)=(*) ]]
								then
									_postpatcomps[$match[1]]="=$match[2]=$func" 
								else
									_postpatcomps[$1]="$func" 
								fi ;;
							(*) if [[ "$1" = *\=* ]]
								then
									cmd="${1%%\=*}" 
									svc=yes 
								else
									cmd="$1" 
									svc= 
								fi
								if [[ -z "$new" || -z "${_comps[$1]}" ]]
								then
									_comps[$cmd]="$func" 
									[[ -n "$svc" ]] && _services[$cmd]="${1#*\=}" 
								fi ;;
						esac
					fi
					shift
				done ;;
		esac
	else
		case "$type" in
			(pattern) unset "_patcomps[$^@]" ;;
			(postpattern) unset "_postpatcomps[$^@]" ;;
			(key) print -u2 "$0: cannot restore key bindings"
				return 1 ;;
			(*) unset "_comps[$^@]" ;;
		esac
	fi builtin autoload -XU builtin autoload -XU builtin autoload -XU 	typeset -g _ZSH_AUTOSUGGEST_LAST_HIGHLIGHT
	if [[ -n "$_ZSH_AUTOSUGGEST_LAST_HIGHLIGHT" ]]
	then
		region_highlight=("${(@)region_highlight:#$_ZSH_AUTOSUGGEST_LAST_HIGHLIGHT}") 
		unset _ZSH_AUTOSUGGEST_LAST_HIGHLIGHT
	fi builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .list-expand -- "$@" 	integer start_pos end_pos=0 buf_offset=$1 has_end=$3 
	local alias_style param_style arg buf=$4 highlight_glob=true style 
	local in_array_assignment=false 
	integer in_alias=0 in_param=0 len=$#buf 
	local -a match mbegin mend list_highlights
	local -A seen_alias
	readonly parameter_name_pattern='([A-Za-z_][A-Za-z0-9_]*|[0-9]+)' 
	list_highlights=() 
	local braces_stack=$2 
	local this_word next_word=':start::start_of_pipeline:' 
	integer in_redirection
	local proc_buf="$buf" 
	local -a args
	if [[ $zsyh_user_options[interactivecomments] == on ]]
	then
		args=(${(zZ+c+)buf}) 
	else
		args=(${(z)buf}) 
	fi
	while (( $#args ))
	do
		arg=$args[1] 
		shift args
		if (( in_alias ))
		then
			(( in_alias-- ))
			if (( in_alias == 0 ))
			then
				seen_alias=() 
				_zsh_highlight_main_add_region_highlight $start_pos $end_pos $alias_style
			fi
		fi
		if (( in_param ))
		then
			(( in_param-- ))
			if (( in_param == 0 ))
			then
				_zsh_highlight_main_add_region_highlight $start_pos $end_pos $param_style
				param_style="" 
			fi
		fi
		if (( in_redirection == 0 ))
		then
			this_word=$next_word 
			next_word=':regular:' 
		else
			(( --in_redirection ))
		fi
		style=unknown-token 
		if [[ $this_word == *':start:'* ]]
		then
			in_array_assignment=false 
			if [[ $arg == 'noglob' ]]
			then
				highlight_glob=false 
			fi
		fi
		if (( in_alias == 0 && in_param == 0 ))
		then
			[[ "$proc_buf" = (#b)(#s)(([ $'	']|\$'
')#)* ]]
			integer offset="${#match[1]}" 
			(( start_pos = end_pos + offset ))
			(( end_pos = start_pos + $#arg ))
			proc_buf="${proc_buf[offset + $#arg + 1,len]}" 
		fi
		if [[ $zsyh_user_options[interactivecomments] == on && $arg[1] == $histchars[3] ]]
		then
			if [[ $this_word == *(':regular:'|':start:')* ]]
			then
				style=comment 
			else
				style=unknown-token 
			fi
			_zsh_highlight_main_add_region_highlight $start_pos $end_pos $style
			in_redirection=1 
			continue
		fi
		if [[ $this_word == *':start:'* ]] && ! (( in_redirection ))
		then
			_zsh_highlight_main__type "$arg" "$(( ! ${+seen_alias[$arg]} ))"
			local res="$REPLY" 
			if [[ $res == "alias" ]]
			then
				if [[ $arg == ?*=* ]]
				then
					(( in_alias == 0 )) && in_alias=1 
					_zsh_highlight_main_add_region_highlight $start_pos $end_pos unknown-token
					continue
				fi
				seen_alias[$arg]=1 
				_zsh_highlight_main__resolve_alias $arg
				local -a alias_args
				if [[ $zsyh_user_options[interactivecomments] == on ]]
				then
					alias_args=(${(zZ+c+)REPLY}) 
				else
					alias_args=(${(z)REPLY}) 
				fi
				args=($alias_args $args) 
				if (( in_alias == 0 ))
				then
					alias_style=alias 
					(( in_alias += $#alias_args + 1 ))
				else
					(( in_alias += $#alias_args ))
				fi
				(( in_redirection++ ))
				continue
			else
				_zsh_highlight_main_highlighter_expand_path $arg
				_zsh_highlight_main__type "$REPLY" 0
				res="$REPLY" 
			fi
		fi
		if _zsh_highlight_main__is_redirection $arg
		then
			if (( in_redirection == 1 ))
			then
				_zsh_highlight_main_add_region_highlight $start_pos $end_pos unknown-token
			else
				in_redirection=2 
				_zsh_highlight_main_add_region_highlight $start_pos $end_pos redirection
			fi
			continue
		elif [[ $arg == '{'${~parameter_name_pattern}'}' ]] && _zsh_highlight_main__is_redirection $args[1]
		then
			in_redirection=3 
			_zsh_highlight_main_add_region_highlight $start_pos $end_pos named-fd
			continue
		fi
		() {
			local -a match mbegin mend
			local MATCH
			integer MBEGIN MEND
			local parameter_name
			local -a words
			if [[ $arg[1] == '$' ]] && [[ ${arg[2]} == '{' ]] && [[ ${arg[-1]} == '}' ]]
			then
				parameter_name=${${arg:2}%?} 
			elif [[ $arg[1] == '$' ]]
			then
				parameter_name=${arg:1} 
			fi
			if [[ $res == none ]] && zmodload -e zsh/parameter && [[ ${parameter_name} =~ ^${~parameter_name_pattern}$ ]] && (( ${+parameters[(e)${MATCH}]} )) && [[ ${parameters[(e)$MATCH]} != *special* ]]
			then
				case ${(tP)MATCH} in
					(*array*|*assoc*) words=(${(P)MATCH})  ;;
					(*) words=(${(P)MATCH})  ;;
				esac
				(( in_param = 1 + $#words ))
				args=($words $args) 
				arg=$args[1] 
				_zsh_highlight_main__type "$arg" 0
				res=$REPLY 
			fi
		}
		if (( ! in_redirection ))
		then
			if [[ $this_word == *':sudo_opt:'* ]]
			then
				if [[ -n $flags_with_argument ]] && {
						[[ -n $flags_sans_argument ]] && [[ $arg == '-'[$flags_sans_argument]#[$flags_with_argument] ]] || [[ $arg == '-'[$flags_with_argument] ]]
					}
				then
					this_word=${this_word//:start:/} 
					next_word=':sudo_arg:' 
				elif [[ -n $flags_with_argument ]] && {
						[[ -n $flags_sans_argument ]] && [[ $arg == '-'[$flags_sans_argument]#[$flags_with_argument]* ]] || [[ $arg == '-'[$flags_with_argument]* ]]
					}
				then
					this_word=${this_word//:start:/} 
					next_word+=':start:' 
					next_word+=':sudo_opt:' 
				elif [[ -n $flags_sans_argument ]] && [[ $arg == '-'[$flags_sans_argument]# ]]
				then
					this_word=':sudo_opt:' 
					next_word+=':start:' 
					next_word+=':sudo_opt:' 
				elif [[ $arg == '-'* ]]
				then
					this_word=':sudo_opt:' 
					next_word+=':start:' 
					next_word+=':sudo_opt:' 
				else
					this_word=${this_word//:sudo_opt:/} 
				fi
			elif [[ $this_word == *':sudo_arg:'* ]]
			then
				next_word+=':sudo_opt:' 
				next_word+=':start:' 
			fi
		fi
		if [[ -n ${(M)ZSH_HIGHLIGHT_TOKENS_COMMANDSEPARATOR:#"$arg"} ]]
		then
			if _zsh_highlight_main__stack_pop T || _zsh_highlight_main__stack_pop Q
			then
				style=unknown-token 
			elif [[ $this_word == *':regular:'* ]]
			then
				style=commandseparator 
			else
				style=unknown-token 
			fi
			if [[ $arg == ';' ]] && $in_array_assignment
			then
				next_word=':regular:' 
			else
				next_word=':start:' 
				highlight_glob=true 
				if [[ $arg != '|' && $arg != '|&' ]]
				then
					next_word+=':start_of_pipeline:' 
				fi
			fi
		elif ! (( in_redirection)) && [[ $this_word == *':always:'* && $arg == 'always' ]]
		then
			style=reserved-word 
			next_word=':start:' 
		elif ! (( in_redirection)) && [[ $this_word == *':start:'* ]]
		then
			if (( ${+precommand_options[$arg]} )) && _zsh_highlight_main__is_runnable $arg
			then
				style=precommand 
				flags_with_argument=${precommand_options[$arg]%:*} 
				flags_sans_argument=${precommand_options[$arg]#*:} 
				next_word=${next_word//:regular:/} 
				next_word+=':sudo_opt:' 
				next_word+=':start:' 
			else
				case $res in
					(reserved) style=reserved-word 
						case $arg in
							(time|nocorrect) next_word=${next_word//:regular:/} 
								next_word+=':start:'  ;;
							($'{') braces_stack='Y'"$braces_stack"  ;;
							($'}') _zsh_highlight_main__stack_pop 'Y' reserved-word
								if [[ $style == reserved-word ]]
								then
									next_word+=':always:' 
								fi ;;
							($'[[') braces_stack='T'"$braces_stack"  ;;
							('do') braces_stack='D'"$braces_stack"  ;;
							('done') _zsh_highlight_main__stack_pop 'D' reserved-word ;;
							('if') braces_stack=':?'"$braces_stack"  ;;
							('then') _zsh_highlight_main__stack_pop ':' reserved-word ;;
							('elif') if [[ ${braces_stack[1]} == '?' ]]
								then
									braces_stack=':'"$braces_stack" 
								else
									style=unknown-token 
								fi ;;
							('else') if [[ ${braces_stack[1]} == '?' ]]
								then
									:
								else
									style=unknown-token 
								fi ;;
							('fi') _zsh_highlight_main__stack_pop '?' ;;
							('foreach') braces_stack='$'"$braces_stack"  ;;
							('end') _zsh_highlight_main__stack_pop '$' reserved-word ;;
							('repeat') in_redirection=2 
								this_word=':start::regular:'  ;;
							('!') if [[ $this_word != *':start_of_pipeline:'* ]]
								then
									style=unknown-token 
								else
									
								fi ;;
						esac ;;
					('suffix alias') style=suffix-alias  ;;
					(alias) : ;;
					(builtin) style=builtin 
						[[ $arg == $'[' ]] && braces_stack='Q'"$braces_stack"  ;;
					(function) style=function  ;;
					(command) style=command  ;;
					(hashed) style=hashed-command  ;;
					(none) if (( ! in_param )) && _zsh_highlight_main_highlighter_check_assign
						then
							_zsh_highlight_main_add_region_highlight $start_pos $end_pos assign
							local i=$(( arg[(i)=] + 1 )) 
							if [[ $arg[i] == '(' ]]
							then
								in_array_assignment=true 
							else
								next_word+=':start:' 
								if (( i <= $#arg ))
								then
									() {
										local highlight_glob=false 
										[[ $zsyh_user_options[globassign] == on ]] && highlight_glob=true 
										_zsh_highlight_main_highlighter_highlight_argument $i
									}
								fi
							fi
							continue
						elif (( ! in_param )) && [[ $arg[0,1] = $histchars[0,1] ]] && (( $#arg[0,2] == 2 ))
						then
							style=history-expansion 
						elif (( ! in_param )) && [[ $arg[0,1] == $histchars[2,2] ]]
						then
							style=history-expansion 
						elif (( ! in_param )) && [[ $arg[1,2] == '((' ]]
						then
							_zsh_highlight_main_add_region_highlight $start_pos $((start_pos + 2)) reserved-word
							if [[ $arg[-2,-1] == '))' ]]
							then
								_zsh_highlight_main_add_region_highlight $((end_pos - 2)) $end_pos reserved-word
							fi
							continue
						elif (( ! in_param )) && [[ $arg == '()' ]]
						then
							style=reserved-word 
						elif (( ! in_param )) && [[ $arg == $'(' ]]
						then
							style=reserved-word 
							braces_stack='R'"$braces_stack" 
						elif (( ! in_param )) && [[ $arg == $')' ]]
						then
							if _zsh_highlight_main__stack_pop 'S'
							then
								REPLY=$start_pos 
								reply=($list_highlights) 
								return 0
							fi
							_zsh_highlight_main__stack_pop 'R' reserved-word
						else
							if _zsh_highlight_main_highlighter_check_path $arg
							then
								style=$REPLY 
							else
								style=unknown-token 
							fi
						fi ;;
					(*) _zsh_highlight_main_add_region_highlight $start_pos $end_pos arg0_$res
						continue ;;
				esac
			fi
			if [[ -n ${(M)ZSH_HIGHLIGHT_TOKENS_CONTROL_FLOW:#"$arg"} ]]
			then
				next_word=':start::start_of_pipeline:' 
			fi
		else
			case $arg in
				($')') if $in_array_assignment
					then
						style=assign 
						in_array_assignment=false 
						next_word+=':start:' 
					elif (( in_redirection ))
					then
						style=unknown-token 
					else
						if _zsh_highlight_main__stack_pop 'S'
						then
							REPLY=$start_pos 
							reply=($list_highlights) 
							return 0
						fi
						_zsh_highlight_main__stack_pop 'R' reserved-word
					fi ;;
				($'()') if (( in_redirection )) || $in_array_assignment
					then
						style=unknown-token 
					else
						if [[ $zsyh_user_options[multifuncdef] == on ]] || false
						then
							next_word+=':start::start_of_pipeline:' 
						fi
						style=reserved-word 
					fi ;;
				(*) if false
					then
						
					elif [[ $arg = $'}' ]] && $right_brace_is_recognised_everywhere
					then
						if (( in_redirection )) || $in_array_assignment
						then
							style=unknown-token 
						else
							_zsh_highlight_main__stack_pop 'Y' reserved-word
							if [[ $style == reserved-word ]]
							then
								next_word+=':always:' 
							fi
						fi
					elif [[ $arg[0,1] = $histchars[0,1] ]] && (( $#arg[0,2] == 2 ))
					then
						style=history-expansion 
					elif [[ $arg == $']]' ]] && _zsh_highlight_main__stack_pop 'T' reserved-word
					then
						:
					elif [[ $arg == $']' ]] && _zsh_highlight_main__stack_pop 'Q' builtin
					then
						:
					else
						_zsh_highlight_main_highlighter_highlight_argument 1 $(( 1 != in_redirection ))
						continue
					fi ;;
			esac
		fi
		_zsh_highlight_main_add_region_highlight $start_pos $end_pos $style
	done
	(( in_alias == 1 )) && in_alias=0 _zsh_highlight_main_add_region_highlight $start_pos $end_pos $alias_style
	(( in_param == 1 )) && in_param=0 _zsh_highlight_main_add_region_highlight $start_pos $end_pos $param_style
	[[ "$proc_buf" = (#b)(#s)(([[:space:]]|\$'
')#) ]]
	REPLY=$(( end_pos + ${#match[1]} - 1 )) 
	reply=($list_highlights) 
	return $(( $#braces_stack > 0 )) 	_zsh_highlight_call_widget .neg-argument -- "$@" builtin autoload -XU builtin autoload -X 	_zsh_highlight_call_widget .split-undo -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	setopt localoptions extendedglob
	if [[ $CONTEXT == (select|vared) ]]
	then
		return
	fi
	typeset -a ZSH_HIGHLIGHT_TOKENS_COMMANDSEPARATOR
	typeset -a ZSH_HIGHLIGHT_TOKENS_CONTROL_FLOW
	local -a options_to_set reply
	local REPLY
	local flags_with_argument
	local flags_sans_argument
	local -A precommand_options
	precommand_options=('-' '' 'builtin' '' 'command' :pvV 'exec' a:cl 'noglob' '' 'doas' aCu:Lns 'nice' n: 'pkexec' '' 'sudo' Cgprtu:AEHPSbilns 'stdbuf' ioe: 'eatmydata' '' 'catchsegv' '' 'nohup' '' 'setsid' :wc 'ssh-agent' aEPt:csDd 'tabbed' gnprtTuU:cdfhs 'chronic' :ev 'ifne' :n) 
	if [[ $zsyh_user_options[ignorebraces] == on || ${zsyh_user_options[ignoreclosebraces]:-off} == on ]]
	then
		local right_brace_is_recognised_everywhere=false 
	else
		local right_brace_is_recognised_everywhere=true 
	fi
	if [[ $zsyh_user_options[pathdirs] == on ]]
	then
		options_to_set+=(PATH_DIRS) 
	fi
	ZSH_HIGHLIGHT_TOKENS_COMMANDSEPARATOR=('|' '||' ';' '&' '&&' '|&' '&!' '&|') 
	ZSH_HIGHLIGHT_TOKENS_CONTROL_FLOW=($'{' $'(' '()' 'while' 'until' 'if' 'then' 'elif' 'else' 'do' 'time' 'coproc' '!') 
	if (( $+X_ZSH_HIGHLIGHT_DIRS_BLACKLIST ))
	then
		print 'zsh-syntax-highlighting: X_ZSH_HIGHLIGHT_DIRS_BLACKLIST is deprecated. Please use ZSH_HIGHLIGHT_DIRS_BLACKLIST.' >&2
		ZSH_HIGHLIGHT_DIRS_BLACKLIST=($X_ZSH_HIGHLIGHT_DIRS_BLACKLIST) 
		unset X_ZSH_HIGHLIGHT_DIRS_BLACKLIST
	fi
	_zsh_highlight_main_highlighter_highlight_list -$#PREBUFFER '' 1 "$PREBUFFER$BUFFER"
	local start end_ style
	for start end_ style in $reply
	do
		(( start >= end_ )) && {
			print -r -- "zsh-syntax-highlighting: BUG: _zsh_highlight_highlighter_main_paint: start($start) >= end($end_)" >&2
			return
		}
		(( end_ <= 0 )) && continue
		(( start < 0 )) && start=0 
		_zsh_highlight_main_calculate_fallback $style
		_zsh_highlight_add_highlight $start $end_ $reply
	done builtin autoload -XU 	_zsh_highlight_call_widget .vi-backward-word -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .up-line -- "$@" 	emulate -L zsh
	local widget
	local ignore_widgets
	ignore_widgets=(.\* _\* autosuggest-\* $ZSH_AUTOSUGGEST_ORIGINAL_WIDGET_PREFIX\* $ZSH_AUTOSUGGEST_IGNORE_WIDGETS) 
	for widget in ${${(f)"$(builtin zle -la)"}:#${(j:|:)~ignore_widgets}}
	do
		if [[ -n ${ZSH_AUTOSUGGEST_CLEAR_WIDGETS[(r)$widget]} ]]
		then
			_zsh_autosuggest_bind_widget $widget clear
		elif [[ -n ${ZSH_AUTOSUGGEST_ACCEPT_WIDGETS[(r)$widget]} ]]
		then
			_zsh_autosuggest_bind_widget $widget accept
		elif [[ -n ${ZSH_AUTOSUGGEST_EXECUTE_WIDGETS[(r)$widget]} ]]
		then
			_zsh_autosuggest_bind_widget $widget execute
		elif [[ -n ${ZSH_AUTOSUGGEST_PARTIAL_ACCEPT_WIDGETS[(r)$widget]} ]]
		then
			_zsh_autosuggest_bind_widget $widget partial_accept
		else
			_zsh_autosuggest_bind_widget $widget modify
		fi
	done builtin autoload -XU builtin autoload -XU 	if [[ $# -eq 0 ]]
	then
		error -1 'no input'
	fi
	local -a opts=() 
	while [[ $1 =~ ^- ]]
	do
		case ${1##-#} in
			(cmd|command) opts+='command'  ;;
			(s|shift) opts+='shift'  ;;
			(c|ctrl|control) opts+='control'  ;;
			(o|opt|option) opts+='option'  ;;
			(*) break ;;
		esac
		shift
	done
	local -a cmd=() 
	case $0 in
		(keycode) cmd+="key code ${argv}"  ;;
		(*) cmd+="keystroke ${(qqq)argv}"  ;;
	esac
	local -a modifiers=() 
	if [[ ${#opts} -gt 0 ]]
	then
		modifiers=(${^opts}' down') 
		cmd+="using {${(j:, :)modifiers}}" 
	fi
	tell -a "System Events" -p "Terminal" "$cmd"
	return 0 	_zsh_highlight_call_widget .kill-region -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	local -i start end
	local highlight
	start=$1 
	end=$2 
	shift 2
	for highlight
	do
		if (( $+ZSH_HIGHLIGHT_STYLES[$highlight] ))
		then
			region_highlight+=("$start $end $ZSH_HIGHLIGHT_STYLES[$highlight]") 
			break
		fi
	done builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	zmodload zsh/datetime
	echo $(( EPOCHSECONDS / 60 / 60 / 24 )) 	_zsh_highlight_call_widget .vi-forward-word-end -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .reset-prompt -- "$@" 	_zsh_highlight_call_widget .put-replace-selection -- "$@" 	_zsh_highlight_call_widget .vi-backward-delete-char -- "$@" 	_zsh_highlight_call_widget .up-case-word -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .end-of-history -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -X builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -X builtin autoload -XU 	_zsh_highlight_call_widget .end-of-list -- "$@" 	local clear list
	zparseopts -E c=clear l=list
	if [[ -n "$clear" ]]
	then
		echo -n >| "$HISTFILE"
		echo History file deleted. Reload the session to see its effects. >&2
	elif [[ -n "$list" ]]
	then
		builtin fc "$@"
	else
		[[ ${@[-1]-} = *[0-9]* ]] && builtin fc -l "$@" || builtin fc -l "$@" 1
	fi builtin autoload -XU builtin autoload -XU builtin autoload -XU 	[[ ${parameters[$1]} = *-export* ]] && return 0
	export "$1=$2" && return 3 builtin autoload -XU 	_zsh_highlight_call_widget .up-line-or-search -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	local -a match mbegin mend
	local MATCH
	integer MBEGIN MEND
	local i j k style
	local AA
	integer c
	reply=() 
	for ((i = $1 + 2 ; i <= $#arg ; i += 1 )) do
		(( j = i + start_pos - 1 ))
		(( k = j + 1 ))
		case "$arg[$i]" in
			("'") break ;;
			("\") style=back-dollar-quoted-argument 
				for ((c = i + 1 ; c <= $#arg ; c += 1 )) do
					[[ "$arg[$c]" != ([0-9xXuUa-fA-F]) ]] && break
				done
				AA=$arg[$i+1,$c-1] 
				if [[ "$AA" =~ "^(x|X)[0-9a-fA-F]{1,2}" || "$AA" =~ "^[0-7]{1,3}" || "$AA" =~ "^u[0-9a-fA-F]{1,4}" || "$AA" =~ "^U[0-9a-fA-F]{1,8}" ]]
				then
					(( k += $#MATCH ))
					(( i += $#MATCH ))
				else
					if (( $#arg > $i+1 )) && [[ $arg[$i+1] == [xXuU] ]]
					then
						style=unknown-token 
					fi
					(( k += 1 ))
					(( i += 1 ))
				fi ;;
			(*) continue ;;
		esac
		reply+=($j $k $style) 
	done
	if [[ $arg[i] == "'" ]]
	then
		style=dollar-quoted-argument 
	else
		(( i-- ))
		style=dollar-quoted-argument-unclosed 
	fi
	reply=($(( start_pos + $1 - 1 )) $(( start_pos + i )) $style $reply) 
	REPLY=$i  builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	print -r -- "${fg[$0]}${argv}${fg[default]}"
	return $(( $# == 0 )) builtin autoload -XU 	_zsh_highlight_call_widget .accept-and-hold -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	man -t "$@" | open -f -a Preview builtin autoload -XU builtin autoload -XU builtin autoload -XU 	autoload -Uz is-at-least
	if ! is-at-least 5.4
	then
		zshexit () {
			kill -KILL $$ 2>&- || command kill -KILL $$
			sleep 1
		}
	fi
	zstyle ':completion:*' matcher-list ''
	zstyle ':completion:*' path-completion false
	zstyle ':completion:*' max-errors 0 not-numeric
	bindkey '^I' autosuggest-capture-completion builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	local -i retval
	_zsh_autosuggest_highlight_reset
	_zsh_autosuggest_clear $@
	retval=$? 
	_zsh_autosuggest_highlight_apply
	zle -R
	return $retval builtin autoload -XU builtin autoload -XU 	return 1 builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-history-search-forward -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	emulate -LR zsh
	local -A opts
	opts=([--type]='a' [--comment]='[#]*') 
	zparseopts-generate -A opts --short-options -- ${(@)argv}
	if [[ $# -lt 2 ]]
	then
		error -1 -m 'not enough arguments'
	fi
	local file=$2 
	if [[ ! -e $file ]]
	then
		error -1 -m 'file not found: ${file}'
	fi
	: ${1:=reply}
	case ${opts[--type]} in
		(a) typeset -ag $1 ;;
		(A) typeset -Ag $1 ;;
		(*) error -1 -m 'invalid array type: ${type}' ;;
	esac
	set -A $1 "${(@)${(Ff)$(< $file)}:#${~opts[--comment]}}" 	_zsh_highlight_call_widget .pound-insert -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	return 1 builtin autoload -XU 	_zsh_highlight_call_widget .accept-and-infer-next-history -- "$@" 	_zsh_highlight_call_widget .vi-join -- "$@" builtin autoload -XU builtin autoload -X builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .undefined-key -- "$@" 	_zsh_highlight_call_widget .vi-find-next-char-skip -- "$@" builtin autoload -XU 	USER_CONFIG_DEFAULTS="CLIENT_ID=\"\"
CLIENT_SECRET=\"\"" 
	USER_CONFIG_FILE="${HOME}/.shpotify.cfg" 
	if ! [[ -f "${USER_CONFIG_FILE}" ]]
	then
		touch "${USER_CONFIG_FILE}"
		echo -e "${USER_CONFIG_DEFAULTS}" > "${USER_CONFIG_FILE}"
	fi
	source "${USER_CONFIG_FILE}"
	showAPIHelp () {
		echo
		echo "Connecting to Spotify's API:"
		echo
		echo "  This command line application needs to connect to Spotify's API in order to"
		echo "  find music by name. It is very likely you want this feature!"
		echo
		echo "  To get this to work, you need to sign up (or in) and create an 'Application' at:"
		echo "  https://developer.spotify.com/my-applications/#!/applications/create"
		echo
		echo "  Once you've created an application, find the 'Client ID' and 'Client Secret'"
		echo "  values, and enter them into your shpotify config file at '${USER_CONFIG_FILE}'"
		echo
		echo "  Be sure to quote your values and don't add any extra spaces!"
		echo "  When done, it should look like this (but with your own values):"
		echo '  CLIENT_ID="abc01de2fghijk345lmnop"'
		echo '  CLIENT_SECRET="qr6stu789vwxyz"'
	}
	showHelp () {
		echo "Usage:"
		echo
		echo "  `basename $0` <command>"
		echo
		echo "Commands:"
		echo
		echo "  play                         # Resumes playback where Spotify last left off."
		echo "  play <song name>             # Finds a song by name and plays it."
		echo "  play album <album name>      # Finds an album by name and plays it."
		echo "  play artist <artist name>    # Finds an artist by name and plays it."
		echo "  play list <playlist name>    # Finds a playlist by name and plays it."
		echo "  play uri <uri>               # Play songs from specific uri."
		echo
		echo "  next                         # Skips to the next song in a playlist."
		echo "  prev                         # Returns to the previous song in a playlist."
		echo "  replay                       # Replays the current track from the beginning."
		echo "  pos <time>                   # Jumps to a time (in secs) in the current song."
		echo "  pause                        # Pauses (or resumes) Spotify playback."
		echo "  stop                         # Stops playback."
		echo "  quit                         # Stops playback and quits Spotify."
		echo
		echo "  vol up                       # Increases the volume by 10%."
		echo "  vol down                     # Decreases the volume by 10%."
		echo "  vol <amount>                 # Sets the volume to an amount between 0 and 100."
		echo "  vol [show]                   # Shows the current Spotify volume."
		echo
		echo "  status                       # Shows the current player status."
		echo "  status artist                # Shows the currently playing artist."
		echo "  status album                 # Shows the currently playing album."
		echo "  status track                 # Shows the currently playing track."
		echo
		echo "  share                        # Displays the current song's Spotify URL and URI."
		echo "  share url                    # Displays the current song's Spotify URL and copies it to the clipboard."
		echo "  share uri                    # Displays the current song's Spotify URI and copies it to the clipboard."
		echo
		echo "  toggle shuffle               # Toggles shuffle playback mode."
		echo "  toggle repeat                # Toggles repeat playback mode."
		showAPIHelp
	}
	cecho () {
		bold=$(tput bold) 
		green=$(tput setaf 2) 
		reset=$(tput sgr0) 
		echo $bold$green"$1"$reset
	}
	showArtist () {
		echo `osascript -e 'tell application "Spotify" to artist of current track as string'`
	}
	showAlbum () {
		echo `osascript -e 'tell application "Spotify" to album of current track as string'`
	}
	showTrack () {
		echo `osascript -e 'tell application "Spotify" to name of current track as string'`
	}
	showStatus () {
		state=`osascript -e 'tell application "Spotify" to player state as string'` 
		cecho "Spotify is currently $state."
		duration=`osascript -e 'tell application "Spotify"
            set durSec to (duration of current track / 1000) as text
            set tM to (round (durSec / 60) rounding down) as text
            if length of ((durSec mod 60 div 1) as text) is greater than 1 then
                set tS to (durSec mod 60 div 1) as text
            else
                set tS to ("0" & (durSec mod 60 div 1)) as text
            end if
            set myTime to tM as text & ":" & tS as text
            end tell
            return myTime'` 
		position=`osascript -e 'tell application "Spotify"
            set pos to player position
            set nM to (round (pos / 60) rounding down) as text
            if length of ((round (pos mod 60) rounding down) as text) is greater than 1 then
                set nS to (round (pos mod 60) rounding down) as text
            else
                set nS to ("0" & (round (pos mod 60) rounding down)) as text
            end if
            set nowAt to nM as text & ":" & nS as text
            end tell
            return nowAt'` 
		echo -e $reset"Artist: $(showArtist)
Album: $(showAlbum)
Track: $(showTrack) 
Position: $position / $duration"
	}
	if [ $# = 0 ]
	then
		showHelp
	else
		if [ ! -d /Applications/Spotify.app ] && [ ! -d $HOME/Applications/Spotify.app ]
		then
			echo "The Spotify application must be installed."
			return 1
		fi
		if [ $(osascript -e 'application "Spotify" is running') = "false" ]
		then
			osascript -e 'tell application "Spotify" to activate' || return 1
			sleep 2
		fi
	fi
	while [ $# -gt 0 ]
	do
		arg=$1 
		case $arg in
			("play") if [ $# != 1 ]
				then
					array=($@) 
					len=${#array[@]} 
					SPOTIFY_SEARCH_API="https://api.spotify.com/v1/search" 
					SPOTIFY_TOKEN_URI="https://accounts.spotify.com/api/token" 
					if [ -z "${CLIENT_ID}" ]
					then
						cecho "Invalid Client ID, please update ${USER_CONFIG_FILE}"
						showAPIHelp
						return 1
					fi
					if [ -z "${CLIENT_SECRET}" ]
					then
						cecho "Invalid Client Secret, please update ${USER_CONFIG_FILE}"
						showAPIHelp
						return 1
					fi
					SHPOTIFY_CREDENTIALS=$(printf "${CLIENT_ID}:${CLIENT_SECRET}" | base64 | tr -d "
"|tr -d '') 
					SPOTIFY_PLAY_URI="" 
					getAccessToken () {
						cecho "Connecting to Spotify's API"
						SPOTIFY_TOKEN_RESPONSE_DATA=$( \
                        curl "${SPOTIFY_TOKEN_URI}" \
                            --silent \
                            -X "POST" \
                            -H "Authorization: Basic ${SHPOTIFY_CREDENTIALS}" \
                            -d "grant_type=client_credentials" \
                    ) 
						if ! [[ "${SPOTIFY_TOKEN_RESPONSE_DATA}" =~ "access_token" ]]
						then
							cecho "Autorization failed, please check ${USER_CONFG_FILE}"
							cecho "${SPOTIFY_TOKEN_RESPONSE_DATA}"
							showAPIHelp
							return 1
						fi
						SPOTIFY_ACCESS_TOKEN=$( \
                        printf "${SPOTIFY_TOKEN_RESPONSE_DATA}" \
                        | grep -E -o '"access_token":".*",' \
                        | sed 's/"access_token"://g' \
                        | sed 's/"//g' \
                        | sed 's/,.*//g' \
                    ) 
					}
					searchAndPlay () {
						type="$1" 
						Q="$2" 
						getAccessToken
						cecho "Searching ${type}s for: $Q"
						SPOTIFY_PLAY_URI=$( \
                        curl -s -G $SPOTIFY_SEARCH_API \
                            -H "Authorization: Bearer ${SPOTIFY_ACCESS_TOKEN}" \
                            -H "Accept: application/json" \
                            --data-urlencode "q=$Q" \
                            -d "type=$type&limit=1&offset=0" \
                        | grep -E -o "spotify:$type:[a-zA-Z0-9]+" -m 1
                    ) 
						echo "play uri: ${SPOTIFY_PLAY_URI}"
					}
					case $2 in
						("list") _args=${array[@]:2:$len} 
							Q=$_args 
							getAccessToken
							cecho "Searching playlists for: $Q"
							results=$( \
                            curl -s -G $SPOTIFY_SEARCH_API --data-urlencode "q=$Q" -d "type=playlist&limit=10&offset=0" -H "Accept: application/json" -H "Authorization: Bearer ${SPOTIFY_ACCESS_TOKEN}" \
                            | grep -E -o "spotify:playlist:[a-zA-Z0-9]+" -m 10 \
                        ) 
							count=$( \
                            echo "$results" | grep -c "spotify:playlist" \
                        ) 
							if [ "$count" -gt 0 ]
							then
								random=$(( $RANDOM % $count)) 
								SPOTIFY_PLAY_URI=$( \
                                echo "$results" | awk -v random="$random" '/spotify:playlist:[a-zA-Z0-9]+/{i++}i==random{print; exit}' \
                            ) 
							fi ;;
						("album" | "artist" | "track") _args=${array[@]:2:$len} 
							searchAndPlay $2 "$_args" ;;
						("uri") SPOTIFY_PLAY_URI=${array[@]:2:$len}  ;;
						(*) _args=${array[@]:1:$len} 
							searchAndPlay track "$_args" ;;
					esac
					if [ "$SPOTIFY_PLAY_URI" != "" ]
					then
						if [ "$2" = "uri" ]
						then
							cecho "Playing Spotify URI: $SPOTIFY_PLAY_URI"
						else
							cecho "Playing ($Q Search) -> Spotify URI: $SPOTIFY_PLAY_URI"
						fi
						osascript -e "tell application \"Spotify\" to play track \"$SPOTIFY_PLAY_URI\""
					else
						cecho "No results when searching for $Q"
					fi
				else
					cecho "Playing Spotify."
					osascript -e 'tell application "Spotify" to play'
				fi
				break ;;
			("pause") state=`osascript -e 'tell application "Spotify" to player state as string'` 
				if [ $state = "playing" ]
				then
					cecho "Pausing Spotify."
				else
					cecho "Playing Spotify."
				fi
				osascript -e 'tell application "Spotify" to playpause'
				break ;;
			("stop") state=`osascript -e 'tell application "Spotify" to player state as string'` 
				if [ $state = "playing" ]
				then
					cecho "Pausing Spotify."
					osascript -e 'tell application "Spotify" to playpause'
				else
					cecho "Spotify is already stopped."
				fi
				break ;;
			("quit") cecho "Quitting Spotify."
				osascript -e 'tell application "Spotify" to quit'
				break ;;
			("next") cecho "Going to next track."
				osascript -e 'tell application "Spotify" to next track'
				showStatus
				break ;;
			("prev") cecho "Going to previous track."
				osascript -e '
            tell application "Spotify"
                set player position to 0
                previous track
            end tell'
				showStatus
				break ;;
			("replay") cecho "Replaying current track."
				osascript -e 'tell application "Spotify" to set player position to 0'
				break ;;
			("vol") vol=`osascript -e 'tell application "Spotify" to sound volume as integer'` 
				if [[ $2 = "" || $2 = "show" ]]
				then
					cecho "Current Spotify volume level is $vol."
					break
				elif [ "$2" = "up" ]
				then
					if [ $vol -le 90 ]
					then
						newvol=$(( vol+10 )) 
						cecho "Increasing Spotify volume to $newvol."
					else
						newvol=100 
						cecho "Spotify volume level is at max."
					fi
				elif [ "$2" = "down" ]
				then
					if [ $vol -ge 10 ]
					then
						newvol=$(( vol-10 )) 
						cecho "Reducing Spotify volume to $newvol."
					else
						newvol=0 
						cecho "Spotify volume level is at min."
					fi
				elif [[ $2 =~ ^[0-9]+$ ]] && [[ $2 -ge 0 && $2 -le 100 ]]
				then
					newvol=$2 
					cecho "Setting Spotify volume level to $newvol"
				else
					echo "Improper use of 'vol' command"
					echo "The 'vol' command should be used as follows:"
					echo "  vol up                       # Increases the volume by 10%."
					echo "  vol down                     # Decreases the volume by 10%."
					echo "  vol [amount]                 # Sets the volume to an amount between 0 and 100."
					echo "  vol                          # Shows the current Spotify volume."
					return 1
				fi
				osascript -e "tell application \"Spotify\" to set sound volume to $newvol"
				break ;;
			("toggle") if [ "$2" = "shuffle" ]
				then
					osascript -e 'tell application "Spotify" to set shuffling to not shuffling'
					curr=`osascript -e 'tell application "Spotify" to shuffling'` 
					cecho "Spotify shuffling set to $curr"
				elif [ "$2" = "repeat" ]
				then
					osascript -e 'tell application "Spotify" to set repeating to not repeating'
					curr=`osascript -e 'tell application "Spotify" to repeating'` 
					cecho "Spotify repeating set to $curr"
				fi
				break ;;
			("status") if [ $# != 1 ]
				then
					case $2 in
						("artist") showArtist
							break ;;
						("album") showAlbum
							break ;;
						("track") showTrack
							break ;;
					esac
				else
					showStatus
				fi
				break ;;
			("info") info=`osascript -e 'tell application "Spotify"
                set durSec to (duration of current track / 1000)
                set tM to (round (durSec / 60) rounding down) as text
                if length of ((durSec mod 60 div 1) as text) is greater than 1 then
                    set tS to (durSec mod 60 div 1) as text
                else
                    set tS to ("0" & (durSec mod 60 div 1)) as text
                end if
                set myTime to tM as text & "min " & tS as text & "s"
                set pos to player position
                set nM to (round (pos / 60) rounding down) as text
                if length of ((round (pos mod 60) rounding down) as text) is greater than 1 then
                    set nS to (round (pos mod 60) rounding down) as text
                else
                    set nS to ("0" & (round (pos mod 60) rounding down)) as text
                end if
                set nowAt to nM as text & "min " & nS as text & "s"
                set info to "" & "
Artist:         " & artist of current track
                set info to info & "
Track:          " & name of current track
                set info to info & "
Album Artist:   " & album artist of current track
                set info to info & "
Album:          " & album of current track
                set info to info & "
Seconds:        " & durSec
                set info to info & "
Seconds played: " & pos
                set info to info & "
Duration:       " & mytime
                set info to info & "
Now at:         " & nowAt
                set info to info & "
Played Count:   " & played count of current track
                set info to info & "
Track Number:   " & track number of current track
                set info to info & "
Popularity:     " & popularity of current track
                set info to info & "
Id:             " & id of current track
                set info to info & "
Spotify URL:    " & spotify url of current track
                set info to info & "
Artwork:        " & artwork url of current track
                set info to info & "
Player:         " & player state
                set info to info & "
Volume:         " & sound volume
                set info to info & "
Shuffle:        " & shuffling
                set info to info & "
Repeating:      " & repeating
            end tell
            return info'` 
				cecho "$info"
				break ;;
			("share") uri=`osascript -e 'tell application "Spotify" to spotify url of current track'` 
				remove='spotify:track:' 
				url=${uri#$remove} 
				url="https://open.spotify.com/track/$url" 
				if [ "$2" = "" ]
				then
					cecho "Spotify URL: $url"
					cecho "Spotify URI: $uri"
					echo "To copy the URL or URI to your clipboard, use:"
					echo "\`spotify share url\` or"
					echo "\`spotify share uri\` respectively."
				elif [ "$2" = "url" ]
				then
					cecho "Spotify URL: $url"
					echo -n $url | pbcopy
				elif [ "$2" = "uri" ]
				then
					cecho "Spotify URI: $uri"
					echo -n $uri | pbcopy
				fi
				break ;;
			("pos") cecho "Adjusting Spotify play position."
				osascript -e "tell application \"Spotify\" to set player position to $2"
				break ;;
			("help") showHelp
				break ;;
			(*) showHelp
				return 1 ;;
		esac
	done builtin autoload -XU builtin autoload -XU 	_zsh_highlight_buffer_modified builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-_complete_tag -- "$@" 	emulate -L zsh
	setopt EXTENDED_GLOB
	typeset -g suggestion
	local line REPLY
	whence compdef > /dev/null || return
	zmodload zsh/zpty 2> /dev/null || return
	[[ -n "$ZSH_AUTOSUGGEST_COMPLETION_IGNORE" ]] && [[ "$1" == $~ZSH_AUTOSUGGEST_COMPLETION_IGNORE ]] && return
	if zle
	then
		zpty $ZSH_AUTOSUGGEST_COMPLETIONS_PTY_NAME _zsh_autosuggest_capture_completion_sync
	else
		zpty $ZSH_AUTOSUGGEST_COMPLETIONS_PTY_NAME _zsh_autosuggest_capture_completion_async "\$1"
		zpty -w $ZSH_AUTOSUGGEST_COMPLETIONS_PTY_NAME $'	'
	fi
	{
		zpty -r $ZSH_AUTOSUGGEST_COMPLETIONS_PTY_NAME line '*'$' ''*'$' '
		suggestion="${${(@0)line}[2]}" 
	} always {
		zpty -d $ZSH_AUTOSUGGEST_COMPLETIONS_PTY_NAME
	} builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .get-line -- "$@" 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-delete-char-or-list -- "$@" builtin autoload -XU builtin autoload -XU 	print -r -- "${fg[$0]}${argv}${fg[default]}"
	return $(( $# == 0 )) 	_zsh_highlight_call_widget .history-incremental-search-forward -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	print -r -- "${fg[$0]}${argv}${fg[default]}"
	return $(( $# == 0 )) builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-_bash_complete-word -- "$@" builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-zle-line-init -- "$@" 	_zsh_highlight_call_widget .what-cursor-position -- "$@" builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-autosuggest-capture-completion -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-expand-or-complete -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .down-history -- "$@" builtin autoload -XU builtin autoload -XU 	setopt localoptions extendedglob
	local pattern
	for pattern in ${(k)ZSH_HIGHLIGHT_REGEXP}
	do
		_zsh_highlight_regexp_highlighter_loop "$BUFFER" "$pattern"
	done 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-autosuggest-disable -- "$@" builtin autoload -XU 	_zsh_highlight_call_widget .emacs-backward-word -- "$@" 	__git_prompt_git config user.name 2> /dev/null builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	local id
	$ZDOTDIR/.iterm2/it2api $argv | grep --color=auto --exclude-dir={.bzr,CVS,.git,.hg,.svn,.idea,.tox} -e 'id=[[:alnum:]-]*' | cut -d '=' -f 2 | read id
	echo "id=$id" builtin autoload -XU builtin autoload -XU 	local entry="$1" default="$2" 
	integer first="$3" second="$4" 
	local region="${zle_highlight[(r)${entry}:*]-}" 
	if [[ -z "$region" ]]
	then
		region=$default 
	else
		region="${region#${entry}:}" 
		if [[ -z "$region" ]] || [[ "$region" == none ]]
		then
			return
		fi
	fi
	integer start end
	if (( first < second ))
	then
		start=$first end=$second 
	else
		start=$second end=$first 
	fi
	region_highlight+=("$start $end $region")  	_zsh_highlight_call_widget .vi-backward-kill-word -- "$@" 	cat <<EOF
Usage: omz <command> [options]

Available commands:

    help                Print this help message
    update              Update Oh My Zsh
    pr <command>        Commands for Oh My Zsh Pull Requests

EOF builtin autoload -XU 	local ref
	ref=$(__git_prompt_git symbolic-ref --quiet HEAD 2> /dev/null) 
	local ret=$? 
	if [[ $ret != 0 ]]
	then
		[[ $ret == 128 ]] && return
		ref=$(__git_prompt_git rev-parse --short HEAD 2> /dev/null)  || return
	fi
	echo ${ref#refs/heads/} builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .emacs-forward-word -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	local color_name
	for color_name in ${(k)fg}
	do
		"$color_name" () {
			print -r -- "${fg[$0]}${argv}${fg[default]}"
			return $(( $# == 0 ))
		}
	done builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-repeat-find -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	pushd "$(pfd)" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-substitute -- "$@" builtin autoload -X builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .recursive-edit -- "$@" 	_zsh_highlight_call_widget .end-of-buffer-or-history -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -X builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .gosmacs-transpose-chars -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	mkdir -p $@ && cd ${@:$#} 	_zsh_highlight_call_widget .vi-caps-lock-panic -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .accept-line-and-down-history -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-znt-history-widget -- "$@" builtin autoload -XU 	_zsh_highlight_call_widget .backward-kill-line -- "$@" 	_zsh_highlight_call_widget .kill-whole-line -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	open vnc://$@ builtin autoload -XU 	local -i retval max_cursor_pos=$#BUFFER 
	if [[ "$KEYMAP" = "vicmd" ]]
	then
		max_cursor_pos=$((max_cursor_pos - 1)) 
	fi
	if (( $CURSOR != $max_cursor_pos || !$#POSTDISPLAY ))
	then
		_zsh_autosuggest_invoke_original_widget $@
		return
	fi
	BUFFER="$BUFFER$POSTDISPLAY" 
	unset POSTDISPLAY
	_zsh_autosuggest_invoke_original_widget $@
	retval=$? 
	if [[ "$KEYMAP" = "vicmd" ]]
	then
		CURSOR=$(($#BUFFER - 1)) 
	else
		CURSOR=$#BUFFER 
	fi
	return $retval builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-delete -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-down-line-or-history -- "$@" 	local key=${1[1]} 
	if [[ -z "$key" ]]
	then
		read -rs -k1 key
	fi
	local hex=$(a2x $key) 
	printf '%s = \x%s
' "$key" "$hex" 	_zsh_highlight_call_widget .vi-delete-char -- "$@" builtin autoload -XU 	(
		_z --add "${PWD:A}" &
	)
	: $RANDOM builtin autoload -XU builtin autoload -XU 	local -i retval
	_zsh_autosuggest_highlight_reset
	_zsh_autosuggest_fetch $@
	retval=$? 
	_zsh_autosuggest_highlight_apply
	zle -R
	return $retval builtin autoload -XU builtin autoload -XU 	local -a breaks match mbegin mend saved_reply
	local MATCH
	integer last_break=$(( start_pos + $1 - 1 )) MBEGIN MEND 
	local i j k ret style
	reply=() 
	for ((i = $1 + 1 ; i <= $#arg ; i += 1 )) do
		(( j = i + start_pos - 1 ))
		(( k = j + 1 ))
		case "$arg[$i]" in
			('"') break ;;
			('`') saved_reply=($reply) 
				_zsh_highlight_main_highlighter_highlight_backtick $i
				(( i = REPLY ))
				reply=($saved_reply $reply) 
				continue ;;
			('$') style=dollar-double-quoted-argument 
				if [[ ${arg:$i} =~ ^([A-Za-z_][A-Za-z0-9_]*|[0-9]+) ]]
				then
					(( k += $#MATCH ))
					(( i += $#MATCH ))
				elif [[ ${arg:$i} =~ ^[{]([A-Za-z_][A-Za-z0-9_]*|[0-9]+)[}] ]]
				then
					(( k += $#MATCH ))
					(( i += $#MATCH ))
				elif [[ $arg[i+1] == '$' ]]
				then
					(( k += 1 ))
					(( i += 1 ))
				elif [[ $arg[i+1] == [-#*@?] ]]
				then
					(( k += 1 ))
					(( i += 1 ))
				elif [[ $arg[i+1] == $'(' ]]
				then
					breaks+=($last_break $(( start_pos + i - 1 ))) 
					(( i += 2 ))
					saved_reply=($reply) 
					_zsh_highlight_main_highlighter_highlight_list $(( start_pos + i - 1 )) S $has_end $arg[i,-1]
					ret=$? 
					(( i += REPLY ))
					last_break=$(( start_pos + i )) 
					reply=($saved_reply $j $(( start_pos + i )) command-substitution-quoted $j $(( j + 2 )) command-substitution-delimiter-quoted $reply) 
					if (( ret == 0 ))
					then
						reply+=($(( start_pos + i - 1 )) $(( start_pos + i )) command-substitution-delimiter-quoted) 
					fi
					continue
				else
					continue
				fi ;;
			("\") style=back-double-quoted-argument 
				if [[ \\`\"\$${histchars[1]} == *$arg[$i+1]* ]]
				then
					(( k += 1 ))
					(( i += 1 ))
				else
					continue
				fi ;;
			($histchars[1]) if [[ $arg[i+1] != ('='|$'('|$'{'|[[:blank:]]) ]]
				then
					style=history-expansion 
				else
					continue
				fi ;;
			(*) continue ;;
		esac
		reply+=($j $k $style) 
	done
	if [[ $arg[i] == '"' ]]
	then
		style=double-quoted-argument 
	else
		(( i-- ))
		style=double-quoted-argument-unclosed 
	fi
	(( last_break != start_pos + i )) && breaks+=($last_break $(( start_pos + i ))) 
	saved_reply=($reply) 
	reply=() 
	for 1 2 in $breaks
	do
		(( $1 != $2 )) && reply+=($1 $2 $style) 
	done
	reply+=($saved_reply) 
	REPLY=$i  builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .select-a-word -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .select-a-shell-word -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-yank-whole-line -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-put-after -- "$@" builtin autoload -XU builtin autoload -XU 	local -i retval
	_zsh_autosuggest_highlight_reset
	_zsh_autosuggest_partial_accept $@
	retval=$? 
	_zsh_autosuggest_highlight_apply
	zle -R
	return $retval builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	local ref
	if [[ "$(__git_prompt_git config --get oh-my-zsh.hide-status 2>/dev/null)" != "1" ]]
	then
		ref=$(__git_prompt_git symbolic-ref HEAD 2> /dev/null)  || ref=$(__git_prompt_git rev-parse --short HEAD 2> /dev/null)  || return 0
		echo "$ZSH_THEME_GIT_PROMPT_PREFIX${ref#refs/heads/}$(parse_git_dirty)$ZSH_THEME_GIT_PROMPT_SUFFIX"
	fi builtin autoload -XU builtin autoload -XU builtin autoload -XU 	local -i retval
	_zsh_autosuggest_highlight_reset
	_zsh_autosuggest_toggle $@
	retval=$? 
	_zsh_autosuggest_highlight_apply
	zle -R
	return $retval builtin autoload -XU 	_zsh_highlight_buffer_modified builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-bracketed-paste -- "$@" builtin autoload -XU 	_zsh_highlight_call_widget .vi-rev-repeat-find -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .history-incremental-pattern-search-forward -- "$@" builtin autoload -X builtin autoload -XU builtin autoload -XU 	local -A fallback_of
	fallback_of=(alias arg0 suffix-alias arg0 builtin arg0 function arg0 command arg0 precommand arg0 hashed-command arg0 arg0_\* arg0 path_prefix path path_pathseparator path path_prefix_pathseparator path_prefix single-quoted-argument{-unclosed,} double-quoted-argument{-unclosed,} dollar-quoted-argument{-unclosed,} back-quoted-argument{-unclosed,} command-substitution{-quoted,,-unquoted,} command-substitution-delimiter{-quoted,,-unquoted,} command-substitution{-delimiter,} process-substitution{-delimiter,} back-quoted-argument{-delimiter,}) 
	local needle=$1 value 
	reply=($1) 
	while [[ -n ${value::=$fallback_of[(k)$needle]} ]]
	do
		unset "fallback_of[$needle]"
		reply+=($value) 
		needle=$value 
	done builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-swap-case -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-change -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	setopt localoptions noksharrays
	typeset -F SECONDS
	local prefix=orig-s$SECONDS-r$RANDOM 
	zmodload zsh/zleparameter 2> /dev/null || {
		print -r -- 'zsh-syntax-highlighting: failed loading zsh/zleparameter.' >&2
		return 1
	}
	local -U widgets_to_bind
	widgets_to_bind=(${${(k)widgets}:#(.*|run-help|which-command|beep|set-local-history|yank|yank-pop)}) 
	widgets_to_bind+=(zle-line-finish) 
	widgets_to_bind+=(zle-isearch-update) 
	local cur_widget
	for cur_widget in $widgets_to_bind
	do
		case ${widgets[$cur_widget]:-""} in
			(user:_zsh_highlight_widget_*)  ;;
			(user:*) zle -N $prefix-$cur_widget ${widgets[$cur_widget]#*:}
				eval "_zsh_highlight_widget_${(q)prefix}-${(q)cur_widget}() { _zsh_highlight_call_widget ${(q)prefix}-${(q)cur_widget} -- \"\$@\" }"
				zle -N $cur_widget _zsh_highlight_widget_$prefix-$cur_widget ;;
			(completion:*) zle -C $prefix-$cur_widget ${${(s.:.)widgets[$cur_widget]}[2,3]}
				eval "_zsh_highlight_widget_${(q)prefix}-${(q)cur_widget}() { _zsh_highlight_call_widget ${(q)prefix}-${(q)cur_widget} -- \"\$@\" }"
				zle -N $cur_widget _zsh_highlight_widget_$prefix-$cur_widget ;;
			(builtin) eval "_zsh_highlight_widget_${(q)prefix}-${(q)cur_widget}() { _zsh_highlight_call_widget .${(q)cur_widget} -- \"\$@\" }"
				zle -N $cur_widget _zsh_highlight_widget_$prefix-$cur_widget ;;
			(*) if [[ $cur_widget == zle-* ]] && (( ! ${+widgets[$cur_widget]} ))
				then
					_zsh_highlight_widget_${cur_widget} () {
						:
						_zsh_highlight
					}
					zle -N $cur_widget _zsh_highlight_widget_$cur_widget
				else
					print -r -- "zsh-syntax-highlighting: unhandled ZLE widget ${(qq)cur_widget}" >&2
					print -r -- "zsh-syntax-highlighting: (This is sometimes caused by doing \`bindkey <keys> ${(q-)cur_widget}\` without creating the ${(qq)cur_widget} widget with \`zle -N\` or \`zle -C\`.)" >&2
				fi ;;
		esac
	done 	_zsh_highlight_call_widget .expand-cmd-path -- "$@" 	return 1 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-_history-complete-newer -- "$@" builtin autoload -XU 	dirname $(osascript 2>/dev/null <<EOF
    if application "Xcode" is running then
      tell application "Xcode"
        return path of active workspace document
      end tell
    end if
EOF
) builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	local command="cd \\"$PWD\\"; clear" 
	(( $# > 0 )) && command="${command}; $*" 
	local the_app=$(_omz_osx_get_frontmost_app) 
	if [[ "$the_app" == 'Terminal' ]]
	then
		osascript > /dev/null <<EOF
      tell application "System Events"
        tell process "Terminal" to keystroke "t" using command down
      end tell
      tell application "Terminal" to do script "${command}" in front window
EOF
	elif [[ "$the_app" == 'iTerm' ]]
	then
		osascript <<EOF
      tell application "iTerm"
        set current_terminal to current terminal
        tell current_terminal
          launch session "Default Session"
          set current_session to current session
          tell current_session
            write text "${command}"
          end tell
        end tell
      end tell
EOF
	elif [[ "$the_app" == 'iTerm2' ]]
	then
		osascript <<EOF
      tell application "iTerm2"
        tell current window
          create tab with default profile
          tell current session to write text "${command}"
        end tell
      end tell
EOF
	elif [[ "$the_app" == 'Hyper' ]]
	then
		osascript > /dev/null <<EOF
      tell application "System Events"
        tell process "Hyper" to keystroke "t" using command down
      end tell
      delay 1
      tell application "System Events"
        keystroke "${command}"
        key code 36  #(presses enter)
      end tell
EOF
	else
		echo "$0: unsupported terminal app: $the_app" >&2
		return 1
	fi 	_zsh_highlight_call_widget .vi-up-line-or-history -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	echoti smkx builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .quote-region -- "$@" builtin autoload -XU 	_zsh_highlight_call_widget .kill-line -- "$@" 	_zsh_highlight_call_widget .vi-kill-eol -- "$@" builtin autoload -XU 	_zsh_highlight_call_widget .expand-word -- "$@" 	_zsh_autosuggest_capture_setup
	zle autosuggest-capture-completion builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	local repo_path
	if repo_path="$(__git_prompt_git rev-parse --show-toplevel 2>/dev/null)"  && [[ -n "$repo_path" ]]
	then
		echo ${repo_path:t}
	fi builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	[[ $1 == (<0-9>|)(\<|\>)* ]] && [[ $1 != (\<|\>)$'('* ]] && [[ $1 != *'<'*'-'*'>'* ]] builtin autoload -XU 	tell -a "System Events" $@ builtin autoload -XU builtin autoload -XU 	case $BUFFER[$1] in
		(\() [[ $BUFFER[$2] == \) ]] ;;
		(\[) [[ $BUFFER[$2] == \] ]] ;;
		(\{) [[ $BUFFER[$2] == \} ]] ;;
		(*) false ;;
	esac 	_zsh_highlight_call_widget .vi-goto-column -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-forward-char -- "$@" 	_zsh_highlight_call_widget .select-in-word -- "$@" 	local -i retval
	local -i KEYS_QUEUED_COUNT
	local orig_buffer="$BUFFER" 
	local orig_postdisplay="$POSTDISPLAY" 
	unset POSTDISPLAY
	_zsh_autosuggest_invoke_original_widget $@
	retval=$? 
	emulate -L zsh
	if (( $PENDING > 0 || $KEYS_QUEUED_COUNT > 0 ))
	then
		POSTDISPLAY="$orig_postdisplay" 
		return $retval
	fi
	if (( $#BUFFER > $#orig_buffer ))
	then
		local added=${BUFFER#$orig_buffer} 
		if [[ "$added" = "${orig_postdisplay:0:$#added}" ]]
		then
			POSTDISPLAY="${orig_postdisplay:$#added}" 
			return $retval
		fi
	fi
	if [[ "$BUFFER" = "$orig_buffer" ]]
	then
		POSTDISPLAY="$orig_postdisplay" 
		return $retval
	fi
	if [[ -n "${_ZSH_AUTOSUGGEST_DISABLED+x}" ]]
	then
		return $?
	fi
	if (( $#BUFFER > 0 ))
	then
		if [[ -z "$ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE" ]] || (( $#BUFFER <= $ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE ))
		then
			_zsh_autosuggest_fetch
		fi
	fi
	return $retval builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-fetch-history -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .overwrite-mode -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-edit-command-line -- "$@" 	_zsh_highlight_call_widget .backward-word -- "$@" builtin autoload -XU 	_zsh_highlight_call_widget .universal-argument -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -X builtin autoload -XU builtin autoload -XU 	local STATUS
	local -a FLAGS
	FLAGS=('--porcelain') 
	if [[ "$(__git_prompt_git config --get oh-my-zsh.hide-dirty)" != "1" ]]
	then
		if [[ "${DISABLE_UNTRACKED_FILES_DIRTY:-}" == "true" ]]
		then
			FLAGS+='--untracked-files=no' 
		fi
		case "${GIT_STATUS_IGNORE_SUBMODULES:-}" in
			(git)  ;;
			(*) FLAGS+="--ignore-submodules=${GIT_STATUS_IGNORE_SUBMODULES:-dirty}"  ;;
		esac
		STATUS=$(__git_prompt_git status ${FLAGS} 2> /dev/null | tail -n1) 
	fi
	if [[ -n $STATUS ]]
	then
		echo "$ZSH_THEME_GIT_PROMPT_DIRTY"
	else
		echo "$ZSH_THEME_GIT_PROMPT_CLEAN"
	fi builtin autoload -XU 	(( $# > 0 && $+functions[_omz::pr::$1] )) || {
		cat <<EOF
Usage: omz pr <command> [options]

Available commands:

    clean                       Delete all PR branches (ohmyzsh/pull-*)
    test <PR_number_or_URL>     Fetch PR #NUMBER and rebase against master

EOF
		return 1
	}
	local command="$1" 
	shift
	_omz::pr::$command "$@" builtin autoload -XU 	_zsh_highlight_call_widget .vi-history-search-backward -- "$@" 	local curcontext="${curcontext}" tmp err_fd=-1 clocale='_comp_locale;' 
	local -a prefix
	if [[ "$1" = -p ]]
	then
		shift
		if (( $#_comp_priv_prefix ))
		then
			curcontext="${curcontext%:*}/${${(@M)_comp_priv_prefix:#^*[^\]=*}[1]}:" 
			zstyle -t ":completion:${curcontext}:${1}" gain-privileges && prefix=($_comp_priv_prefix) 
		fi
	elif [[ "$1" = -l ]]
	then
		shift
		clocale='' 
	fi
	if (( ${debug_fd:--1} > 2 )) || [[ ! -t 2 ]]
	then
		exec {err_fd}>&2
	else
		exec {err_fd}> /dev/null
	fi
	{
		if zstyle -s ":completion:${curcontext}:${1}" command tmp
		then
			if [[ "$tmp" = -* ]]
			then
				eval $clocale "$tmp[2,-1]" "$argv[2,-1]"
			else
				eval $clocale $prefix "$tmp"
			fi
		else
			eval $clocale $prefix "$argv[2,-1]"
		fi 2>&$err_fd
	} always {
		exec {err_fd}>&-
	} builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	return 1 builtin autoload -XU builtin autoload -XU builtin autoload -XU 	local char style
	local -i bracket_color_size=${#ZSH_HIGHLIGHT_STYLES[(I)bracket-level-*]} buflen=${#BUFFER} level=0 matchingpos pos 
	local -A levelpos lastoflevel matching
	for ((pos = 1; pos <= buflen; pos++ )) do
		char=$BUFFER[pos] 
		case $char in
			(["([{"]) levelpos[$pos]=$((++level)) 
				lastoflevel[$level]=$pos  ;;
			([")]}"]) if (( level > 0 ))
				then
					matchingpos=$lastoflevel[$level] 
					levelpos[$pos]=$((level--)) 
					if _zsh_highlight_brackets_match $matchingpos $pos
					then
						matching[$matchingpos]=$pos 
						matching[$pos]=$matchingpos 
					fi
				else
					levelpos[$pos]=-1 
				fi ;;
		esac
	done
	for pos in ${(k)levelpos}
	do
		if (( $+matching[$pos] ))
		then
			if (( bracket_color_size ))
			then
				_zsh_highlight_add_highlight $((pos - 1)) $pos bracket-level-$(( (levelpos[$pos] - 1) % bracket_color_size + 1 ))
			fi
		else
			_zsh_highlight_add_highlight $((pos - 1)) $pos bracket-error
		fi
	done
	if [[ $WIDGET != zle-line-finish ]]
	then
		pos=$((CURSOR + 1)) 
		if (( $+levelpos[$pos] )) && (( $+matching[$pos] ))
		then
			local -i otherpos=$matching[$pos] 
			_zsh_highlight_add_highlight $((otherpos - 1)) $otherpos cursor-matchingbracket
		fi
	fi 	_zsh_highlight_call_widget .delete-char -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-add-next -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-autosuggest-toggle -- "$@" 	local SHA
	SHA=$(__git_prompt_git rev-parse --short HEAD 2> /dev/null)  && echo "$ZSH_THEME_GIT_PROMPT_SHA_BEFORE$SHA$ZSH_THEME_GIT_PROMPT_SHA_AFTER" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .accept-search -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-beginning-of-line -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .undo -- "$@" builtin autoload -XU builtin autoload -XU 	[[ -f "$NVM_DIR/nvm.sh" ]] || return
	local nvm_prompt
	nvm_prompt=$(node -v 2>/dev/null) 
	[[ "${nvm_prompt}x" == "x" ]] && return
	nvm_prompt=${nvm_prompt:1} 
	echo "${ZSH_THEME_NVM_PROMPT_PREFIX}${nvm_prompt}${ZSH_THEME_NVM_PROMPT_SUFFIX}" builtin autoload -XU builtin autoload -XU 	[ -f $HOME/.rvm/bin/rvm-prompt ] || return 1
	local rvm_prompt
	rvm_prompt=$($HOME/.rvm/bin/rvm-prompt ${=ZSH_THEME_RVM_PROMPT_OPTIONS} 2>/dev/null) 
	[[ -z "${rvm_prompt}" ]] && return 1
	echo "${ZSH_THEME_RUBY_PROMPT_PREFIX}${rvm_prompt}${ZSH_THEME_RUBY_PROMPT_SUFFIX}" 	emulate -L zsh
	setopt prompt_subst
	[[ "$EMACS" == *term* ]] && return
	: ${2=$1}
	case "$TERM" in
		(cygwin | xterm* | putty* | rxvt* | konsole* | ansi | mlterm* | alacritty | st*) print -Pn "]2;${2:q}"
			print -Pn "]1;${1:q}" ;;
		(screen* | tmux*) print -Pn "k${1:q}\" ;;
		(*) if [[ "$TERM_PROGRAM" == "iTerm.app" ]]
			then
				print -Pn "]2;${2:q}"
				print -Pn "]1;${1:q}"
			else
				if [[ -n "$terminfo[fsl]" ]] && [[ -n "$terminfo[tsl]" ]]
				then
					echoti tsl
					print -Pn "$1"
					echoti fsl
				fi
			fi ;;
	esac 	local pos style_pathsep
	style_pathsep=$1_pathseparator 
	reply=() 
	[[ -z "$ZSH_HIGHLIGHT_STYLES[$style_pathsep]" || "$ZSH_HIGHLIGHT_STYLES[$1]" == "$ZSH_HIGHLIGHT_STYLES[$style_pathsep]" ]] && return 0
	for ((pos = start_pos; $pos <= end_pos; pos++ )) do
		if [[ $BUFFER[pos] == / ]]
		then
			reply+=($((pos - 1)) $pos $style_pathsep) 
		fi
	done 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-_complete_debug -- "$@" builtin autoload -XU 	[[ "${DISABLE_AUTO_TITLE:-}" == true ]] && return
	title $ZSH_THEME_TERM_TAB_TITLE_IDLE $ZSH_THEME_TERM_TITLE_IDLE builtin autoload -XU builtin autoload -XU 	typeset -A opts
	opts=([--alpha]='Alpha arg' [--alice]='Alice arg' [--bravo]='Bravo arg' [--bob]='Bob arg' [--zulu]='Zulu arg' [--zsh]='$SHELL') 
	red Before
	typeset -m argv ARGC opts
	echo
	green After
	zparseopts-generate -A opts --short-options -- $argv
	typeset -m argv ARGC opts 	[[ $WIDGET == zle-line-finish ]] || _zsh_highlight_cursor_moved 	_zsh_highlight_call_widget .vi-insert -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-replace-chars -- "$@" 	_zsh_highlight_call_widget .visual-mode -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	print -r -- "${fg[$0]}${argv}${fg[default]}"
	return $(( $# == 0 )) 	local -a +h comppostfuncs
	comppostfuncs=(_zsh_autosuggest_capture_postcompletion) 
	CURSOR=$#BUFFER 
	zle -- ${(k)widgets[(r)completion:.complete-word:_main_complete]}
	if is-at-least 5.0.3
	then
		stty -onlcr -ocrnl -F /dev/tty
	fi
	echo -nE - $' '$BUFFER$' ' builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .insert-last-word -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	setopt localoptions nopromptsubst
	local logtype=$1 
	local logname=${${functrace[1]#_}%:*} 
	shift
	if [[ $logtype = debug && -z $_OMZ_DEBUG ]]
	then
		return
	fi
	case "$logtype" in
		(prompt) print -Pn "%S%F{blue}$logname%f%s: $@" ;;
		(debug) print -P "%F{white}$logname%f: $@" ;;
		(info) print -P "%F{green}$logname%f: $@" ;;
		(warn) print -P "%S%F{yellow}$logname%f%s: $@" ;;
		(error) print -P "%S%F{red}$logname%f%s: $@" ;;
	esac >&2 builtin autoload -XU builtin autoload -XU builtin autoload -XU 	print -r -- "${fg[$0]}${argv}${fg[default]}"
	return $(( $# == 0 )) 	setopt localoptions extendedglob
	local pattern
	for pattern in ${(k)ZSH_HIGHLIGHT_PATTERNS}
	do
		_zsh_highlight_pattern_highlighter_loop "$BUFFER" "$pattern"
	done builtin autoload -XU builtin autoload -XU 	local program programs progfile md5
	builtin echo oh-my-zsh diagnostic dump
	builtin echo
	builtin echo $outfile
	builtin echo
	command date
	command uname -a
	builtin echo OSTYPE=$OSTYPE
	builtin echo ZSH_VERSION=$ZSH_VERSION
	builtin echo User: $USER
	builtin echo umask: $(umask)
	builtin echo
	_omz_diag_dump_os_specific_version
	builtin echo
	programs=(sh zsh ksh bash sed cat grep ls find git posh) 
	local progfile="" extra_str="" sha_str="" 
	for program in $programs
	do
		extra_str="" sha_str="" 
		progfile=$(builtin which $program) 
		if [[ $? == 0 ]]
		then
			if [[ -e $progfile ]]
			then
				if builtin whence shasum &> /dev/null
				then
					sha_str=($(command shasum $progfile)) 
					sha_str=$sha_str[1] 
					extra_str+=" SHA $sha_str" 
				fi
				if [[ -h "$progfile" ]]
				then
					extra_str+=" ( -> ${progfile:A} )" 
				fi
			fi
			builtin printf '%-9s %-20s %s
' "$program is" "$progfile" "$extra_str"
		else
			builtin echo "$program: not found"
		fi
	done
	builtin echo
	builtin echo Command Versions:
	builtin echo "zsh: $(zsh --version)"
	builtin echo "this zsh session: $ZSH_VERSION"
	builtin echo "bash: $(bash --version | command grep bash)"
	builtin echo "git: $(git --version)"
	builtin echo "grep: $(grep --version)"
	builtin echo
	_omz_diag_dump_check_core_commands || return 1
	builtin echo
	builtin echo Process state:
	builtin echo pwd: $PWD
	if builtin whence pstree &> /dev/null
	then
		builtin echo Process tree for this shell:
		pstree -p $$
	else
		ps -fT
	fi
	builtin set | command grep -a '^\(ZSH\|plugins\|TERM\|LC_\|LANG\|precmd\|chpwd\|preexec\|FPATH\|TTY\|DISPLAY\|PATH\)\|OMZ'
	builtin echo
	builtin echo Exported:
	builtin echo $(builtin export | command sed 's/=.*//')
	builtin echo
	builtin echo Locale:
	command locale
	builtin echo
	builtin echo Zsh configuration:
	builtin echo setopt: $(builtin setopt)
	builtin echo
	builtin echo zstyle:
	builtin zstyle
	builtin echo
	builtin echo 'compaudit output:'
	compaudit
	builtin echo
	builtin echo '$fpath directories:'
	command ls -lad $fpath
	builtin echo
	builtin echo oh-my-zsh installation:
	command ls -ld ~/.z*
	command ls -ld ~/.oh*
	builtin echo
	builtin echo oh-my-zsh git state:
	(
		builtin cd $ZSH && builtin echo "HEAD: $(git rev-parse HEAD)" && git remote -v && git status | command grep "[^[:space:]]"
	)
	if [[ $verbose -ge 1 ]]
	then
		(
			builtin cd $ZSH && git reflog --date=default | command grep pull
		)
	fi
	builtin echo
	if [[ -e $ZSH_CUSTOM ]]
	then
		local custom_dir=$ZSH_CUSTOM 
		if [[ -h $custom_dir ]]
		then
			custom_dir=$(builtin cd $custom_dir && pwd -P) 
		fi
		builtin echo "oh-my-zsh custom dir:"
		builtin echo "   $ZSH_CUSTOM ($custom_dir)"
		(
			builtin cd ${custom_dir:h} && command find ${custom_dir:t} -name .git -prune -o -print
		)
		builtin echo
	fi
	if [[ $verbose -ge 1 ]]
	then
		builtin echo "bindkey:"
		builtin bindkey
		builtin echo
		builtin echo "infocmp:"
		command infocmp -L
		builtin echo
	fi
	local zdotdir=${ZDOTDIR:-$HOME} 
	builtin echo "Zsh configuration files:"
	local cfgfile cfgfiles
	cfgfiles=(/etc/zshenv /etc/zprofile /etc/zshrc /etc/zlogin /etc/zlogout $zdotdir/.zshenv $zdotdir/.zprofile $zdotdir/.zshrc $zdotdir/.zlogin $zdotdir/.zlogout ~/.zsh.pre-oh-my-zsh /etc/bashrc /etc/profile ~/.bashrc ~/.profile ~/.bash_profile ~/.bash_logout) 
	command ls -lad $cfgfiles 2>&1
	builtin echo
	if [[ $verbose -ge 1 ]]
	then
		for cfgfile in $cfgfiles
		do
			_omz_diag_dump_echo_file_w_header $cfgfile
		done
	fi
	builtin echo
	builtin echo "Zsh compdump files:"
	local dumpfile dumpfiles
	command ls -lad $zdotdir/.zcompdump*
	dumpfiles=($zdotdir/.zcompdump*(N)) 
	if [[ $verbose -ge 2 ]]
	then
		for dumpfile in $dumpfiles
		do
			_omz_diag_dump_echo_file_w_header $dumpfile
		done
	fi builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	if (( EUID == 0 ))
	then
		_zsh_highlight_add_highlight 0 $#BUFFER root
	fi builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	iterm2api set-profile-property ${TERM_SESSION_ID#*:} transparency "${1:=0}"
	return $? 	_zsh_highlight_add_highlight 0 $#BUFFER line 	_zsh_highlight_call_widget .vi-backward-char -- "$@" 	GREP_COLOR="$HGREP_COLOR" ${0#h} --color='always' $argv builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-autosuggest-execute -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -X builtin autoload -XU 	_zsh_highlight_call_widget .vi-find-next-char -- "$@" 	env ZSH="$ZSH" sh "$ZSH/tools/uninstall.sh" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .auto-suffix-retain -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-set-mark -- "$@" 	_zsh_highlight_call_widget .describe-key-briefly -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .kill-buffer -- "$@" 	_zsh_highlight_call_widget .clear-screen -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	local buf="$1" pat="$2" 
	integer OFFSET=0 
	local MATCH
	integer MBEGIN MEND
	local -a match mbegin mend
	while true
	do
		[[ "$buf" =~ "$pat" ]] || return
		region_highlight+=("$((MBEGIN - 1 + OFFSET)) $((MEND + OFFSET)) $ZSH_HIGHLIGHT_REGEXP[$pat]") 
		buf="$buf[$(($MEND+1)),-1]" 
		OFFSET=$((MEND+OFFSET)) 
	done builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	local buf="$1" pat="$2" 
	local -a match mbegin mend
	local MATCH
	integer MBEGIN MEND
	if [[ "$buf" == (#b)(*)(${~pat})* ]]
	then
		region_highlight+=("$((mbegin[2] - 1)) $mend[2] $ZSH_HIGHLIGHT_PATTERNS[$pat]") 
		"$0" "$match[1]" "$pat"
		return $?
	fi builtin autoload -XU builtin autoload -XU 	emulate -L zsh
	typeset -Ag color colour
	color=(00 none 01 bold 02 faint 22 normal 03 standout 23 no-standout 04 underline 24 no-underline 05 blink 25 no-blink 07 reverse 27 no-reverse 08 conceal 28 no-conceal 30 black 40 bg-black 31 red 41 bg-red 32 green 42 bg-green 33 yellow 43 bg-yellow 34 blue 44 bg-blue 35 magenta 45 bg-magenta 36 cyan 46 bg-cyan 37 white 47 bg-white 39 default 49 bg-default) 
	local k
	for k in ${(k)color}
	do
		color[${color[$k]}]=$k 
	done
	for k in ${color[(I)3?]}
	do
		color[fg-${color[$k]}]=$k 
	done
	color[grey]=${color[black]} 
	color[fg-grey]=${color[grey]} 
	color[bg-grey]=${color[bg-black]} 
	colour=(${(kv)color}) 
	local lc=$'[' rc=m 
	typeset -Hg reset_color bold_color
	reset_color="$lc${color[none]}$rc" 
	bold_color="$lc${color[bold]}$rc" 
	typeset -AHg fg fg_bold fg_no_bold
	for k in ${(k)color[(I)fg-*]}
	do
		fg[${k#fg-}]="$lc${color[$k]}$rc" 
		fg_bold[${k#fg-}]="$lc${color[bold]};${color[$k]}$rc" 
		fg_no_bold[${k#fg-}]="$lc${color[normal]};${color[$k]}$rc" 
	done
	typeset -AHg bg bg_bold bg_no_bold
	for k in ${(k)color[(I)bg-*]}
	do
		bg[${k#bg-}]="$lc${color[$k]}$rc" 
		bg_bold[${k#bg-}]="$lc${color[bold]};${color[$k]}$rc" 
		bg_no_bold[${k#bg-}]="$lc${color[normal]};${color[$k]}$rc" 
	done builtin autoload -XU 	local ret=1 
	local -a suf matches
	local -x COMP_POINT COMP_CWORD
	local -a COMP_WORDS COMPREPLY BASH_VERSINFO
	local -x COMP_LINE="$words" 
	local -A savejobstates savejobtexts
	(( COMP_POINT = 1 + ${#${(j. .)words[1,CURRENT-1]}} + $#QIPREFIX + $#IPREFIX + $#PREFIX ))
	(( COMP_CWORD = CURRENT - 1))
	COMP_WORDS=($words) 
	BASH_VERSINFO=(2 05b 0 1 release) 
	savejobstates=(${(kv)jobstates}) 
	savejobtexts=(${(kv)jobtexts}) 
	[[ ${argv[${argv[(I)nospace]:-0}-1]} = -o ]] && suf=(-S '') 
	matches=(${(f)"$(compgen $@ -- ${words[CURRENT]})"}) 
	if [[ -n $matches ]]
	then
		if [[ ${argv[${argv[(I)filenames]:-0}-1]} = -o ]]
		then
			compset -P '*/' && matches=(${matches##*/}) 
			compset -S '/*' && matches=(${matches%%/*}) 
			compadd -Q -f "${suf[@]}" -a matches && ret=0 
		else
			compadd -Q "${suf[@]}" -a matches && ret=0 
		fi
	fi
	if (( ret ))
	then
		if [[ ${argv[${argv[(I)default]:-0}-1]} = -o ]]
		then
			_default "${suf[@]}" && ret=0 
		elif [[ ${argv[${argv[(I)dirnames]:-0}-1]} = -o ]]
		then
			_directories "${suf[@]}" && ret=0 
		fi
	fi
	return ret builtin autoload -XU 	emulate -LR zsh
	local template_ext=".${0}" 
	local macro_pattern='___[A-Z0-9]*___' 
	local -A opts
	set -A opts ${(kv)ztemplate_macros}
	opts+=([--out]="") 
	zparseopts-generate -A opts --short-options -- $argv
	ztemplate_apply () {
		local target="$1" 
		if [[ ! -e $target ]]
		then
			error -1 -m 'target file not found: ${target}'
		fi
		if ! (
				/usr/bin/grep --quiet -e "${~macro_pattern}" < $target
			)
		then
			error -1 -m 'target file ${target} is not a template file'
		fi
		local -a substitutions
		local id value macro{,_{name,value}}
		for id value in ${(kvq)opts}
		do
			macro_name="___${${(UQ)id#--}//-/_}___" 
			macro_value="${${(eQ)value}//\//\/}" 
			if [[ $macro_value =~ ${~macro_pattern} ]]
			then
				substitutions=('s/'"${macro_name}"'/'"${macro_value}"'/g' $substitutions) 
			else
				substitutions=($substitutions 's/'"${macro_name}"'/'"${macro_value}"'/g') 
			fi
		done
		/usr/bin/perl -pe "${(j:; :)substitutions}" < $target
		printf '%i
' $(( ${(e)opts[--template-id]} + 1 )) > $ztemplate_id_file
		return 0
	}
	ztemplate_make () {
		local output_file=${opts[--out]} 
		if [[ ! -f $output_file ]]
		then
			output_file=/dev/stdout 
		fi
		local template_{name,file}
		for template_name
		do
			local template_file="${ztemplate_dir}/Templates/${template_name%$template_ext}${template_ext}" 
			if [[ ! -f $template_file ]]
			then
				error -1 -m '${template_name} is not a valid template name'
			fi
			cat $template_file > $output_file
		done
		return 0
	}
	if [[ $# -lt 2 ]]
	then
		error -1 -m "not enough arguments" -u "${0} [--<macro> value] make [template...]; ${0} [--<macro> value] apply [file]"
	fi
	local cmd=$1 
	shift
	if [[ ${+functions[${0}_${cmd}]} -ne 1 ]]
	then
		error -127 -m 'no such command: ${cmd}'
	fi
	${0}_${cmd} ${argv}
	return 0 builtin autoload -XU builtin autoload -XU builtin autoload -XU 	sudo kextunload -b com.apple.iokit.BroadcomBluetoothHostControllerUSBTransport
	sudo kextload -b com.apple.iokit.BroadcomBluetoothHostControllerUSBTransport builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .forward-word -- "$@" 	_zsh_highlight_call_widget .history-beginning-search-backward -- "$@" 	_zsh_highlight_call_widget .vi-repeat-change -- "$@" 	_zsh_highlight_call_widget .vi-match-bracket -- "$@" 	_zsh_highlight_call_widget .quote-line -- "$@" 	_zsh_highlight_call_widget .where-is -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	emulate -L zsh
	builtin echo "Generating diagnostic dump; please be patient..."
	local thisfcn=omz_diagnostic_dump 
	local -A opts
	local opt_verbose opt_noverbose opt_outfile
	local timestamp=$(date +%Y%m%d-%H%M%S) 
	local outfile=omz_diagdump_$timestamp.txt 
	builtin zparseopts -A opts -D -- "v+=opt_verbose" "V+=opt_noverbose"
	local verbose n_verbose=${#opt_verbose} n_noverbose=${#opt_noverbose} 
	(( verbose = 1 + n_verbose - n_noverbose ))
	if [[ ${#*} > 0 ]]
	then
		opt_outfile=$1 
	fi
	if [[ ${#*} > 1 ]]
	then
		builtin echo "$thisfcn: error: too many arguments" >&2
		return 1
	fi
	if [[ -n "$opt_outfile" ]]
	then
		outfile="$opt_outfile" 
	fi
	_omz_diag_dump_one_big_text &> "$outfile"
	if [[ $? != 0 ]]
	then
		builtin echo "$thisfcn: error while creating diagnostic dump; see $outfile for details"
	fi
	builtin echo
	builtin echo Diagnostic dump file created at: "$outfile"
	builtin echo
	builtin echo To share this with OMZ developers, post it as a gist on GitHub
	builtin echo at "https://gist.github.com" and share the link to the gist.
	builtin echo
	builtin echo "WARNING: This dump file contains all your zsh and omz configuration files,"
	builtin echo "so don't share it publicly if there's sensitive information in them."
	builtin echo builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-undo-change -- "$@" 	local -a all_flags
	setarray all_flags ~share/expansion-flags
	local -A otps
	zparseopts -D -E -K -M -A opts - F:
	[[ $# -eq 0 ]] && return 1
	local id="$1" 
	if [[ ! -v $id ]]
	then
		error -1 -m 'parameter ${id} is not set'
	fi
	expand () {
		eval 'printf "%s: %s
" "'$2'" "${('$2')'$1'}"'
	}
	local f
	for f in $all_flags
	do
		expand $id $f
	done
	if [[ ${+opts[-F]} -eq 1 ]]
	then
		expand $id ${opts[-F]}
	fi 	echo "LAST_EPOCH=$(current_epoch)" >| "${ZSH_CACHE_DIR}/.zsh-update" 	_zsh_highlight_call_widget .history-search-forward -- "$@" builtin autoload -XU builtin autoload -XU 	if [[ "$1" = https://* ]]
	then
		1="${1:t}" 
	fi
	if ! [[ -n "$1" && "$1" =~ ^[[:digit:]]+$ ]]
	then
		echo "Usage: omz pr test <PR_NUMBER_or_URL>" >&2
		return 1
	fi
	local branch
	branch=$(builtin cd -q "$ZSH"; git symbolic-ref --short HEAD)  || {
		_omz::log error "error when getting the current git branch. Aborting..."
		return 1
	}
	(
		set -e
		builtin cd -q "$ZSH"
		command git remote -v | while read remote url _
		do
			case "$url" in
				(https://github.com/ohmyzsh/ohmyzsh(|.git)) found=1 
					break ;;
				(git@github.com:ohmyzsh/ohmyzsh(|.git)) found=1 
					break ;;
			esac
		done
		(( $found )) || {
			_omz::log error "could not found the ohmyzsh git remote. Aborting..."
			return 1
		}
		_omz::log info "fetching PR #$1 to ohmyzsh/pull-$1..."
		command git fetch -f "$remote" refs/pull/$1/head:ohmyzsh/pull-$1 || {
			_omz::log error "error when trying to fetch PR #$1."
			return 1
		}
		_omz::log info "rebasing PR #$1..."
		command git rebase master ohmyzsh/pull-$1 || {
			command git rebase --abort &> /dev/null
			_omz::log warn "could not rebase PR #$1 on top of master."
			_omz::log warn "you might not see the latest stable changes."
			_omz::log info "run \`zsh\` to test the changes."
			return 1
		}
		_omz::log info "fetch of PR #${1} successful."
	)
	[[ $? -eq 0 ]] || return 1
	_omz::log info "running \`zsh\` to test the changes. Run \`exit\` to go back."
	command zsh -l
	_omz::log prompt "do you want to go back to the previous branch? [Y/n] "
	read -r -k 1
	[[ "$REPLY" != $'
' ]] && echo
	[[ "$REPLY" = [nN] ]] && return
	(
		set -e
		builtin cd -q "$ZSH"
		command git checkout "$branch" -- || {
			_omz::log error "could not go back to the previous branch ('$branch')."
			return 1
		}
	) builtin autoload -XU 	local -i retval
	_zsh_autosuggest_highlight_reset
	_zsh_autosuggest_accept $@
	retval=$? 
	_zsh_autosuggest_highlight_apply
	zle -R
	return $retval builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-_most_recent_file -- "$@" builtin autoload -XU 	_zsh_highlight_call_widget .vi-find-prev-char -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	typeset -gA _ZSH_AUTOSUGGEST_BIND_COUNTS
	local widget=$1 
	local autosuggest_action=$2 
	local prefix=$ZSH_AUTOSUGGEST_ORIGINAL_WIDGET_PREFIX 
	local -i bind_count
	case $widgets[$widget] in
		(user:_zsh_autosuggest_(bound|orig)_*) bind_count=$((_ZSH_AUTOSUGGEST_BIND_COUNTS[$widget]))  ;;
		(user:*) _zsh_autosuggest_incr_bind_count $widget
			zle -N $prefix$bind_count-$widget ${widgets[$widget]#*:} ;;
		(builtin) _zsh_autosuggest_incr_bind_count $widget
			eval "_zsh_autosuggest_orig_${(q)widget}() { zle .${(q)widget} }"
			zle -N $prefix$bind_count-$widget _zsh_autosuggest_orig_$widget ;;
		(completion:*) _zsh_autosuggest_incr_bind_count $widget
			eval "zle -C $prefix$bind_count-${(q)widget} ${${(s.:.)widgets[$widget]}[2,3]}" ;;
	esac
	eval "_zsh_autosuggest_bound_${bind_count}_${(q)widget}() {
		_zsh_autosuggest_widget_$autosuggest_action $prefix$bind_count-${(q)widget} \$@
	}"
	zle -N -- $widget _zsh_autosuggest_bound_${bind_count}_$widget 	_zsh_highlight_call_widget .vi-backward-blank-word -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	[[ $# -gt 0 ]] || {
		_omz::help
		return 1
	}
	local command="$1" 
	shift
	(( $+functions[_omz::$command] )) || {
		_omz::help
		return 1
	}
	_omz::$command "$@" builtin autoload -XU 	_zsh_highlight_call_widget .push-line -- "$@" builtin autoload -XU builtin autoload -XU 	(( $# > 0 )) && qlmanage -p $* &> /dev/null & builtin autoload -XU 	_zsh_highlight_call_widget .infer-next-history -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .backward-delete-word -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-indent -- "$@" builtin autoload -XU 	_zsh_highlight_call_widget .vi-unindent -- "$@" builtin autoload -XU 	GREP_COLOR="$HGREP_COLOR" ${0#h} --color='always' $argv builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	typeset -g _ZSH_AUTOSUGGEST_DISABLED
	_zsh_autosuggest_clear builtin autoload -XU builtin autoload -XU builtin autoload -X builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-replace -- "$@" 	echo $(rvm_prompt_info || rbenv_prompt_info || chruby_prompt_info) builtin autoload -XU builtin autoload -XU builtin autoload -XU 	if [[ $braces_stack[1] == $1 ]]
	then
		braces_stack=${braces_stack:1} 
		if (( $+2 ))
		then
			style=$2 
		fi
		return 0
	else
		style=unknown-token 
		return 1
	fi 	integer start=$1 end=$2 
	shift 2
	if (( in_alias ))
	then
		[[ $1 == unknown-token ]] && alias_style=unknown-token 
		return
	fi
	if (( in_param ))
	then
		if [[ $1 == unknown-token ]]
		then
			param_style=unknown-token 
		fi
		if [[ -n $param_style ]]
		then
			return
		fi
		param_style=$1 
		return
	fi
	(( start += buf_offset ))
	(( end += buf_offset ))
	list_highlights+=($start $end $1)  	[[ $WIDGET == zle-line-finish ]] && return
	_zsh_highlight_add_highlight $CURSOR $(( $CURSOR + 1 )) cursor 	local ZSH_SPECTRUM_TEXT=${ZSH_SPECTRUM_TEXT:-Arma virumque cano Troiae qui primus ab oris} 
	for code in {000..255}
	do
		print -P -- "$code: $FG[$code]$ZSH_SPECTRUM_TEXT%{$reset_color%}"
	done builtin autoload -XU 	_zsh_highlight_call_widget .vi-backward-blank-word-end -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-cmd-mode -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .push-line-or-edit -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-yank -- "$@" 	local -i retval
	_zsh_autosuggest_highlight_reset
	_zsh_autosuggest_disable $@
	retval=$? 
	_zsh_autosuggest_highlight_apply
	zle -R
	return $retval builtin autoload -XU 	_zsh_highlight_call_widget .backward-kill-word -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .exchange-point-and-mark -- "$@" 	_zsh_highlight_call_widget .select-in-shell-word -- "$@" 	if (( $+functions[_omz::update] ))
	then
		echo "${fg[yellow]}Note: \`$0\` is deprecated. Use \`omz update\` instead.$reset_color" >&2
	fi
	env ZSH="$ZSH" sh "$ZSH/tools/upgrade.sh"
	zmodload zsh/datetime
	echo "LAST_EPOCH=$(( EPOCHSECONDS / 60 / 60 / 24 ))" >| "${ZSH_CACHE_DIR}/.zsh-update"
	command rm -rf "$ZSH/log/update.lock" 	emulate -L zsh
	local suggestion
	if [[ -z "$2" || "$2" == "hup" ]]
	then
		IFS='' read -rd '' -u $1 suggestion
		zle autosuggest-suggest -- "$suggestion"
		exec {1}<&-
	fi
	zle -F "$1" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .down-line-or-search -- "$@" 	find "${@:-.}" -type f -name .DS_Store -delete 	if [[ $# -eq 0 ]]
	then
		error -1 'no input'
	fi
	local -a opts=() 
	while [[ $1 =~ ^- ]]
	do
		case ${1##-#} in
			(cmd|command) opts+='command'  ;;
			(s|shift) opts+='shift'  ;;
			(c|ctrl|control) opts+='control'  ;;
			(o|opt|option) opts+='option'  ;;
			(*) break ;;
		esac
		shift
	done
	local -a cmd=() 
	case $0 in
		(keycode) cmd+="key code ${argv}"  ;;
		(*) cmd+="keystroke ${(qqq)argv}"  ;;
	esac
	local -a modifiers=() 
	if [[ ${#opts} -gt 0 ]]
	then
		modifiers=(${^opts}' down') 
		cmd+="using {${(j:, :)modifiers}}" 
	fi
	tell -a "System Events" -p "Terminal" "$cmd"
	return 0 	[[ "${_ZSH_HIGHLIGHT_PRIOR_BUFFER:-}" != "$BUFFER" ]] builtin autoload -XU 	_zsh_highlight_main_highlighter_expand_path "$1"
	local expanded_path="$REPLY" tmp_path 
	REPLY=path 
	[[ -z $expanded_path ]] && return 1
	if [[ $expanded_path[1] == / ]]
	then
		tmp_path=$expanded_path 
	else
		tmp_path=$PWD/$expanded_path 
	fi
	tmp_path=$tmp_path:a 
	while [[ $tmp_path != / ]]
	do
		[[ -n ${(M)ZSH_HIGHLIGHT_DIRS_BLACKLIST:#$tmp_path} ]] && return 1
		tmp_path=$tmp_path:h 
	done
	[[ -L $expanded_path ]] && return 0
	[[ -e $expanded_path ]] && return 0
	local cdpath_dir
	for cdpath_dir in $cdpath
	do
		[[ -e "$cdpath_dir/$expanded_path" ]] && return 0
	done
	[[ ! -d ${expanded_path:h} ]] && return 1
	if (( has_end && (len == end_pos) )) && [[ $WIDGET != zle-line-finish ]]
	then
		local -a tmp
		tmp=(${expanded_path}*(N)) 
		(( $#tmp > 0 )) && REPLY=path_prefix  && return 0
	fi
	return 1 	_zsh_highlight_call_widget .copy-region-as-kill -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .select-a-blank-word -- "$@" 	zmodload zsh/system 2> /dev/null
	typeset -g _ZSH_AUTOSUGGEST_ASYNC_FD _ZSH_AUTOSUGGEST_CHILD_PID
	if [[ -n "$_ZSH_AUTOSUGGEST_ASYNC_FD" ]] && {
			true <&$_ZSH_AUTOSUGGEST_ASYNC_FD
		} 2> /dev/null
	then
		exec {_ZSH_AUTOSUGGEST_ASYNC_FD}<&-
		zle -F $_ZSH_AUTOSUGGEST_ASYNC_FD
		if [[ -n "$_ZSH_AUTOSUGGEST_CHILD_PID" ]]
		then
			if [[ -o MONITOR ]]
			then
				kill -TERM -$_ZSH_AUTOSUGGEST_CHILD_PID 2> /dev/null
			else
				kill -TERM $_ZSH_AUTOSUGGEST_CHILD_PID 2> /dev/null
			fi
		fi
	fi
	exec {_ZSH_AUTOSUGGEST_ASYNC_FD}< <(
		# Tell parent process our pid
		echo $sysparams[pid]

		# Fetch and print the suggestion
		local suggestion
		_zsh_autosuggest_fetch_suggestion "$1"
		echo -nE "$suggestion"
	)
	command true
	read _ZSH_AUTOSUGGEST_CHILD_PID <&$_ZSH_AUTOSUGGEST_ASYNC_FD
	zle -F "$_ZSH_AUTOSUGGEST_ASYNC_FD" _zsh_autosuggest_async_response builtin autoload -XU 	_zsh_highlight_call_widget .set-mark-command -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	local arg1=$1 i q=\' style 
	i=$arg[(ib:arg1+1:)$q] 
	reply=() 
	if [[ $zsyh_user_options[rcquotes] == on ]]
	then
		while [[ $arg[i+1] == "'" ]]
		do
			reply+=($(( start_pos + i - 1 )) $(( start_pos + i + 1 )) rc-quote) 
			(( i++ ))
			i=$arg[(ib:i+1:)$q] 
		done
	fi
	if [[ $arg[i] == "'" ]]
	then
		style=single-quoted-argument 
	else
		(( i-- ))
		style=single-quoted-argument-unclosed 
	fi
	reply=($(( start_pos + arg1 - 1 )) $(( start_pos + i )) $style $reply) 
	REPLY=$i  builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	env ZSH="$ZSH" sh "$ZSH/tools/upgrade.sh"
	zmodload zsh/datetime
	echo "LAST_EPOCH=$(( EPOCHSECONDS / 60 / 60 / 24 ))" >| "${ZSH_CACHE_DIR}/.zsh-update"
	command rm -rf "$ZSH/log/update.lock" builtin autoload -XU 	[[ $WIDGET == zle-line-finish ]] || _zsh_highlight_buffer_modified 	local -i N=${1:=25} 
	fc -l 1 | awk '(! /\.\//) { CMD[$2]++; count++; }
              END { for (a in CMD) {print CMD[a] " " CMD[a]*100/count "% " a;} }' | sort -n -r | head -n $N | column -t | nl builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-autosuggest-suggest -- "$@" 	(( $# )) || return 0
	local original_widget_name="$1" 
	shift
	if (( ${+widgets[$original_widget_name]} ))
	then
		zle $original_widget_name -- $@
	fi builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .capitalize-word -- "$@" 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-autosuggest-clear -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .beginning-of-history -- "$@" builtin autoload -XU 	local -i retval
	_zsh_autosuggest_highlight_reset
	_zsh_autosuggest_modify $@
	retval=$? 
	_zsh_autosuggest_highlight_apply
	zle -R
	return $retval 	if [[ -n "$1" ]]
	then
		fc -l 1 | grep -E $1 --color='always'
	else
		fc -l -40
	fi builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .push-input -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	typeset -g _ZSH_AUTOSUGGEST_LAST_HIGHLIGHT
	if (( $#POSTDISPLAY ))
	then
		typeset -g _ZSH_AUTOSUGGEST_LAST_HIGHLIGHT="$#BUFFER $(($#BUFFER + $#POSTDISPLAY)) $ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE" 
		region_highlight+=("$_ZSH_AUTOSUGGEST_LAST_HIGHLIGHT") 
	else
		unset _ZSH_AUTOSUGGEST_LAST_HIGHLIGHT
	fi 	local base_dir=$1 
	local name=$2 
	builtin test -f $base_dir/plugins/$name/$name.plugin.zsh || builtin test -f $base_dir/plugins/$name/_$name builtin autoload -XU 	_zsh_highlight_call_widget .vi-find-prev-char-skip -- "$@" builtin autoload -XU builtin autoload -XU 	local SHA
	SHA=$(__git_prompt_git rev-parse HEAD 2> /dev/null)  && echo "$ZSH_THEME_GIT_PROMPT_SHA_BEFORE$SHA$ZSH_THEME_GIT_PROMPT_SHA_AFTER" 	_zsh_highlight_call_widget .vi-yank-eol -- "$@" 	_zsh_highlight_call_widget .vi-kill-line -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_autosuggest_capture_setup
	zmodload zsh/parameter 2> /dev/null || return
	autoload +X _complete
	functions[_original_complete]=$functions[_complete] 
	_complete () {
		unset 'compstate[vared]'
		_original_complete "$@"
	}
	vared 1 builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-autosuggest-accept -- "$@" 	return 1 builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-quoted-insert -- "$@" 	_zsh_highlight_call_widget .vi-digit-or-beginning-of-line -- "$@" 	GIT_OPTIONAL_LOCKS=0 command git "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-repeat-search -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .kill-word -- "$@" builtin autoload -XU 	if ! colorize_check_requirements
	then
		return 1
	fi
	_cless () {
		local LESS="-R $LESS" 
		local LESSOPEN="| zsh -c 'source \"$ZSH_COLORIZE_PLUGIN_PATH\";         ZSH_COLORIZE_TOOL=$ZSH_COLORIZE_TOOL ZSH_COLORIZE_STYLE=$ZSH_COLORIZE_STYLE         colorize_cat %s 2> /dev/null'" 
		local LESSCLOSE="" 
		LESS="$LESS" LESSOPEN="$LESSOPEN" LESSCLOSE="$LESSCLOSE" less "$@"
	}
	if [ -t 0 ]
	then
		_cless "$@"
	else
		colorize_cat | _cless "$@"
	fi builtin autoload -XU 	_zsh_highlight_call_widget .visual-line-mode -- "$@" 	_zsh_highlight_call_widget .transpose-chars -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-reverse-menu-complete -- "$@" builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-_expand_alias -- "$@" builtin autoload -XU 	_zsh_highlight_call_widget .vi-insert-bol -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	local -a cmds subcmds
	cmds=('help:Usage information' 'update:Update Oh My Zsh' 'pr:Commands for Oh My Zsh Pull Requests') 
	if (( CURRENT == 2 ))
	then
		_describe 'command' cmds
	elif (( CURRENT == 3 ))
	then
		case "$words[2]" in
			(pr) subcmds=('test:Test a Pull Request' 'clean:Delete all Pull Request branches') 
				_describe 'command' subcmds ;;
		esac
	fi
	return 0 builtin autoload -XU builtin autoload -XU 	emulate -L zsh
	if [[ "${OSTYPE}" == darwin* ]] && (( ${+commands[pbcopy]} )) && (( ${+commands[pbpaste]} ))
	then
		clipcopy () {
			pbcopy < "${1:-/dev/stdin}"
		}
		clippaste () {
			pbpaste
		}
	elif [[ "${OSTYPE}" == (cygwin|msys)* ]]
	then
		clipcopy () {
			cat "${1:-/dev/stdin}" > /dev/clipboard
		}
		clippaste () {
			cat /dev/clipboard
		}
	elif [ -n "${WAYLAND_DISPLAY:-}" ] && (( ${+commands[wl-copy]} )) && (( ${+commands[wl-paste]} ))
	then
		clipcopy () {
			wl-copy < "${1:-/dev/stdin}"
		}
		clippaste () {
			wl-paste
		}
	elif [ -n "${DISPLAY:-}" ] && (( ${+commands[xclip]} ))
	then
		clipcopy () {
			xclip -in -selection clipboard < "${1:-/dev/stdin}"
		}
		clippaste () {
			xclip -out -selection clipboard
		}
	elif [ -n "${DISPLAY:-}" ] && (( ${+commands[xsel]} ))
	then
		clipcopy () {
			xsel --clipboard --input < "${1:-/dev/stdin}"
		}
		clippaste () {
			xsel --clipboard --output
		}
	elif (( ${+commands[lemonade]} ))
	then
		clipcopy () {
			lemonade copy < "${1:-/dev/stdin}"
		}
		clippaste () {
			lemonade paste
		}
	elif (( ${+commands[doitclient]} ))
	then
		clipcopy () {
			doitclient wclip < "${1:-/dev/stdin}"
		}
		clippaste () {
			doitclient wclip -r
		}
	elif (( ${+commands[win32yank]} ))
	then
		clipcopy () {
			win32yank -i < "${1:-/dev/stdin}"
		}
		clippaste () {
			win32yank -o
		}
	elif [[ $OSTYPE == linux-android* ]] && (( $+commands[termux-clipboard-set] ))
	then
		clipcopy () {
			termux-clipboard-set "${1:-/dev/stdin}"
		}
		clippaste () {
			termux-clipboard-get
		}
	elif [ -n "${TMUX:-}" ] && (( ${+commands[tmux]} ))
	then
		clipcopy () {
			tmux load-buffer "${1:--}"
		}
		clippaste () {
			tmux save-buffer -
		}
	elif [[ $(uname -r) = *icrosoft* ]]
	then
		clipcopy () {
			clip.exe < "${1:-/dev/stdin}"
		}
		clippaste () {
			powershell.exe -noprofile -command Get-Clipboard
		}
	else
		_retry_clipboard_detection_or_fail () {
			local clipcmd="${1}" 
			shift
			if detect-clipboard
			then
				"${clipcmd}" "$@"
			else
				print "${clipcmd}: Platform $OSTYPE not supported or xclip/xsel not installed" >&2
				return 1
			fi
		}
		clipcopy () {
			_retry_clipboard_detection_or_fail clipcopy "$@"
		}
		clippaste () {
			_retry_clipboard_detection_or_fail clippaste "$@"
		}
		return 1
	fi builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-pound-insert -- "$@" 	GREP_COLOR="$HGREP_COLOR" ${0#h} --color='always' $argv builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .magic-space -- "$@" builtin autoload -XU builtin autoload -XU 	local -i retval
	_zsh_autosuggest_highlight_reset
	_zsh_autosuggest_execute $@
	retval=$? 
	_zsh_autosuggest_highlight_apply
	zle -R
	return $retval 	_zsh_highlight_call_widget .digit-argument -- "$@" 	(( $+aliases[$1] )) && echo $aliases[$1] builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .up-line-or-history -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-self-insert -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	unset _ZSH_AUTOSUGGEST_DISABLED
	if (( $#BUFFER ))
	then
		_zsh_autosuggest_fetch
	fi builtin autoload -XU builtin autoload -XU 	local base_style=default i=$1 option_eligible=${2:-1} path_eligible=1 ret start style 
	local -a highlights
	local -a match mbegin mend
	local MATCH
	integer MBEGIN MEND
	case "$arg[i]" in
		('%') if [[ $arg[i+1] == '?' ]]
			then
				(( i += 2 ))
			fi ;;
		('-') if (( option_eligible ))
			then
				if [[ $arg[i+1] == - ]]
				then
					base_style=double-hyphen-option 
				else
					base_style=single-hyphen-option 
				fi
				path_eligible=0 
			fi ;;
		('=') if [[ $arg[i+1] == $'(' ]]
			then
				(( i += 2 ))
				_zsh_highlight_main_highlighter_highlight_list $(( start_pos + i - 1 )) S $has_end $arg[i,-1]
				ret=$? 
				(( i += REPLY ))
				highlights+=($(( start_pos + $1 - 1 )) $(( start_pos + i )) process-substitution $(( start_pos + $1 - 1 )) $(( start_pos + $1 + 1 )) process-substitution-delimiter $reply) 
				if (( ret == 0 ))
				then
					highlights+=($(( start_pos + i - 1 )) $(( start_pos + i )) process-substitution-delimiter) 
				fi
			fi ;;
	esac
	for ((; i <= $#arg ; i += 1 )) do
		case "$arg[$i]" in
			("\") (( i += 1 ))
				continue ;;
			("'") _zsh_highlight_main_highlighter_highlight_single_quote $i
				(( i = REPLY ))
				highlights+=($reply)  ;;
			('"') _zsh_highlight_main_highlighter_highlight_double_quote $i
				(( i = REPLY ))
				highlights+=($reply)  ;;
			('`') _zsh_highlight_main_highlighter_highlight_backtick $i
				(( i = REPLY ))
				highlights+=($reply)  ;;
			('$') if [[ $arg[i+1] != "'" ]]
				then
					path_eligible=0 
				fi
				if [[ $arg[i+1] == "'" ]]
				then
					_zsh_highlight_main_highlighter_highlight_dollar_quote $i
					(( i = REPLY ))
					highlights+=($reply) 
					continue
				elif [[ $arg[i+1] == $'(' ]]
				then
					start=$i 
					(( i += 2 ))
					_zsh_highlight_main_highlighter_highlight_list $(( start_pos + i - 1 )) S $has_end $arg[i,-1]
					ret=$? 
					(( i += REPLY ))
					highlights+=($(( start_pos + start - 1)) $(( start_pos + i )) command-substitution-unquoted $(( start_pos + start - 1)) $(( start_pos + start + 1)) command-substitution-delimiter-unquoted $reply) 
					if (( ret == 0 ))
					then
						highlights+=($(( start_pos + i - 1)) $(( start_pos + i )) command-substitution-delimiter-unquoted) 
					fi
					continue
				fi
				while [[ $arg[i+1] == [\^=~#+] ]]
				do
					(( i += 1 ))
				done
				if [[ $arg[i+1] == [*@#?$!-] ]]
				then
					(( i += 1 ))
				fi ;;
			([\<\>]) if [[ $arg[i+1] == $'(' ]]
				then
					start=$i 
					(( i += 2 ))
					_zsh_highlight_main_highlighter_highlight_list $(( start_pos + i - 1 )) S $has_end $arg[i,-1]
					ret=$? 
					(( i += REPLY ))
					highlights+=($(( start_pos + start - 1)) $(( start_pos + i )) process-substitution $(( start_pos + start - 1)) $(( start_pos + start + 1 )) process-substitution-delimiter $reply) 
					if (( ret == 0 ))
					then
						highlights+=($(( start_pos + i - 1)) $(( start_pos + i )) process-substitution-delimiter) 
					fi
					continue
				fi ;|
			(*) if $highlight_glob && [[ ${arg[$i]} =~ ^[*?] || ${arg:$i-1} =~ ^\<[0-9]*-[0-9]*\> ]]
				then
					highlights+=($(( start_pos + i - 1 )) $(( start_pos + i + $#MATCH - 1)) globbing) 
					(( i += $#MATCH - 1 ))
					path_eligible=0 
				else
					continue
				fi ;;
		esac
	done
	if (( path_eligible )) && _zsh_highlight_main_highlighter_check_path $arg[$1,-1]
	then
		base_style=$REPLY 
		_zsh_highlight_main_highlighter_highlight_path_separators $base_style
		highlights+=($reply) 
	fi
	highlights=($(( start_pos + $1 - 1 )) $end_pos $base_style $highlights) 
	_zsh_highlight_main_add_many_region_highlights $highlights builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .send-break -- "$@" builtin autoload -XU 	alias_value "$1" || echo "$1" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-put-before -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	if [[ -n "$(__git_prompt_git rev-list HEAD..origin/$(git_current_branch) 2> /dev/null)" ]]
	then
		echo "$ZSH_THEME_GIT_PROMPT_BEHIND"
	fi 	_zsh_highlight_call_widget .deactivate-region -- "$@" builtin autoload -XU 	typeset -A opts
	zparseopts -D -E -A opts - '-echo' '-line'
	if [[ ${+opts[--line]} -eq 1 ]]
	then
		set -- ${argv//;/'
'}
	fi
	local -a statements=() 
	while [[ "$1" =~ ^- ]]
	do
		case $1 in
			(-a) statements+='tell application "'$2'" to' 
				shift ;;
			(-p) statements+='tell process "'$2'" to' 
				shift ;;
			(--pref) statements+='tell '$2' preferences to' 
				shift ;;
			(--plist) statements+='return its properties'  ;;
		esac
		shift
	done
	[[ "$1" == "--" ]] && shift
	if [[ ${#statements} -eq 0 ]]
	then
		statements=('tell') 
	fi
	if [[ ${#argv} -gt 0 ]]
	then
		statements+=($argv) 
	fi
	if [[ ${#statements} -eq 0 ]]
	then
		error -1 'no commands to tell'
	fi
	if [[ ${+opts[--echo]} -eq 1 ]]
	then
		print -P -- "%F{6}%U${0}%u%f command: ${(qq)statements}"
	fi
	/usr/bin/osascript -e "$statements"
	return 0 builtin autoload -XU builtin autoload -XU builtin autoload -XU 	emulate -LR zsh
	setopt extendedglob
	local -i exit_code=0 
	local zparseopts_trap='return ${exit_code};' 
	local association_id
	local -a {,custom_}specs {generated,ignored}_names argument_values
	local -i generate_short_names=0 
	while [[ "$1" =~ ^[-] ]]
	do
		case "$1" in
			(-A) if [[ -z "$2" ]]
				then
					error -1 -m 'option needs a name of an associative array'
				fi
				association_id=$2 
				shift ;;
			(-s|--short-options) let generate_short_names=1 ;;
			(-c|--custom) if [[ -z "$2" ]]
				then
					error -1 -m 'option needs an argument' -u 'To map -o to --option, use:; ${0} --custom o:=-option'
				fi
				custom_specs+=(${(s:=:)2}) 
				shift ;;
			(-f) if [[ -z "$2" ]]
				then
					error -1 -m 'option needs an argument'
				fi
				custom_specs+=($2) 
				shift ;;
			(-i|--ignore) if [[ -z "$2" ]]
				then
					error -1 -m 'option needs an argument' -u 'To ignore --option, use:; ${0} --ignore option'
				fi
				ignored_names+=(--$2) 
				shift ;;
			(--) shift && break ;;
			(*) break ;;
		esac
		shift
	done
	if [[ $# -eq 0 ]]
	then
		return 1
	fi
	if [[ -z "$association_id" ]]
	then
		error -1 'association is not specified'
	fi
	local arg{,spec} {long,short}name
	for arg in ${(Pk)association_id}
	do
		argspec=":" 
		longname="${arg#-}" 
		specs+="${longname}${argspec}" 
		if [[ $generate_short_names -eq 1 ]] && [[ ${+ignored_names[(r)$arg]} -ne 1 ]]
		then
			shortname="${${arg#-##?}[1]}" 
			if [[ ${+generated_names[(r)$shortname]} -eq 1 ]]
			then
				shortname=${(U)shortname} 
			fi
			if [[ ${+generated_names[(r)$shortname]} -eq 1 ]]
			then
				continue
			fi
			generated_names+="$shortname" 
			specs+="${shortname}${argspec}=${longname}" 
		fi
	done
	if [[ ${#custom_specs} -gt 0 ]]
	then
		specs+=($custom_specs) 
	fi
	builtin zparseopts -D -E -K -M -A $association_id - $specs
	exit_code=$? 
	if [[ $exit_code -eq 0 ]]
	then
		zparseopts_trap="set -- ${(@q)argv};" 
	fi
	trap "$zparseopts_trap" EXIT builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-up-case -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .beginning-of-line-hist -- "$@" builtin autoload -XU builtin autoload -XU 	if [[ -n "$(__git_prompt_git rev-list origin/$(git_current_branch)..HEAD 2> /dev/null)" ]]
	then
		echo "$ZSH_THEME_GIT_PROMPT_AHEAD"
	fi builtin autoload -XU builtin autoload -XU 	print -r -- "${fg[$0]}${argv}${fg[default]}"
	return $(( $# == 0 )) builtin autoload -XU 	if _zsh_highlight_main__type "$1"
	then
		[[ $REPLY != none ]]
	else
		return 2
	fi builtin autoload -XU builtin autoload -XU 	local command="cd \\"$PWD\\"; clear" 
	(( $# > 0 )) && command="${command}; $*" 
	local the_app=$(_omz_osx_get_frontmost_app) 
	if [[ "$the_app" == 'iTerm' ]]
	then
		osascript 2> /dev/null <<EOF
      tell application "iTerm" to activate

      tell application "System Events"
        tell process "iTerm"
          tell menu item "Split Horizontally With Current Profile" of menu "Shell" of menu bar item "Shell" of menu bar 1
            click
          end tell
        end tell
        keystroke "${command} 
"
      end tell
EOF
	elif [[ "$the_app" == 'iTerm2' ]]
	then
		osascript <<EOF
      tell application "iTerm2"
        tell current session of first window
          set newSession to (split horizontally with same profile)
          tell newSession
            write text "${command}"
            select
          end tell
        end tell
      end tell
EOF
	elif [[ "$the_app" == 'Hyper' ]]
	then
		osascript > /dev/null <<EOF
    tell application "System Events"
      tell process "Hyper"
        tell menu item "Split Horizontally" of menu "Shell" of menu bar 1
          click
        end tell
      end tell
      delay 1
      keystroke "${command} 
"
    end tell
EOF
	else
		echo "$0: unsupported terminal app: $the_app" >&2
		return 1
	fi 	if [[ $# -eq 0 ]]
	then
		return 1
	fi
	local filename="$(date -j +'%F_%T')_${1}" 
	if ! (
			type -- $1 &> /dev/null
		)
	then
		return 1
	fi
	$argv &> ~log/Commands/$filename
	return $? builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	print -r -- "${fg[$0]}${argv}${fg[default]}"
	return $(( $# == 0 )) builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-list-choices -- "$@" builtin autoload -XU 	_zsh_highlight_call_widget .backward-char -- "$@" 	_zsh_highlight_call_widget .down-case-word -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-_next_tags -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-autosuggest-fetch -- "$@" builtin autoload -XU 	local APP_NAME=Music sw_vers=$(sw_vers -productVersion 2>/dev/null) 
	autoload is-at-least
	if [[ -z "$sw_vers" ]] || is-at-least 10.15 $sw_vers
	then
		if [[ $0 = itunes ]]
		then
			echo The itunes function name is deprecated. Use \'music\' instead. >&2
			return 1
		fi
	else
		APP_NAME=iTunes 
	fi
	local opt=$1 playlist=$2 
	(( $# > 0 )) && shift
	case "$opt" in
		(launch | play | pause | stop | rewind | resume | quit)  ;;
		(mute) opt="set mute to true"  ;;
		(unmute) opt="set mute to false"  ;;
		(next | previous) opt="$opt track"  ;;
		(vol) local new_volume volume=$(osascript -e "tell application \"$APP_NAME\" to get sound volume") 
			if [[ $# -eq 0 ]]
			then
				echo "Current volume is ${volume}."
				return 0
			fi
			case $1 in
				(up) new_volume=$((volume + 10 < 100 ? volume + 10 : 100))  ;;
				(down) new_volume=$((volume - 10 > 0 ? volume - 10 : 0))  ;;
				(<0-100>) new_volume=$1  ;;
				(*) echo "'$1' is not valid. Expected <0-100>, up or down."
					return 1 ;;
			esac
			opt="set sound volume to ${new_volume}"  ;;
		(playlist) if [[ -n "$playlist" ]]
			then
				osascript 2> /dev/null <<EOF
          tell application "$APP_NAME"
            set new_playlist to "$playlist" as string
            play playlist new_playlist
          end tell
EOF
				if [[ $? -eq 0 ]]
				then
					opt="play" 
				else
					opt="stop" 
				fi
			else
				opt="set allPlaylists to (get name of every playlist)" 
			fi ;;
		(playing | status) local currenttrack currentartist state=$(osascript -e "tell application \"$APP_NAME\" to player state as string") 
			if [[ "$state" = "playing" ]]
			then
				currenttrack=$(osascript -e "tell application \"$APP_NAME\" to name of current track as string") 
				currentartist=$(osascript -e "tell application \"$APP_NAME\" to artist of current track as string") 
				echo -E "Listening to ${fg[yellow]}${currenttrack}${reset_color} by ${fg[yellow]}${currentartist}${reset_color}"
			else
				echo "$APP_NAME is $state"
			fi
			return 0 ;;
		(shuf | shuff | shuffle) local state=$1 
			if [[ -n "$state" && "$state" != (on|off|toggle) ]]
			then
				print "Usage: $0 shuffle [on|off|toggle]. Invalid option."
				return 1
			fi
			case "$state" in
				(on | off) osascript > /dev/null 2>&1 <<EOF
            tell application "System Events" to perform action "AXPress" of (menu item "${state}" of menu "Shuffle" of menu item "Shuffle" of menu "Controls" of menu bar item "Controls" of menu bar 1 of application process "iTunes" )
EOF
					return 0 ;;
				(toggle | *) osascript > /dev/null 2>&1 <<EOF
            tell application "System Events" to perform action "AXPress" of (button 2 of process "iTunes"'s window "iTunes"'s scroll area 1)
EOF
					return 0 ;;
			esac ;;
		("" | -h | --help) echo "Usage: $0 <option>"
			echo "option:"
			echo "	-h|--help	Show this message and exit"
			echo "	launch|play|pause|stop|rewind|resume|quit"
			echo "	mute|unmute	Mute or unmute $APP_NAME"
			echo "	next|previous	Play next or previous track"
			echo "	shuf|shuffle [on|off|toggle]	Set shuffled playback. Default: toggle. Note: toggle doesn't support the MiniPlayer."
			echo "	vol [0-100|up|down]	Get or set the volume. 0 to 100 sets the volume. 'up' / 'down' increases / decreases by 10 points. No argument displays current volume."
			echo "	playing|status	Show what song is currently playing in Music."
			echo "	playlist [playlist name]	 Play specific playlist"
			return 0 ;;
		(*) print "Unknown option: $opt"
			return 1 ;;
	esac
	osascript -e "tell application \"$APP_NAME\" to $opt" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-_expand_word -- "$@" builtin autoload -XU 	local cmd
	case $# in
		(0) cmd="get autohide"  ;;
		(1) cmd="set autohide to $1"  ;;
	esac
	tell -a "System Events" --pref "Dock" "$cmd" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_buffer_modified builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-complete-word -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	return 1 builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_buffer_modified builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	:
	_zsh_highlight 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-expand-or-complete-prefix -- "$@" builtin autoload -XU 	_zsh_highlight_call_widget .vi-change-whole-line -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .accept-and-menu-complete -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-down-line-or-beginning-search -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	(( $# == 1 )) || print -r -- "zsh-syntax-highlighting: BUG: _zsh_highlight_main_highlighter_expand_path: called without argument" >&2
	setopt localoptions nonomatch
	unset REPLY
	: ${REPLY:=${(Q)${~1}}} builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	integer -r aliases_allowed=${2-1} 
	integer may_cache=1 
	if (( $+_zsh_highlight_main__command_type_cache ))
	then
		REPLY=$_zsh_highlight_main__command_type_cache[(e)$1] 
		if [[ -n "$REPLY" ]]
		then
			return
		fi
	fi
	if (( $#options_to_set ))
	then
		setopt localoptions $options_to_set
	fi
	unset REPLY
	if zmodload -e zsh/parameter
	then
		if (( $+aliases[(e)$1] ))
		then
			may_cache=0 
		fi
		if (( $+aliases[(e)$1] )) && (( aliases_allowed ))
		then
			REPLY=alias 
		elif [[ $1 == *.* && -n ${1%.*} ]] && (( $+saliases[(e)${1##*.}] ))
		then
			REPLY='suffix alias' 
		elif (( $reswords[(Ie)$1] ))
		then
			REPLY=reserved 
		elif (( $+functions[(e)$1] ))
		then
			REPLY=function 
		elif (( $+builtins[(e)$1] ))
		then
			REPLY=builtin 
		elif (( $+commands[(e)$1] ))
		then
			REPLY=command 
		elif {
				[[ $1 != */* ]] || is-at-least 5.3
			} && ! (
				builtin type -w -- "$1"
			) > /dev/null 2>&1
		then
			REPLY=none 
		fi
	fi
	if ! (( $+REPLY ))
	then
		REPLY="${$(:; (( aliases_allowed )) || unalias -- "$1" 2>/dev/null; LC_ALL=C builtin type -w -- "$1" 2>/dev/null)##*: }" 
		if [[ $REPLY == 'alias' ]]
		then
			may_cache=0 
		fi
	fi
	if (( may_cache )) && (( $+_zsh_highlight_main__command_type_cache ))
	then
		_zsh_highlight_main__command_type_cache[(e)$1]=$REPLY 
	fi
	[[ -n $REPLY ]]
	return $? builtin autoload -XU 	ZSH="$ZSH" sh "$ZSH/tools/upgrade.sh"
	update_last_updated_file builtin autoload -XU 	print -r -- "${fg[$0]}${argv}${fg[default]}"
	return $(( $# == 0 )) builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-menu-expand-or-complete -- "$@" 	emulate -L zsh
	setopt EXTENDED_GLOB
	local prefix="${1//(#m)[\*?[\]<>()|^~#]/\$MATCH}" 
	local pattern="$prefix*" 
	if [[ -n $ZSH_AUTOSUGGEST_HISTORY_IGNORE ]]
	then
		pattern="($pattern)~($ZSH_AUTOSUGGEST_HISTORY_IGNORE)" 
	fi
	local history_match_keys
	history_match_keys=(${(k)history[(R)$~pattern]}) 
	local histkey="${history_match_keys[1]}" 
	local prev_cmd="$(_zsh_autosuggest_escape_command "${history[$((HISTCMD-1))]}")" 
	for key in "${(@)history_match_keys[1,200]}"
	do
		[[ $key -gt 1 ]] || break
		if [[ "${history[$((key - 1))]}" == "$prev_cmd" ]]
		then
			histkey="$key" 
			break
		fi
	done
	typeset -g suggestion="$history[$histkey]"  builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	emulate -L zsh
	local -a hooktypes
	hooktypes=(chpwd precmd preexec periodic zshaddhistory zshexit zsh_directory_name) 
	local usage="Usage: add-zsh-hook hook function
Valid hooks are:
  $hooktypes" 
	local opt
	local -a autoopts
	integer del list help
	while getopts "dDhLUzk" opt
	do
		case $opt in
			(d) del=1  ;;
			(D) del=2  ;;
			(h) help=1  ;;
			(L) list=1  ;;
			([Uzk]) autoopts+=(-$opt)  ;;
			(*) return 1 ;;
		esac
	done
	shift $(( OPTIND - 1 ))
	if (( list ))
	then
		typeset -mp "(${1:-${(@j:|:)hooktypes}})_functions"
		return $?
	elif (( help || $# != 2 || ${hooktypes[(I)$1]} == 0 ))
	then
		print -u$(( 2 - help )) $usage
		return $(( 1 - help ))
	fi
	local hook="${1}_functions" 
	local fn="$2" 
	if (( del ))
	then
		if (( ${(P)+hook} ))
		then
			if (( del == 2 ))
			then
				set -A $hook ${(P)hook:#${~fn}}
			else
				set -A $hook ${(P)hook:#$fn}
			fi
			if (( ! ${(P)#hook} ))
			then
				unset $hook
			fi
		fi
	else
		if (( ${(P)+hook} ))
		then
			if (( ${${(P)hook}[(I)$fn]} == 0 ))
			then
				typeset -ga $hook
				set -A $hook ${(P)hook} $fn
			fi
		else
			typeset -ga $hook
			set -A $hook $fn
		fi
		autoload $autoopts -- $fn
	fi builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	echoti rmkx 	_zsh_highlight_call_widget .redo -- "$@" 	_zsh_highlight_call_widget .vi-rev-repeat-search -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .history-incremental-pattern-search-backward -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -X builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-goto-mark-line -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	BUFFER="$BUFFER$POSTDISPLAY" 
	unset POSTDISPLAY
	_zsh_autosuggest_invoke_original_widget "accept-line" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	fc -l 1 | awk '{ CMD[$2]++; count++; } END { for (a in CMD) print CMD[a] " " CMD[a]*100/count "% " a }' | grep -v "./" | sort -nr | head -n20 | column -c3 -s " " -t | nl builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	pbpaste 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-_list_expansions -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -X builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-_read_comp -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	header 'tldr'
	/usr/local/bin/tldr $argv
	echo
	header 'tealdeer'
	/usr/local/bin/tealdeer $argv builtin autoload -XU 	local datafile="${_Z_DATA:-$HOME/.z}" 
	[ -h "$datafile" ] && datafile=$(readlink "$datafile") 
	[ -z "$_Z_OWNER" -a -f "$datafile" -a ! -O "$datafile" ] && return
	_z_dirs () {
		local line
		while read line
		do
			[ -d "${line%%\|*}" ] && echo "$line"
		done < "$datafile"
		return 0
	}
	if [ "$1" = "--add" ]
	then
		shift
		[ "$*" = "$HOME" ] && return
		local exclude
		for exclude in "${_Z_EXCLUDE_DIRS[@]}"
		do
			case "$*" in
				("$exclude*") return ;;
			esac
		done
		local tempfile="$datafile.$RANDOM" 
		_z_dirs | awk -v path="$*" -v now="$(date +%s)" -F"|" '
            BEGIN {
                rank[path] = 1
                time[path] = now
            }
            $2 >= 1 {
                # drop ranks below 1
                if( $1 == path ) {
                    rank[$1] = $2 + 1
                    time[$1] = now
                } else {
                    rank[$1] = $2
                    time[$1] = $3
                }
                count += $2
            }
            END {
                if( count > 9000 ) {
                    # aging
                    for( x in rank ) print x "|" 0.99*rank[x] "|" time[x]
                } else for( x in rank ) print x "|" rank[x] "|" time[x]
            }
        ' 2> /dev/null >| "$tempfile"
		if [ $? -ne 0 -a -f "$datafile" ]
		then
			env rm -f "$tempfile"
		else
			[ "$_Z_OWNER" ] && chown $_Z_OWNER:"$(id -ng $_Z_OWNER)" "$tempfile"
			env mv -f "$tempfile" "$datafile" || env rm -f "$tempfile"
		fi
	elif [ "$1" = "--complete" -a -s "$datafile" ]
	then
		_z_dirs | awk -v q="$2" -F"|" '
            BEGIN {
                q = substr(q, 3)
                if( q == tolower(q) ) imatch = 1
                gsub(/ /, ".*", q)
            }
            {
                if( imatch ) {
                    if( tolower($1) ~ q ) print $1
                } else if( $1 ~ q ) print $1
            }
        ' 2> /dev/null
	else
		local echo fnd last list opt typ
		while [ "$1" ]
		do
			case "$1" in
				(--) while [ "$1" ]
					do
						shift
						fnd="$fnd${fnd:+ }$1" 
					done ;;
				(-*) opt=${1:1} 
					while [ "$opt" ]
					do
						case ${opt:0:1} in
							(c) fnd="^$PWD $fnd"  ;;
							(e) echo=1  ;;
							(h) echo "${_Z_CMD:-z} [-cehlrtx] args" >&2
								return ;;
							(l) list=1  ;;
							(r) typ="rank"  ;;
							(t) typ="recent"  ;;
							(x) sed -i -e "\:^${PWD}|.*:d" "$datafile" ;;
						esac
						opt=${opt:1} 
					done ;;
				(*) fnd="$fnd${fnd:+ }$1"  ;;
			esac
			last=$1 
			[ "$#" -gt 0 ] && shift
		done
		[ "$fnd" -a "$fnd" != "^$PWD " ] || list=1 
		case "$last" in
			(/*) [ -z "$list" -a -d "$last" ] && builtin cd "$last" && return ;;
		esac
		[ -f "$datafile" ] || return
		local cd
		cd="$( < <( _z_dirs ) awk -v t="$(date +%s)" -v list="$list" -v typ="$typ" -v q="$fnd" -F"|" '
            function frecent(rank, time) {
                # relate frequency and time
                dx = t - time
                if( dx < 3600 ) return rank * 4
                if( dx < 86400 ) return rank * 2
                if( dx < 604800 ) return rank / 2
                return rank / 4
            }
            function output(matches, best_match, common) {
                # list or return the desired directory
                if( list ) {
                    cmd = "sort -g >&2"
                    for( x in matches ) {
                        if( matches[x] ) {
                            printf "%-10s %s
", matches[x], x | cmd
                        }
                    }
                    if( common ) {
                        printf "%-10s %s
", "common:", common > "/dev/stderr"
                    }
                } else {
                    if( common ) best_match = common
                    print best_match
                }
            }
            function common(matches) {
                # find the common root of a list of matches, if it exists
                for( x in matches ) {
                    if( matches[x] && (!short || length(x) < length(short)) ) {
                        short = x
                    }
                }
                if( short == "/" ) return
                for( x in matches ) if( matches[x] && index(x, short) != 1 ) {
                    return
                }
                return short
            }
            BEGIN {
                gsub(" ", ".*", q)
                hi_rank = ihi_rank = -9999999999
            }
            {
                if( typ == "rank" ) {
                    rank = $2
                } else if( typ == "recent" ) {
                    rank = $3 - t
                } else rank = frecent($2, $3)
                if( $1 ~ q ) {
                    matches[$1] = rank
                } else if( tolower($1) ~ tolower(q) ) imatches[$1] = rank
                if( matches[$1] && matches[$1] > hi_rank ) {
                    best_match = $1
                    hi_rank = matches[$1]
                } else if( imatches[$1] && imatches[$1] > ihi_rank ) {
                    ibest_match = $1
                    ihi_rank = imatches[$1]
                }
            }
            END {
                # prefer case sensitive
                if( best_match ) {
                    output(matches, best_match, common(matches))
                } else if( ibest_match ) {
                    output(imatches, ibest_match, common(imatches))
                }
            }
        ')" 
		[ $? -eq 0 ] && [ "$cd" ] && {
			if [ "$echo" ]
			then
				echo "$cd"
			else
				builtin cd "$cd"
			fi
		}
	fi builtin autoload -XU builtin autoload -XU builtin autoload -XU 	local -aU insecure_dirs
	insecure_dirs=(${(f@):-"$(compaudit 2>/dev/null)"}) 
	[[ -z "${insecure_dirs}" ]] && return
	print "[oh-my-zsh] Insecure completion-dependent directories detected:"
	ls -ld "${(@)insecure_dirs}"
	cat <<EOD

[oh-my-zsh] For safety, we will not load completions from these directories until
[oh-my-zsh] you fix their permissions and ownership and restart zsh.
[oh-my-zsh] See the above list for directories with group or other writability.

[oh-my-zsh] To fix your permissions you can do so by disabling
[oh-my-zsh] the write permission of "group" and "others" and making sure that the
[oh-my-zsh] owner of these directories is either root or your current user.
[oh-my-zsh] The following command may help:
[oh-my-zsh]     compaudit | xargs chmod g-w,o-w

[oh-my-zsh] If the above didn't help or you want to skip the verification of
[oh-my-zsh] insecure directories you can set the variable ZSH_DISABLE_COMPFIX to
[oh-my-zsh] "true" before oh-my-zsh is sourced in your zshrc file.

EOD builtin autoload -XU 	setopt localoptions EXTENDED_GLOB
	echo -E "${1//(#m)[\"\'\()\[\]|*?~]/\$MATCH}" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .history-search-backward -- "$@" builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-_bash_list-choices -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	local -i retval
	_zsh_autosuggest_highlight_reset
	_zsh_autosuggest_suggest $@
	retval=$? 
	_zsh_autosuggest_highlight_apply
	zle -R
	return $retval builtin autoload -XU 	_zsh_highlight_call_widget .copy-prev-word -- "$@" 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-zle-line-finish -- "$@" builtin autoload -X builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-_correct_filename -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .auto-suffix-remove -- "$@" builtin autoload -XU 	setopt localoptions extended_glob
	[[ $arg == [[:alpha:]_][[:alnum:]_]#(|\[*\])(|[+])=* ]] || [[ $arg == [0-9]##(|[+])=* ]] builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .transpose-words -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .up-history -- "$@" builtin autoload -XU 	__git_prompt_git config user.email 2> /dev/null builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .beginning-of-line -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .redisplay -- "$@" 	local remote ahead behind git_remote_status git_remote_status_detailed
	remote=${$(__git_prompt_git rev-parse --verify ${hook_com[branch]}@{upstream} --symbolic-full-name 2>/dev/null)/refs\/remotes\/} 
	if [[ -n ${remote} ]]
	then
		ahead=$(__git_prompt_git rev-list ${hook_com[branch]}@{upstream}..HEAD 2>/dev/null | wc -l) 
		behind=$(__git_prompt_git rev-list HEAD..${hook_com[branch]}@{upstream} 2>/dev/null | wc -l) 
		if [[ $ahead -eq 0 ]] && [[ $behind -eq 0 ]]
		then
			git_remote_status="$ZSH_THEME_GIT_PROMPT_EQUAL_REMOTE" 
		elif [[ $ahead -gt 0 ]] && [[ $behind -eq 0 ]]
		then
			git_remote_status="$ZSH_THEME_GIT_PROMPT_AHEAD_REMOTE" 
			git_remote_status_detailed="$ZSH_THEME_GIT_PROMPT_AHEAD_REMOTE_COLOR$ZSH_THEME_GIT_PROMPT_AHEAD_REMOTE$((ahead))%{$reset_color%}" 
		elif [[ $behind -gt 0 ]] && [[ $ahead -eq 0 ]]
		then
			git_remote_status="$ZSH_THEME_GIT_PROMPT_BEHIND_REMOTE" 
			git_remote_status_detailed="$ZSH_THEME_GIT_PROMPT_BEHIND_REMOTE_COLOR$ZSH_THEME_GIT_PROMPT_BEHIND_REMOTE$((behind))%{$reset_color%}" 
		elif [[ $ahead -gt 0 ]] && [[ $behind -gt 0 ]]
		then
			git_remote_status="$ZSH_THEME_GIT_PROMPT_DIVERGED_REMOTE" 
			git_remote_status_detailed="$ZSH_THEME_GIT_PROMPT_AHEAD_REMOTE_COLOR$ZSH_THEME_GIT_PROMPT_AHEAD_REMOTE$((ahead))%{$reset_color%}$ZSH_THEME_GIT_PROMPT_BEHIND_REMOTE_COLOR$ZSH_THEME_GIT_PROMPT_BEHIND_REMOTE$((behind))%{$reset_color%}" 
		fi
		if [[ -n $ZSH_THEME_GIT_PROMPT_REMOTE_STATUS_DETAILED ]]
		then
			git_remote_status="$ZSH_THEME_GIT_PROMPT_REMOTE_STATUS_PREFIX$remote$git_remote_status_detailed$ZSH_THEME_GIT_PROMPT_REMOTE_STATUS_SUFFIX" 
		fi
		echo $git_remote_status
	fi builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	osascript 2> /dev/null <<EOF
    tell application "System Events"
      name of first item of (every process whose frontmost is true)
    end tell
EOF builtin autoload -XU builtin autoload -XU builtin autoload -XU 	if (( ${+ZSH_AUTOSUGGEST_MANUAL_REBIND} ))
	then
		add-zsh-hook -d precmd _zsh_autosuggest_start
	fi
	_zsh_autosuggest_bind_widgets builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-menu-complete -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .forward-char -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	return 1 builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .copy-prev-shell-word -- "$@" builtin autoload -XU builtin autoload -XU 	local compl
	read -l compl
	reply=(${(f)"$(_z --complete "$compl")"})  builtin autoload -XU builtin autoload -XU 	if ! colorize_check_requirements
	then
		return 1
	fi
	if [ -z "$ZSH_COLORIZE_STYLE" ]
	then
		ZSH_COLORIZE_STYLE="emacs" 
	fi
	if [ $# -eq 0 ]
	then
		if [[ "$ZSH_COLORIZE_TOOL" == "pygmentize" ]]
		then
			pygmentize -O style="$ZSH_COLORIZE_STYLE" -g
		else
			chroma --style="$ZSH_COLORIZE_STYLE" --formatter="${ZSH_COLORIZE_CHROMA_FORMATTER:-terminal}"
		fi
		return $?
	fi
	local FNAME lexer
	for FNAME in "$@"
	do
		if [[ "$ZSH_COLORIZE_TOOL" == "pygmentize" ]]
		then
			lexer=$(pygmentize -N "$FNAME") 
			if [[ $lexer != text ]]
			then
				pygmentize -O style="$ZSH_COLORIZE_STYLE" -l "$lexer" "$FNAME"
			else
				pygmentize -O style="$ZSH_COLORIZE_STYLE" -g "$FNAME"
			fi
		else
			chroma --style="$ZSH_COLORIZE_STYLE" --formatter="${ZSH_COLORIZE_CHROMA_FORMATTER:-terminal}" "$FNAME"
		fi
	done builtin autoload -XU 	local app_name
	case "$words[1]" in
		(itunes) app_name="iTunes"  ;;
		(music | *) app_name="Music"  ;;
	esac
	local -a cmds subcmds
	cmds=("launch:Launch the ${app_name} app" "play:Play ${app_name}" "pause:Pause ${app_name}" "stop:Stop ${app_name}" "rewind:Rewind ${app_name}" "resume:Resume ${app_name}" "quit:Quit ${app_name}" "mute:Mute the ${app_name} app" "unmute:Unmute the ${app_name} app" "next:Skip to the next song" "previous:Skip to the previous song" "vol:Change the volume" "playlist:Play a specific playlist" {playing,status}":Show what song is currently playing" {shuf,shuff,shuffle}":Set shuffle mode" {-h,--help}":Show usage") 
	if (( CURRENT == 2 ))
	then
		_describe 'command' cmds
	elif (( CURRENT == 3 ))
	then
		case "$words[2]" in
			(vol) subcmds=('up:Raise the volume' 'down:Lower the volume') 
				_describe 'command' subcmds ;;
			(shuf | shuff | shuffle) subcmds=('on:Switch on shuffle mode' 'off:Switch off shuffle mode' 'toggle:Toggle shuffle mode (default)') 
				_describe 'command' subcmds ;;
		esac
	elif (( CURRENT == 4 ))
	then
		case "$words[2]" in
			(playlist) subcmds=('play:Play the playlist (default)' 'stop:Stop the playlist') 
				_describe 'command' subcmds ;;
		esac
	fi
	return 0 	_zsh_highlight_call_widget .vi-change-eol -- "$@" 	print -r -- "${fg[$0]}${argv}${fg[default]}"
	return $(( $# == 0 )) builtin autoload -XU 	_zsh_highlight_call_widget .vi-add-eol -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	if [[ -n "$(__git_prompt_git show-ref origin/$(git_current_branch) 2> /dev/null)" ]]
	then
		echo "$ZSH_THEME_GIT_PROMPT_REMOTE_EXISTS"
	else
		echo "$ZSH_THEME_GIT_PROMPT_REMOTE_MISSING"
	fi builtin autoload -X builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-end-of-line -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	emulate -L zsh
	local IFS=".-" min_cnt=0 ver_cnt=0 part min_ver version order 
	min_ver=(${=1}) 
	version=(${=2:-$ZSH_VERSION} 0) 
	while (( $min_cnt <= ${#min_ver} ))
	do
		while [[ "$part" != <-> ]]
		do
			(( ++ver_cnt > ${#version} )) && return 0
			if [[ ${version[ver_cnt]} = *[0-9][^0-9]* ]]
			then
				order=(${version[ver_cnt]} ${min_ver[ver_cnt]}) 
				if [[ ${version[ver_cnt]} = <->* ]]
				then
					[[ $order != ${${(On)order}} ]] && return 1
				else
					[[ $order != ${${(O)order}} ]] && return 1
				fi
				[[ $order[1] != $order[2] ]] && return 0
			fi
			part=${version[ver_cnt]##*[^0-9]} 
		done
		while true
		do
			(( ++min_cnt > ${#min_ver} )) && return 0
			[[ ${min_ver[min_cnt]} = <-> ]] && break
		done
		(( part > min_ver[min_cnt] )) && return 0
		(( part < min_ver[min_cnt] )) && return 1
		part='' 
	done builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .select-in-blank-word -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .execute-last-named-cmd -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .backward-delete-char -- "$@" 	local open_cmd
	case "$OSTYPE" in
		(darwin*) open_cmd='open'  ;;
		(cygwin*) open_cmd='cygstart'  ;;
		(linux*) [[ "$(uname -r)" != *icrosoft* ]] && open_cmd='nohup xdg-open'  || {
				open_cmd='cmd.exe /c start ""' 
				[[ -e "$1" ]] && {
					1="$(wslpath -w "${1:a}")"  || return 1
				}
			} ;;
		(msys*) open_cmd='start ""'  ;;
		(*) echo "Platform $OSTYPE not supported"
			return 1 ;;
	esac
	${=open_cmd} "$@" &> /dev/null builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-_correct_word -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU 	for 1 2 3
	do
		_zsh_highlight_main_add_region_highlight $1 $2 $3
	done builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -X builtin autoload -XU builtin autoload -XU builtin autoload -XU 	local APP_NAME=Music sw_vers=$(sw_vers -productVersion 2>/dev/null) 
	autoload is-at-least
	if [[ -z "$sw_vers" ]] || is-at-least 10.15 $sw_vers
	then
		if [[ $0 = itunes ]]
		then
			echo The itunes function name is deprecated. Use \'music\' instead. >&2
			return 1
		fi
	else
		APP_NAME=iTunes 
	fi
	local opt=$1 playlist=$2 
	(( $# > 0 )) && shift
	case "$opt" in
		(launch | play | pause | stop | rewind | resume | quit)  ;;
		(mute) opt="set mute to true"  ;;
		(unmute) opt="set mute to false"  ;;
		(next | previous) opt="$opt track"  ;;
		(vol) local new_volume volume=$(osascript -e "tell application \"$APP_NAME\" to get sound volume") 
			if [[ $# -eq 0 ]]
			then
				echo "Current volume is ${volume}."
				return 0
			fi
			case $1 in
				(up) new_volume=$((volume + 10 < 100 ? volume + 10 : 100))  ;;
				(down) new_volume=$((volume - 10 > 0 ? volume - 10 : 0))  ;;
				(<0-100>) new_volume=$1  ;;
				(*) echo "'$1' is not valid. Expected <0-100>, up or down."
					return 1 ;;
			esac
			opt="set sound volume to ${new_volume}"  ;;
		(playlist) if [[ -n "$playlist" ]]
			then
				osascript 2> /dev/null <<EOF
          tell application "$APP_NAME"
            set new_playlist to "$playlist" as string
            play playlist new_playlist
          end tell
EOF
				if [[ $? -eq 0 ]]
				then
					opt="play" 
				else
					opt="stop" 
				fi
			else
				opt="set allPlaylists to (get name of every playlist)" 
			fi ;;
		(playing | status) local currenttrack currentartist state=$(osascript -e "tell application \"$APP_NAME\" to player state as string") 
			if [[ "$state" = "playing" ]]
			then
				currenttrack=$(osascript -e "tell application \"$APP_NAME\" to name of current track as string") 
				currentartist=$(osascript -e "tell application \"$APP_NAME\" to artist of current track as string") 
				echo -E "Listening to ${fg[yellow]}${currenttrack}${reset_color} by ${fg[yellow]}${currentartist}${reset_color}"
			else
				echo "$APP_NAME is $state"
			fi
			return 0 ;;
		(shuf | shuff | shuffle) local state=$1 
			if [[ -n "$state" && "$state" != (on|off|toggle) ]]
			then
				print "Usage: $0 shuffle [on|off|toggle]. Invalid option."
				return 1
			fi
			case "$state" in
				(on | off) osascript > /dev/null 2>&1 <<EOF
            tell application "System Events" to perform action "AXPress" of (menu item "${state}" of menu "Shuffle" of menu item "Shuffle" of menu "Controls" of menu bar item "Controls" of menu bar 1 of application process "iTunes" )
EOF
					return 0 ;;
				(toggle | *) osascript > /dev/null 2>&1 <<EOF
            tell application "System Events" to perform action "AXPress" of (button 2 of process "iTunes"'s window "iTunes"'s scroll area 1)
EOF
					return 0 ;;
			esac ;;
		("" | -h | --help) echo "Usage: $0 <option>"
			echo "option:"
			echo "	-h|--help	Show this message and exit"
			echo "	launch|play|pause|stop|rewind|resume|quit"
			echo "	mute|unmute	Mute or unmute $APP_NAME"
			echo "	next|previous	Play next or previous track"
			echo "	shuf|shuffle [on|off|toggle]	Set shuffled playback. Default: toggle. Note: toggle doesn't support the MiniPlayer."
			echo "	vol [0-100|up|down]	Get or set the volume. 0 to 100 sets the volume. 'up' / 'down' increases / decreases by 10 points. No argument displays current volume."
			echo "	playing|status	Show what song is currently playing in Music."
			echo "	playlist [playlist name]	 Play specific playlist"
			return 0 ;;
		(*) print "Unknown option: $opt"
			return 1 ;;
	esac
	osascript -e "tell application \"$APP_NAME\" to $opt" builtin autoload -XU 	result=() 
	local -i width="($(longest-key --length $1) + 10)" 
	local -R $width var_name
	local -L $width var_value
	case ${(Pt)1} in
		(*association*) print -P -- "%U%F{5}${1}%f%u"
			local k v
			for k v in ${(Pkv)1}
			do
				var_name="[${k}]  =" 
				var_value="\"${v}\"" 
				result+=("$var_name" "$var_value") 
			done ;;
		(*array*) print -nr -aC1 -- ${(P)1} ;;
		(*scalar*) print -nr -- "\"${(P)1}\"" ;;
		(*integer*) print -nr -- ${(P)1} ;;
		(*) echo ${(Pt)1} ;;
	esac
	print -nr -aC2 -- ${(@)result} builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	typeset -A opts
	zparseopts -D -E -M -A opts - s -scrollback=s b -buffer=b
	case 1 in
		(${+opts[-s]})  ;;
	esac builtin autoload -XU builtin autoload -XU builtin autoload -XU 	local opts prefix suffix job OPTARG OPTIND ret=1 
	local -a name res results jids
	local -A shortopts
	emulate -L sh
	setopt kshglob noshglob braceexpand nokshautoload
	shortopts=(a alias b builtin c command d directory e export f file g group j job k keyword u user v variable) 
	while getopts "o:A:G:C:F:P:S:W:X:abcdefgjkuv" name
	do
		case $name in
			([abcdefgjkuv]) OPTARG="${shortopts[$name]}"  ;&
			(A) case $OPTARG in
					(alias) results+=("${(k)aliases[@]}")  ;;
					(arrayvar) results+=("${(k@)parameters[(R)array*]}")  ;;
					(binding) results+=("${(k)widgets[@]}")  ;;
					(builtin) results+=("${(k)builtins[@]}" "${(k)dis_builtins[@]}")  ;;
					(command) results+=("${(k)commands[@]}" "${(k)aliases[@]}" "${(k)builtins[@]}" "${(k)functions[@]}" "${(k)reswords[@]}")  ;;
					(directory) setopt bareglobqual
						results+=(${IPREFIX}${PREFIX}*${SUFFIX}${ISUFFIX}(N-/)) 
						setopt nobareglobqual ;;
					(disabled) results+=("${(k)dis_builtins[@]}")  ;;
					(enabled) results+=("${(k)builtins[@]}")  ;;
					(export) results+=("${(k)parameters[(R)*export*]}")  ;;
					(file) setopt bareglobqual
						results+=(${IPREFIX}${PREFIX}*${SUFFIX}${ISUFFIX}(N)) 
						setopt nobareglobqual ;;
					(function) results+=("${(k)functions[@]}")  ;;
					(group) emulate zsh
						_groups -U -O res
						emulate sh
						setopt kshglob noshglob braceexpand
						results+=("${res[@]}")  ;;
					(hostname) emulate zsh
						_hosts -U -O res
						emulate sh
						setopt kshglob noshglob braceexpand
						results+=("${res[@]}")  ;;
					(job) results+=("${savejobtexts[@]%% *}")  ;;
					(keyword) results+=("${(k)reswords[@]}")  ;;
					(running) jids=("${(@k)savejobstates[(R)running*]}") 
						for job in "${jids[@]}"
						do
							results+=(${savejobtexts[$job]%% *}) 
						done ;;
					(stopped) jids=("${(@k)savejobstates[(R)suspended*]}") 
						for job in "${jids[@]}"
						do
							results+=(${savejobtexts[$job]%% *}) 
						done ;;
					(setopt | shopt) results+=("${(k)options[@]}")  ;;
					(signal) results+=("SIG${^signals[@]}")  ;;
					(user) results+=("${(k)userdirs[@]}")  ;;
					(variable) results+=("${(k)parameters[@]}")  ;;
					(helptopic)  ;;
				esac ;;
			(F) COMPREPLY=() 
				local -a args
				args=("${words[0]}" "${@[-1]}" "${words[CURRENT-2]}") 
				() {
					typeset -h words
					$OPTARG "${args[@]}"
				}
				results+=("${COMPREPLY[@]}")  ;;
			(G) setopt nullglob
				results+=(${~OPTARG}) 
				unsetopt nullglob ;;
			(W) results+=(${(Q)~=OPTARG})  ;;
			(C) results+=($(eval $OPTARG))  ;;
			(P) prefix="$OPTARG"  ;;
			(S) suffix="$OPTARG"  ;;
			(X) if [[ ${OPTARG[0]} = '!' ]]
				then
					results=("${(M)results[@]:#${OPTARG#?}}") 
				else
					results=("${results[@]:#$OPTARG}") 
				fi ;;
		esac
	done
	print -l -r -- "$prefix${^results[@]}$suffix" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .execute-named-cmd -- "$@" builtin autoload -XU 	_zsh_highlight_call_widget .read-command -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	[[ "${DISABLE_AUTO_TITLE:-}" == true ]] && return
	emulate -L zsh
	setopt extended_glob
	local -a cmdargs
	cmdargs=("${(z)2}") 
	if [[ "${cmdargs[1]}" = fg ]]
	then
		local job_id jobspec="${cmdargs[2]#%}" 
		case "$jobspec" in
			(<->) job_id=${jobspec}  ;;
			("" | % | +) job_id=${(k)jobstates[(r)*:+:*]}  ;;
			(-) job_id=${(k)jobstates[(r)*:-:*]}  ;;
			([?]*) job_id=${(k)jobtexts[(r)*${(Q)jobspec}*]}  ;;
			(*) job_id=${(k)jobtexts[(r)${(Q)jobspec}*]}  ;;
		esac
		if [[ -n "${jobtexts[$job_id]}" ]]
		then
			1="${jobtexts[$job_id]}" 
			2="${jobtexts[$job_id]}" 
		fi
	fi
	local CMD=${1[(wr)^(*=*|sudo|ssh|mosh|rake|-*)]:gs/%/%%} 
	local LINE="${2:gs/%/%%}" 
	title '$CMD' '%100>...>$LINE%<<' 	local -i retval
	_zsh_autosuggest_highlight_reset
	_zsh_autosuggest_enable $@
	retval=$? 
	_zsh_autosuggest_highlight_apply
	zle -R
	return $retval 	emulate -L zsh
	local args void cmd print remove
	args=("$@") 
	zparseopts -D -a void o: A: G: W: C: F: P: S: X: a b c d e f g j k u v p=print r=remove
	if [[ -n $print ]]
	then
		printf 'complete %2$s %1$s
' "${(@kv)_comps[(R)_bash*]#* }"
	elif [[ -n $remove ]]
	then
		for cmd
		do
			unset "_comps[$cmd]"
		done
	else
		compdef _bash_complete\ ${(j. .)${(q)args[1,-1-$#]}} "$@"
	fi 	_zsh_highlight_call_widget .history-beginning-search-forward -- "$@" builtin autoload -XU builtin autoload -XU 	print -r -- "${fg[$0]}${argv}${fg[default]}"
	return $(( $# == 0 )) 	typeset -g suggestion
	local -a strategies
	local strategy
	strategies=(${=ZSH_AUTOSUGGEST_STRATEGY}) 
	for strategy in $strategies
	do
		_zsh_autosuggest_strategy_$strategy "$1"
		[[ "$suggestion" != "$1"* ]] && unset suggestion
		[[ -n "$suggestion" ]] && break
	done 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-_history-complete-older -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .menu-select -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .beginning-of-buffer-or-history -- "$@" 	emulate -L zsh
	local suggestion="$1" 
	if [[ -n "$suggestion" ]] && (( $#BUFFER ))
	then
		POSTDISPLAY="${suggestion#$BUFFER}" 
	else
		unset POSTDISPLAY
	fi builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-open-line-above -- "$@" 	unset POSTDISPLAY
	_zsh_autosuggest_invoke_original_widget $@ builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-open-line-below -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .vi-forward-blank-word-end -- "$@" builtin autoload -XU builtin autoload -XU 	builtin zle "$@" && _zsh_highlight 	emulate -LR zsh
	setopt extendedglob
	if [[ "$1" =~ ^[-][0-9]+$ ]]
	then
		set -- '--code' ${1#-} ${argv:2}
	fi
	[[ ! -v SET_ERROR_TRAP ]] && export SET_ERROR_TRAP=1 
	local -A opts
	opts=([--code]=1 [--message]="" [--color]="red" [--usage]="") 
	zparseopts-generate -A opts --short-options --ignore 'color' -- $argv
	if builtin zselect -t 1 -r 0
	then
		local -a input=() 
		setarray input /dev/stdin
		set -- $input $argv
	fi
	local c_error=${opts[--color]} c_usage='cyan' 
	local error_title="%F{$c_error}\${\${0#\$ZSH_ARGZERO}:-Error}%f" 
	local usage_title="%F{$c_usage}Usage%f" 
	local -i code=${opts[--code]} title_width=6 
	local -a message=(${opts[--message]} $argv) 
	local -a usage=(${opts[--usage]}) 
	local -a error_trap=() 
	if [[ -n "$message" ]]
	then
		error_trap+="print -P -- \"${error_title}: ${message}\";" 
	fi
	if [[ -n "$usage" ]]
	then
		set -A usage ${(@fs:; :)^usage}$'
	'
		error_trap+="print -P -x ${title_width} -- \"${usage_title}: ${usage}\";" 
	fi
	if [[ $code -ne 0 ]]
	then
		error_trap+="return ${code};" 
	fi
	if [[ $SET_ERROR_TRAP -eq 1 ]]
	then
		trap "{${(F)error_trap}} >&2" EXIT
	fi
	return $code builtin autoload -XU builtin autoload -XU builtin autoload -XU 	emulate -LR zsh
	setopt extendedglob
	local prefix"=${ITERM_PROFILE%: *}: "
	local -a profiles=('Dark' 'Light') 
	local profile_name
	if [[ $# -eq 0 ]]
	then
		fn print-help $0
		error -1 'enter a command'
	fi
	it2_set-profile () {
		profile_name="${prefix}${1#$prefix}" 
		printf 'Setting iTerm2 profile to %s%b
' "${profile_name}" "]1337;SetProfile=${profile_name}" >&2
		export ITERM_PROFILE="${profile_name}" 
		return 0
	}
	it2_switch-profile () {
		local -i i=${profiles[(i)${ITERM_PROFILE#$prefix}]} 
		let i="($i % ${#profiles}) + 1"
		profile_name="${profiles[$i]}" 
		it2_set-profile "$profile_name"
		return $?
	}
	it2_split () {
		local -a opts=() 
		while [[ "$1" =~ ^- ]]
		do
			case "$1" in
				(-r | --right) opts+=('--vertical')  ;;
				(-l | --left) opts+=('--vertical' '--before')  ;;
				(-d | --down) opts+=()  ;;
				(-u | --up) opts+=('--before')  ;;
			esac
			shift
		done
		if [[ -n "$1" ]]
		then
			opts+=('--profile' "$1") 
		fi
		iterm2api split-pane ${opts} ${ITERM_SESSION_ID#*:}
	}
	it2_list-window-hotkeys () {
		if [[ -t 1 ]]
		then
			print -u2 -P -- '%F{3}Window Hotkeys%f:'
		fi
		print -aC2 -nr -u2 -x4 -- $'	'${(@kv)^it2window_map}
		if [[ -t 1 ]]
		then
			print -u2 -n $'

'
		fi
		return 0
	}
	it2_window () {
		local input
		if [[ $# -eq 0 ]]
		then
			it2_list-window-hotkeys
			read input'?Enter window hotkey or full profile name: '
		else
			input=$1 
		fi
		local hotkey profile_name
		hotkey="${it2window_map[(r)(|*,)$input(,*|)]}" 
		profile_name="${it2window_map[$hotkey]}" 
		local hotkey profile_name
		print -P -- "Creating new window with profile" "\"%U%F{3}${profile_name:=$input}%f%u\""
		iterm2api create-tab --profile "${profile_name:=$input}" > /dev/null
		return 0
	}
	typeset cmd=$1 
	shift
	if [[ ${+functions[${0}_${cmd}]} -ne 1 ]]
	then
		error -127 'invalid command: ${cmd}'
	fi
	${0}_${cmd} $argv
	return $? builtin autoload -XU builtin autoload -XU 	emulate -L zsh
	setopt EXTENDED_GLOB
	local prefix="${1//(#m)[\*?[\]<>()|^~#]/\$MATCH}" 
	local pattern="$prefix*" 
	if [[ -n $ZSH_AUTOSUGGEST_HISTORY_IGNORE ]]
	then
		pattern="($pattern)~($ZSH_AUTOSUGGEST_HISTORY_IGNORE)" 
	fi
	typeset -g suggestion="${history[(r)$pattern]}"  builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	return 1 	compstate[insert]=1 
	unset 'compstate[list]' builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget orig-s0.0000030000-r6659-_complete_help -- "$@" builtin autoload -XU builtin autoload -XU 	_zsh_highlight_call_widget .self-insert-unmeta -- "$@" builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU 	osascript 2> /dev/null <<EOF
    tell application "Finder"
      return POSIX path of (insertion location as alias)
    end tell
EOF 	BZR_CB=`bzr nick 2> /dev/null | grep -v "ERROR" | cut -d ":" -f2 | awk -F / '{print "bzr::"$1}'` 
	if [ -n "$BZR_CB" ]
	then
		BZR_DIRTY="" 
		[[ -n `bzr status` ]] && BZR_DIRTY=" %{$fg[red]%} * %{$fg[green]%}" 
		echo "$ZSH_THEME_SCM_PROMPT_PREFIX$BZR_CB$BZR_DIRTY$ZSH_THEME_GIT_PROMPT_SUFFIX"
	fi builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU builtin autoload -XU
